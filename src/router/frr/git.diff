diff -urpN frr-frr-8.1/.git/FETCH_HEAD frr/.git/FETCH_HEAD
diff -urpN frr-frr-8.1/.git/HEAD frr/.git/HEAD
diff -urpN frr-frr-8.1/.git/ORIG_HEAD frr/.git/ORIG_HEAD
diff -urpN frr-frr-8.1/.git/config frr/.git/config
diff -urpN frr-frr-8.1/.git/description frr/.git/description
diff -urpN frr-frr-8.1/.git/hooks/applypatch-msg.sample frr/.git/hooks/applypatch-msg.sample
diff -urpN frr-frr-8.1/.git/hooks/commit-msg.sample frr/.git/hooks/commit-msg.sample
diff -urpN frr-frr-8.1/.git/hooks/fsmonitor-watchman.sample frr/.git/hooks/fsmonitor-watchman.sample
diff -urpN frr-frr-8.1/.git/hooks/post-update.sample frr/.git/hooks/post-update.sample
diff -urpN frr-frr-8.1/.git/hooks/pre-applypatch.sample frr/.git/hooks/pre-applypatch.sample
diff -urpN frr-frr-8.1/.git/hooks/pre-commit.sample frr/.git/hooks/pre-commit.sample
diff -urpN frr-frr-8.1/.git/hooks/pre-merge-commit.sample frr/.git/hooks/pre-merge-commit.sample
diff -urpN frr-frr-8.1/.git/hooks/pre-push.sample frr/.git/hooks/pre-push.sample
diff -urpN frr-frr-8.1/.git/hooks/pre-rebase.sample frr/.git/hooks/pre-rebase.sample
diff -urpN frr-frr-8.1/.git/hooks/pre-receive.sample frr/.git/hooks/pre-receive.sample
diff -urpN frr-frr-8.1/.git/hooks/prepare-commit-msg.sample frr/.git/hooks/prepare-commit-msg.sample
diff -urpN frr-frr-8.1/.git/hooks/update.sample frr/.git/hooks/update.sample
Binary files frr-frr-8.1/.git/index and frr/.git/index differ
diff -urpN frr-frr-8.1/.git/info/exclude frr/.git/info/exclude
diff -urpN frr-frr-8.1/.git/logs/HEAD frr/.git/logs/HEAD
diff -urpN frr-frr-8.1/.git/logs/refs/heads/master frr/.git/logs/refs/heads/master
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/HEAD frr/.git/logs/refs/remotes/origin/HEAD
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/dev/7.6 frr/.git/logs/refs/remotes/origin/dev/7.6
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/dev/8.2 frr/.git/logs/refs/remotes/origin/dev/8.2
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/dev/mgmtd frr/.git/logs/refs/remotes/origin/dev/mgmtd
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/fuzz frr/.git/logs/refs/remotes/origin/fuzz
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/master frr/.git/logs/refs/remotes/origin/master
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/mergify/bp/stable/8.0/pr-8637 frr/.git/logs/refs/remotes/origin/mergify/bp/stable/8.0/pr-8637
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/mergify/bp/stable/8.0/pr-9490 frr/.git/logs/refs/remotes/origin/mergify/bp/stable/8.0/pr-9490
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/mergify/bp/stable/8.0/pr-9498 frr/.git/logs/refs/remotes/origin/mergify/bp/stable/8.0/pr-9498
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/mergify/bp/stable/8.0/pr-9504 frr/.git/logs/refs/remotes/origin/mergify/bp/stable/8.0/pr-9504
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/rc/8.1 frr/.git/logs/refs/remotes/origin/rc/8.1
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/revert-8216-add_rd_all frr/.git/logs/refs/remotes/origin/revert-8216-add_rd_all
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/revert-8795-fix-ospf6-router-id frr/.git/logs/refs/remotes/origin/revert-8795-fix-ospf6-router-id
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/revert-9175-mergify/bp/stable/8.0/pr-8983 frr/.git/logs/refs/remotes/origin/revert-9175-mergify/bp/stable/8.0/pr-8983
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/revert-9179-PR9001-for-8.0 frr/.git/logs/refs/remotes/origin/revert-9179-PR9001-for-8.0
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/stable/7.2 frr/.git/logs/refs/remotes/origin/stable/7.2
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/stable/7.3 frr/.git/logs/refs/remotes/origin/stable/7.3
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/stable/7.4 frr/.git/logs/refs/remotes/origin/stable/7.4
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/stable/7.5 frr/.git/logs/refs/remotes/origin/stable/7.5
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/stable/8.0 frr/.git/logs/refs/remotes/origin/stable/8.0
diff -urpN frr-frr-8.1/.git/logs/refs/remotes/origin/stable/8.1 frr/.git/logs/refs/remotes/origin/stable/8.1
Binary files frr-frr-8.1/.git/objects/pack/pack-011fd4e2af6f4291e1e94873601e2ed07c69a475.idx and frr/.git/objects/pack/pack-011fd4e2af6f4291e1e94873601e2ed07c69a475.idx differ
Binary files frr-frr-8.1/.git/objects/pack/pack-011fd4e2af6f4291e1e94873601e2ed07c69a475.pack and frr/.git/objects/pack/pack-011fd4e2af6f4291e1e94873601e2ed07c69a475.pack differ
Binary files frr-frr-8.1/.git/objects/pack/pack-4e6204f7bace4f3b1b4eb2db065719b020fdf696.idx and frr/.git/objects/pack/pack-4e6204f7bace4f3b1b4eb2db065719b020fdf696.idx differ
Binary files frr-frr-8.1/.git/objects/pack/pack-4e6204f7bace4f3b1b4eb2db065719b020fdf696.pack and frr/.git/objects/pack/pack-4e6204f7bace4f3b1b4eb2db065719b020fdf696.pack differ
Binary files frr-frr-8.1/.git/objects/pack/pack-6b1bfd62b42299a9f1a041cd0151fffb2194de8b.idx and frr/.git/objects/pack/pack-6b1bfd62b42299a9f1a041cd0151fffb2194de8b.idx differ
Binary files frr-frr-8.1/.git/objects/pack/pack-6b1bfd62b42299a9f1a041cd0151fffb2194de8b.pack and frr/.git/objects/pack/pack-6b1bfd62b42299a9f1a041cd0151fffb2194de8b.pack differ
Binary files frr-frr-8.1/.git/objects/pack/pack-d3d06f80fdde43e24c3db7ea15f28d423541c1e2.idx and frr/.git/objects/pack/pack-d3d06f80fdde43e24c3db7ea15f28d423541c1e2.idx differ
Binary files frr-frr-8.1/.git/objects/pack/pack-d3d06f80fdde43e24c3db7ea15f28d423541c1e2.pack and frr/.git/objects/pack/pack-d3d06f80fdde43e24c3db7ea15f28d423541c1e2.pack differ
Binary files frr-frr-8.1/.git/objects/pack/pack-d4e2b2a1aa78168a56864307771b6a92ea7fe2c1.idx and frr/.git/objects/pack/pack-d4e2b2a1aa78168a56864307771b6a92ea7fe2c1.idx differ
Binary files frr-frr-8.1/.git/objects/pack/pack-d4e2b2a1aa78168a56864307771b6a92ea7fe2c1.pack and frr/.git/objects/pack/pack-d4e2b2a1aa78168a56864307771b6a92ea7fe2c1.pack differ
diff -urpN frr-frr-8.1/.git/packed-refs frr/.git/packed-refs
diff -urpN frr-frr-8.1/.git/refs/heads/master frr/.git/refs/heads/master
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/HEAD frr/.git/refs/remotes/origin/HEAD
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/dev/7.6 frr/.git/refs/remotes/origin/dev/7.6
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/dev/8.2 frr/.git/refs/remotes/origin/dev/8.2
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/dev/mgmtd frr/.git/refs/remotes/origin/dev/mgmtd
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/fuzz frr/.git/refs/remotes/origin/fuzz
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/master frr/.git/refs/remotes/origin/master
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/mergify/bp/stable/8.0/pr-8637 frr/.git/refs/remotes/origin/mergify/bp/stable/8.0/pr-8637
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/mergify/bp/stable/8.0/pr-9490 frr/.git/refs/remotes/origin/mergify/bp/stable/8.0/pr-9490
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/mergify/bp/stable/8.0/pr-9498 frr/.git/refs/remotes/origin/mergify/bp/stable/8.0/pr-9498
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/mergify/bp/stable/8.0/pr-9504 frr/.git/refs/remotes/origin/mergify/bp/stable/8.0/pr-9504
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/rc/8.1 frr/.git/refs/remotes/origin/rc/8.1
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/revert-8216-add_rd_all frr/.git/refs/remotes/origin/revert-8216-add_rd_all
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/revert-8795-fix-ospf6-router-id frr/.git/refs/remotes/origin/revert-8795-fix-ospf6-router-id
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/revert-9175-mergify/bp/stable/8.0/pr-8983 frr/.git/refs/remotes/origin/revert-9175-mergify/bp/stable/8.0/pr-8983
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/revert-9179-PR9001-for-8.0 frr/.git/refs/remotes/origin/revert-9179-PR9001-for-8.0
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/stable/7.2 frr/.git/refs/remotes/origin/stable/7.2
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/stable/7.3 frr/.git/refs/remotes/origin/stable/7.3
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/stable/7.4 frr/.git/refs/remotes/origin/stable/7.4
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/stable/7.5 frr/.git/refs/remotes/origin/stable/7.5
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/stable/8.0 frr/.git/refs/remotes/origin/stable/8.0
diff -urpN frr-frr-8.1/.git/refs/remotes/origin/stable/8.1 frr/.git/refs/remotes/origin/stable/8.1
diff -urpN frr-frr-8.1/.git/refs/tags/8.0-dev frr/.git/refs/tags/8.0-dev
diff -urpN frr-frr-8.1/.git/refs/tags/8.1-dev frr/.git/refs/tags/8.1-dev
diff -urpN frr-frr-8.1/.git/refs/tags/base_7.6 frr/.git/refs/tags/base_7.6
diff -urpN frr-frr-8.1/.git/refs/tags/base_8.0 frr/.git/refs/tags/base_8.0
diff -urpN frr-frr-8.1/.git/refs/tags/base_8.1 frr/.git/refs/tags/base_8.1
diff -urpN frr-frr-8.1/.git/refs/tags/base_8.2 frr/.git/refs/tags/base_8.2
diff -urpN frr-frr-8.1/.git/refs/tags/frr-7.5-dev frr/.git/refs/tags/frr-7.5-dev
diff -urpN frr-frr-8.1/.git/refs/tags/frr-7.5.1 frr/.git/refs/tags/frr-7.5.1
diff -urpN frr-frr-8.1/.git/refs/tags/frr-7.6-dev frr/.git/refs/tags/frr-7.6-dev
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.0 frr/.git/refs/tags/frr-8.0
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.0-dev frr/.git/refs/tags/frr-8.0-dev
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.0.1 frr/.git/refs/tags/frr-8.0.1
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.1 frr/.git/refs/tags/frr-8.1
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.1-dev frr/.git/refs/tags/frr-8.1-dev
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.1-rc1 frr/.git/refs/tags/frr-8.1-rc1
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.1-rc2 frr/.git/refs/tags/frr-8.1-rc2
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.2-dev frr/.git/refs/tags/frr-8.2-dev
diff -urpN frr-frr-8.1/.git/refs/tags/frr-8.3-dev frr/.git/refs/tags/frr-8.3-dev
diff -urpN frr-frr-8.1/bfdd/bfd.c frr/bfdd/bfd.c
--- frr-frr-8.1/bfdd/bfd.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/bfdd/bfd.c	2022-02-15 18:58:51.836291037 +0700
@@ -1256,27 +1256,6 @@ void bs_final_handler(struct bfd_session
 	/* Apply new transmission timer immediately. */
 	ptm_bfd_start_xmt_timer(bs, false);
 
-	/*
-	 * Detection timeout calculation:
-	 * The minimum detection timeout is the remote detection
-	 * multipler (number of packets to be missed) times the agreed
-	 * transmission interval.
-	 *
-	 * RFC 5880, Section 6.8.4.
-	 *
-	 * TODO: support sending/counting more packets inside detection
-	 * timeout.
-	 */
-	if (bs->timers.required_min_rx > bs->remote_timers.desired_min_tx)
-		bs->detect_TO = bs->remote_detect_mult
-				* bs->timers.required_min_rx;
-	else
-		bs->detect_TO = bs->remote_detect_mult
-				* bs->remote_timers.desired_min_tx;
-
-	/* Apply new receive timer immediately. */
-	bfd_recvtimer_update(bs);
-
 	/* Notify watchers about changed timers. */
 	control_notify_config(BCM_NOTIFY_CONFIG_UPDATE, bs);
 }
diff -urpN frr-frr-8.1/bfdd/bfd_packet.c frr/bfdd/bfd_packet.c
--- frr-frr-8.1/bfdd/bfd_packet.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/bfdd/bfd_packet.c	2022-02-15 18:58:51.836291037 +0700
@@ -693,11 +693,26 @@ int bfd_recv_cb(struct thread *t)
 
 		/* Handle poll finalization. */
 		bs_final_handler(bfd);
-	} else {
-		/* Received a packet, lets update the receive timer. */
-		bfd_recvtimer_update(bfd);
 	}
 
+	/*
+	 * Detection timeout calculation:
+	 * The minimum detection timeout is the remote detection
+	 * multipler (number of packets to be missed) times the agreed
+	 * transmission interval.
+	 *
+	 * RFC 5880, Section 6.8.4.
+	 */
+	if (bfd->cur_timers.required_min_rx > bfd->remote_timers.desired_min_tx)
+		bfd->detect_TO = bfd->remote_detect_mult
+				 * bfd->cur_timers.required_min_rx;
+	else
+		bfd->detect_TO = bfd->remote_detect_mult
+				 * bfd->remote_timers.desired_min_tx;
+
+	/* Apply new receive timer immediately. */
+	bfd_recvtimer_update(bfd);
+
 	/* Handle echo timers changes. */
 	bs_echo_timer_handler(bfd);
 
diff -urpN frr-frr-8.1/bgpd/bgp_attr.c frr/bgpd/bgp_attr.c
--- frr-frr-8.1/bgpd/bgp_attr.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/bgpd/bgp_attr.c	2022-02-15 18:58:51.842957721 +0700
@@ -1073,7 +1073,9 @@ struct attr *bgp_attr_aggregate_intern(
 		new = bgp_attr_intern(&attr);
 	}
 
-	aspath_unintern(&new->aspath);
+	/* Always release the 'intern()'ed AS Path. */
+	aspath_unintern(&attr.aspath);
+
 	return new;
 }
 
diff -urpN frr-frr-8.1/bgpd/bgp_bfd.c frr/bgpd/bgp_bfd.c
--- frr-frr-8.1/bgpd/bgp_bfd.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/bgpd/bgp_bfd.c	2022-02-15 18:58:51.842957721 +0700
@@ -163,7 +163,7 @@ void bgp_peer_bfd_update_source(struct p
 		return;
 
 	/* Figure out the correct source to use. */
-	if (CHECK_FLAG(p->flags, PEER_FLAG_UPDATE_SOURCE))
+	if (CHECK_FLAG(p->flags, PEER_FLAG_UPDATE_SOURCE) && p->update_source)
 		source = p->update_source;
 	else
 		source = p->su_local;
diff -urpN frr-frr-8.1/bgpd/bgp_bmp.c frr/bgpd/bgp_bmp.c
--- frr-frr-8.1/bgpd/bgp_bmp.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/bgpd/bgp_bmp.c	2022-02-15 18:58:51.842957721 +0700
@@ -688,22 +688,32 @@ static int bmp_outgoing_packet(struct pe
 	return 0;
 }
 
-static int bmp_peer_established(struct peer *peer)
+static int bmp_peer_status_changed(struct peer *peer)
 {
 	struct bmp_bgp *bmpbgp = bmp_bgp_find(peer->bgp);
+	struct bmp_bgp_peer *bbpeer, *bbdopp;
 
 	frrtrace(1, frr_bgp, bmp_peer_status_changed, peer);
 
 	if (!bmpbgp)
 		return 0;
 
+	if (peer->status == Deleted) {
+		bbpeer = bmp_bgp_peer_find(peer->qobj_node.nid);
+		if (bbpeer) {
+			XFREE(MTYPE_BMP_OPEN, bbpeer->open_rx);
+			XFREE(MTYPE_BMP_OPEN, bbpeer->open_tx);
+			bmp_peerh_del(&bmp_peerh, bbpeer);
+			XFREE(MTYPE_BMP_PEER, bbpeer);
+		}
+		return 0;
+	}
+
 	/* Check if this peer just went to Established */
 	if ((peer->ostatus != OpenConfirm) || !(peer_established(peer)))
 		return 0;
 
 	if (peer->doppelganger && (peer->doppelganger->status != Deleted)) {
-		struct bmp_bgp_peer *bbpeer, *bbdopp;
-
 		bbpeer = bmp_bgp_peer_get(peer);
 		bbdopp = bmp_bgp_peer_find(peer->doppelganger->qobj_node.nid);
 		if (bbdopp) {
@@ -2435,7 +2445,7 @@ static int bgp_bmp_module_init(void)
 {
 	hook_register(bgp_packet_dump, bmp_mirror_packet);
 	hook_register(bgp_packet_send, bmp_outgoing_packet);
-	hook_register(peer_status_changed, bmp_peer_established);
+	hook_register(peer_status_changed, bmp_peer_status_changed);
 	hook_register(peer_backward_transition, bmp_peer_backward);
 	hook_register(bgp_process, bmp_process);
 	hook_register(bgp_inst_config_write, bmp_config_write);
diff -urpN frr-frr-8.1/bgpd/bgp_route.c frr/bgpd/bgp_route.c
--- frr-frr-8.1/bgpd/bgp_route.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/bgpd/bgp_route.c	2022-02-15 18:58:51.859624431 +0700
@@ -2054,7 +2054,7 @@ bool subgroup_announce_check(struct bgp_
 		if ((CHECK_FLAG(peer->af_flags[afi][safi],
 				PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED)
 		     && IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_local))
-		    || (!reflect
+		    || (!reflect && !transparent
 			&& IN6_IS_ADDR_LINKLOCAL(&peer->nexthop.v6_local)
 			&& peer->shared_network
 			&& (from == bgp->peer_self
@@ -7382,15 +7382,14 @@ void bgp_aggregate_delete(struct bgp *bg
 			if (pi->sub_type == BGP_ROUTE_AGGREGATE)
 				continue;
 
-			if (aggregate->summary_only && pi->extra
-			    && AGGREGATE_MED_VALID(aggregate)) {
-				if (aggr_unsuppress_path(aggregate, pi))
-					match++;
-			}
-
-			if (aggregate->suppress_map_name
-			    && AGGREGATE_MED_VALID(aggregate)
-			    && aggr_suppress_map_test(bgp, aggregate, pi)) {
+			/*
+			 * This route is suppressed: attempt to unsuppress it.
+			 *
+			 * `aggr_unsuppress_path` will fail if this particular
+			 * aggregate route was not the suppressor.
+			 */
+			if (pi->extra && pi->extra->aggr_suppressors &&
+			    listcount(pi->extra->aggr_suppressors)) {
 				if (aggr_unsuppress_path(aggregate, pi))
 					match++;
 			}
@@ -12461,7 +12460,7 @@ DEFPY (show_ip_bgp_instance_all,
        JSON_STR
       "Increase table width for longer prefixes\n")
 {
-	afi_t afi = AFI_IP;
+	afi_t afi = AFI_IP6;
 	safi_t safi = SAFI_UNICAST;
 	struct bgp *bgp = NULL;
 	int idx = 0;
@@ -13748,7 +13747,11 @@ static int peer_adj_routes(struct vty *v
 			       &output_count, &filtered_count);
 
 	if (use_json) {
-		json_object_object_add(json, "advertisedRoutes", json_ar);
+		if (type == bgp_show_adj_route_advertised)
+			json_object_object_add(json, "advertisedRoutes",
+					       json_ar);
+		else
+			json_object_object_add(json, "receivedRoutes", json_ar);
 		json_object_int_add(json, "totalPrefixCounter", output_count);
 		json_object_int_add(json, "filteredPrefixCounter",
 				    filtered_count);
@@ -14084,7 +14087,7 @@ DEFUN (show_ip_bgp_flowspec_routes_detai
        "Detailed information on flowspec entries\n"
        JSON_STR)
 {
-	afi_t afi = AFI_IP;
+	afi_t afi = AFI_IP6;
 	safi_t safi = SAFI_UNICAST;
 	struct bgp *bgp = NULL;
 	int idx = 0;
diff -urpN frr-frr-8.1/isisd/isis_adjacency.c frr/isisd/isis_adjacency.c
--- frr-frr-8.1/isisd/isis_adjacency.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/isisd/isis_adjacency.c	2022-02-15 18:58:51.892957851 +0700
@@ -327,15 +327,18 @@ void isis_adj_state_change(struct isis_a
 				adj->flaps++;
 			} else if (old_state == ISIS_ADJ_UP) {
 				circuit->adj_state_changes++;
-				listnode_delete(circuit->u.bc.adjdb[level - 1],
-						adj);
 
 				circuit->upadjcount[level - 1]--;
 				if (circuit->upadjcount[level - 1] == 0)
 					isis_tx_queue_clean(circuit->tx_queue);
 
-				if (new_state == ISIS_ADJ_DOWN)
+				if (new_state == ISIS_ADJ_DOWN) {
+					listnode_delete(
+						circuit->u.bc.adjdb[level - 1],
+						adj);
+
 					del = true;
+				}
 			}
 
 			if (circuit->u.bc.lan_neighs[level - 1]) {
@@ -374,14 +377,17 @@ void isis_adj_state_change(struct isis_a
 							 &circuit->t_send_csnp[1]);
 				}
 			} else if (old_state == ISIS_ADJ_UP) {
-				if (adj->circuit->u.p2p.neighbor == adj)
-					adj->circuit->u.p2p.neighbor = NULL;
 				circuit->upadjcount[level - 1]--;
 				if (circuit->upadjcount[level - 1] == 0)
 					isis_tx_queue_clean(circuit->tx_queue);
 
-				if (new_state == ISIS_ADJ_DOWN)
+				if (new_state == ISIS_ADJ_DOWN) {
+					if (adj->circuit->u.p2p.neighbor == adj)
+						adj->circuit->u.p2p.neighbor =
+							NULL;
+
 					del = true;
+				}
 			}
 		}
 	}
diff -urpN frr-frr-8.1/lib/elf_py.c frr/lib/elf_py.c
--- frr-frr-8.1/lib/elf_py.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/lib/elf_py.c	2022-02-15 18:58:51.909624562 +0700
@@ -636,6 +636,9 @@ static Elf_Scn *elf_find_addr(struct elf
 		Elf_Scn *scn = elf_getscn(ef->elf, i);
 		GElf_Shdr _shdr, *shdr = gelf_getshdr(scn, &_shdr);
 
+		/* virtual address is kinda meaningless for TLS sections */
+		if (shdr->sh_flags & SHF_TLS)
+			continue;
 		if (addr < shdr->sh_addr ||
 		    addr >= shdr->sh_addr + shdr->sh_size)
 			continue;
diff -urpN frr-frr-8.1/lib/plist.c frr/lib/plist.c
--- frr-frr-8.1/lib/plist.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/lib/plist.c	2022-02-15 18:58:51.916291246 +0700
@@ -1489,9 +1489,9 @@ int prefix_bgp_orf_set(char *name, afi_t
 	struct prefix_list_entry *pentry;
 
 	/* ge and le value check */
-	if (orfp->ge && orfp->ge <= orfp->p.prefixlen)
+	if (orfp->ge && orfp->ge < orfp->p.prefixlen)
 		return CMD_WARNING_CONFIG_FAILED;
-	if (orfp->le && orfp->le <= orfp->p.prefixlen)
+	if (orfp->le && orfp->le < orfp->p.prefixlen)
 		return CMD_WARNING_CONFIG_FAILED;
 	if (orfp->le && orfp->ge > orfp->le)
 		return CMD_WARNING_CONFIG_FAILED;
diff -urpN frr-frr-8.1/ospfd/ospf_interface.c frr/ospfd/ospf_interface.c
--- frr-frr-8.1/ospfd/ospf_interface.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/ospfd/ospf_interface.c	2022-02-15 18:58:51.936291298 +0700
@@ -705,11 +705,11 @@ static int ospf_if_delete_hook(struct in
 	 */
 	ospf_del_if_params(ifp, IF_DEF_PARAMS(ifp));
 
-	route_table_finish(IF_OIFS(ifp));
-
 	for (rn = route_top(IF_OIFS_PARAMS(ifp)); rn; rn = route_next(rn))
 		if (rn->info)
 			ospf_del_if_params(ifp, rn->info);
+
+	route_table_finish(IF_OIFS(ifp));
 	route_table_finish(IF_OIFS_PARAMS(ifp));
 
 	XFREE(MTYPE_OSPF_IF_INFO, ifp->info);
diff -urpN frr-frr-8.1/tests/topotests/nhrp_topo/test_nhrp_topo.py frr/tests/topotests/nhrp_topo/test_nhrp_topo.py
--- frr-frr-8.1/tests/topotests/nhrp_topo/test_nhrp_topo.py	2021-11-08 10:44:24.000000000 +0700
+++ frr/tests/topotests/nhrp_topo/test_nhrp_topo.py	2022-02-15 18:58:52.059624955 +0700
@@ -41,6 +41,7 @@ sys.path.append(os.path.join(CWD, "../")
 from lib import topotest
 from lib.topogen import Topogen, TopoRouter, get_topogen
 from lib.topolog import logger
+from lib.common_config import required_linux_kernel_version
 
 # Required to instantiate the topology builder class.
 
@@ -99,6 +100,11 @@ def _populate_iface():
 
 def setup_module(mod):
     "Sets up the pytest environment"
+
+    result = required_linux_kernel_version("5.0")
+    if result is not True:
+        pytest.skip("Kernel requirements are not met")
+
     tgen = Topogen(build_topo, mod.__name__)
     tgen.start_topology()
 
Binary files frr-frr-8.1/usr/bin/vtysh and frr/usr/bin/vtysh differ
diff -urpN frr-frr-8.1/usr/lib/frr/modules/bgpd_bmp.la frr/usr/lib/frr/modules/bgpd_bmp.la
--- frr-frr-8.1/usr/lib/frr/modules/bgpd_bmp.la	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/lib/frr/modules/bgpd_bmp.la	2021-08-31 15:25:52.378888926 +0700
@@ -0,0 +1,41 @@
+# bgpd_bmp.la - a libtool library file
+# Generated by libtool (GNU libtool) 2.4.6
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='bgpd_bmp.so'
+
+# Names of this library.
+library_names='bgpd_bmp.so bgpd_bmp.so bgpd_bmp.so'
+
+# The name of the static archive.
+old_library=''
+
+# Linker flags that cannot go in dependency_libs.
+inherited_linker_flags=''
+
+# Libraries that this one depends upon.
+dependency_libs=' -L/home/seg/DEV/x86_64/src/router/readline/shlib -L/home/seg/DEV/x86_64/src/router/ncurses/lib -lncurses -L/home/seg/DEV/x86_64/src/router/json-c/.libs -L/home/seg/DEV/x86_64/src/router/libyang/build -lyang -L/home/seg/DEV/x86_64/src/router/pcre/.libs /home/seg/DEV/x86_64/src/router/pcre/.libs/libpcre.la -L/home/seg/DEV/x86_64/src/router/libcap/libcap -lcap -lresolv -lcrypt /home/seg/DEV/x86_64/src/router/_staging/usr/lib/libjson-c.la -lm'
+
+# Names of additional weak libraries provided by this library
+weak_library_names=''
+
+# Version information for bgpd_bmp.
+current=0
+age=0
+revision=0
+
+# Is this an already installed library?
+installed=yes
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=yes
+
+# Files to dlopen/dlpreopen
+dlopen=''
+dlpreopen=''
+
+# Directory that this library needs to be installed in:
+libdir='/usr/tmp/frr/modules'
Binary files frr-frr-8.1/usr/lib/frr/modules/bgpd_bmp.so and frr/usr/lib/frr/modules/bgpd_bmp.so differ
diff -urpN frr-frr-8.1/usr/lib/frr/modules/dplane_fpm_nl.la frr/usr/lib/frr/modules/dplane_fpm_nl.la
--- frr-frr-8.1/usr/lib/frr/modules/dplane_fpm_nl.la	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/lib/frr/modules/dplane_fpm_nl.la	2021-08-31 15:25:52.378888926 +0700
@@ -0,0 +1,41 @@
+# dplane_fpm_nl.la - a libtool library file
+# Generated by libtool (GNU libtool) 2.4.6
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='dplane_fpm_nl.so'
+
+# Names of this library.
+library_names='dplane_fpm_nl.so dplane_fpm_nl.so dplane_fpm_nl.so'
+
+# The name of the static archive.
+old_library=''
+
+# Linker flags that cannot go in dependency_libs.
+inherited_linker_flags=''
+
+# Libraries that this one depends upon.
+dependency_libs=' -L/home/seg/DEV/x86_64/src/router/readline/shlib -L/home/seg/DEV/x86_64/src/router/ncurses/lib -lncurses -L/home/seg/DEV/x86_64/src/router/json-c/.libs -L/home/seg/DEV/x86_64/src/router/libyang/build -lyang -L/home/seg/DEV/x86_64/src/router/pcre/.libs /home/seg/DEV/x86_64/src/router/pcre/.libs/libpcre.la -L/home/seg/DEV/x86_64/src/router/libcap/libcap -lcap -lresolv -lcrypt /home/seg/DEV/x86_64/src/router/_staging/usr/lib/libjson-c.la -lm'
+
+# Names of additional weak libraries provided by this library
+weak_library_names=''
+
+# Version information for dplane_fpm_nl.
+current=0
+age=0
+revision=0
+
+# Is this an already installed library?
+installed=yes
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=yes
+
+# Files to dlopen/dlpreopen
+dlopen=''
+dlpreopen=''
+
+# Directory that this library needs to be installed in:
+libdir='/usr/tmp/frr/modules'
Binary files frr-frr-8.1/usr/lib/frr/modules/dplane_fpm_nl.so and frr/usr/lib/frr/modules/dplane_fpm_nl.so differ
diff -urpN frr-frr-8.1/usr/lib/frr/modules/zebra_cumulus_mlag.la frr/usr/lib/frr/modules/zebra_cumulus_mlag.la
--- frr-frr-8.1/usr/lib/frr/modules/zebra_cumulus_mlag.la	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/lib/frr/modules/zebra_cumulus_mlag.la	2021-08-31 15:25:52.378888926 +0700
@@ -0,0 +1,41 @@
+# zebra_cumulus_mlag.la - a libtool library file
+# Generated by libtool (GNU libtool) 2.4.6
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='zebra_cumulus_mlag.so'
+
+# Names of this library.
+library_names='zebra_cumulus_mlag.so zebra_cumulus_mlag.so zebra_cumulus_mlag.so'
+
+# The name of the static archive.
+old_library=''
+
+# Linker flags that cannot go in dependency_libs.
+inherited_linker_flags=''
+
+# Libraries that this one depends upon.
+dependency_libs=' -L/home/seg/DEV/x86_64/src/router/readline/shlib -L/home/seg/DEV/x86_64/src/router/ncurses/lib -lncurses -L/home/seg/DEV/x86_64/src/router/json-c/.libs -L/home/seg/DEV/x86_64/src/router/libyang/build -lyang -L/home/seg/DEV/x86_64/src/router/pcre/.libs /home/seg/DEV/x86_64/src/router/pcre/.libs/libpcre.la -L/home/seg/DEV/x86_64/src/router/libcap/libcap -lcap -lresolv -lcrypt /home/seg/DEV/x86_64/src/router/_staging/usr/lib/libjson-c.la -lm'
+
+# Names of additional weak libraries provided by this library
+weak_library_names=''
+
+# Version information for zebra_cumulus_mlag.
+current=0
+age=0
+revision=0
+
+# Is this an already installed library?
+installed=yes
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=yes
+
+# Files to dlopen/dlpreopen
+dlopen=''
+dlpreopen=''
+
+# Directory that this library needs to be installed in:
+libdir='/usr/tmp/frr/modules'
Binary files frr-frr-8.1/usr/lib/frr/modules/zebra_cumulus_mlag.so and frr/usr/lib/frr/modules/zebra_cumulus_mlag.so differ
diff -urpN frr-frr-8.1/usr/lib/frr/modules/zebra_irdp.la frr/usr/lib/frr/modules/zebra_irdp.la
--- frr-frr-8.1/usr/lib/frr/modules/zebra_irdp.la	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/lib/frr/modules/zebra_irdp.la	2021-08-31 15:25:52.378888926 +0700
@@ -0,0 +1,41 @@
+# zebra_irdp.la - a libtool library file
+# Generated by libtool (GNU libtool) 2.4.6
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='zebra_irdp.so'
+
+# Names of this library.
+library_names='zebra_irdp.so zebra_irdp.so zebra_irdp.so'
+
+# The name of the static archive.
+old_library=''
+
+# Linker flags that cannot go in dependency_libs.
+inherited_linker_flags=''
+
+# Libraries that this one depends upon.
+dependency_libs=' -L/home/seg/DEV/x86_64/src/router/readline/shlib -L/home/seg/DEV/x86_64/src/router/ncurses/lib -lncurses -L/home/seg/DEV/x86_64/src/router/json-c/.libs -L/home/seg/DEV/x86_64/src/router/libyang/build -lyang -L/home/seg/DEV/x86_64/src/router/pcre/.libs /home/seg/DEV/x86_64/src/router/pcre/.libs/libpcre.la -L/home/seg/DEV/x86_64/src/router/libcap/libcap -lcap -lresolv -lcrypt /home/seg/DEV/x86_64/src/router/_staging/usr/lib/libjson-c.la -lm'
+
+# Names of additional weak libraries provided by this library
+weak_library_names=''
+
+# Version information for zebra_irdp.
+current=0
+age=0
+revision=0
+
+# Is this an already installed library?
+installed=yes
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=yes
+
+# Files to dlopen/dlpreopen
+dlopen=''
+dlpreopen=''
+
+# Directory that this library needs to be installed in:
+libdir='/usr/tmp/frr/modules'
Binary files frr-frr-8.1/usr/lib/frr/modules/zebra_irdp.so and frr/usr/lib/frr/modules/zebra_irdp.so differ
Binary files frr-frr-8.1/usr/lib/libfrr.so and frr/usr/lib/libfrr.so differ
Binary files frr-frr-8.1/usr/lib/libfrr.so.0 and frr/usr/lib/libfrr.so.0 differ
Binary files frr-frr-8.1/usr/lib/libfrr.so.0.0.0 and frr/usr/lib/libfrr.so.0.0.0 differ
Binary files frr-frr-8.1/usr/lib/libfrrcares.so and frr/usr/lib/libfrrcares.so differ
Binary files frr-frr-8.1/usr/lib/libfrrcares.so.0 and frr/usr/lib/libfrrcares.so.0 differ
Binary files frr-frr-8.1/usr/lib/libfrrcares.so.0.0.0 and frr/usr/lib/libfrrcares.so.0.0.0 differ
Binary files frr-frr-8.1/usr/sbin/bfdd and frr/usr/sbin/bfdd differ
Binary files frr-frr-8.1/usr/sbin/bgpd and frr/usr/sbin/bgpd differ
diff -urpN frr-frr-8.1/usr/sbin/frr frr/usr/sbin/frr
--- frr-frr-8.1/usr/sbin/frr	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/sbin/frr	2021-08-31 15:25:51.994888474 +0700
@@ -0,0 +1,621 @@
+#!/bin/bash
+#
+### BEGIN INIT INFO
+# Provides: frr
+# Required-Start: $local_fs $network $remote_fs $syslog
+# Required-Stop: $local_fs $network $remote_fs $syslog
+# Default-Start:  2 3 4 5
+# Default-Stop: 0 1 6
+# Short-Description: start and stop the Frr routing suite
+# Description: Frr is a routing suite for IP routing protocols like
+#              BGP, OSPF, RIP and others. This script contols the main
+#              daemon "frr" as well as the individual protocol daemons.
+### END INIT INFO
+#
+
+PATH=/bin:/usr/bin:/sbin:/usr/sbin
+D_PATH="/usr/sbin" # /usr/lib/frr
+C_PATH="/tmp" # /etc/frr
+V_PATH="/var/run" # /var/run/frr
+VTYSH="/usr/bin/vtysh" # /usr/bin/vtysh
+FRR_USER="root" # frr
+FRR_GROUP="root" # frr
+FRR_VTY_GROUP="" # frrvty
+FRR_CONFIG_MODE="0600" # 0600
+FRR_DEFAULT_PROFILE="traditional" # traditional / datacenter
+
+# Local Daemon selection may be done by using /etc/frr/daemons.
+# See /usr/share/doc/frr/README.Debian.gz for further information.
+# Keep zebra first and do not list watchfrr!
+DAEMONS="zebra bgpd ripd ripngd ospfd ospf6d isisd babeld pimd ldpd nhrpd eigrpd sharpd pbrd staticd bfdd fabricd vrrpd"
+MAX_INSTANCES=5
+RELOAD_SCRIPT="$D_PATH/frr-reload.py"
+
+if [ -e /lib/lsb/init-functions ]; then
+	. /lib/lsb/init-functions
+fi
+
+if [ -f $D_PATH/ssd ]; then
+	SSD=$D_PATH/ssd
+else
+	SSD=`which start-stop-daemon`
+fi
+
+# Print the name of the pidfile.
+pidfile()
+{
+	echo "$V_PATH/$1.pid"
+}
+
+# Print the name of the vtysh.
+vtyfile()
+{
+	echo "$V_PATH/$1.vty"
+}
+
+chownfrr()
+{
+	test -n "$FRR_USER" && chown "$FRR_USER" "$1"
+	test -n "$FRR_GROUP" && chgrp "$FRR_GROUP" "$1"
+	test -n "$FRR_CONFIG_MODE" && chmod "$FRR_CONFIG_MODE" "$1"
+}
+
+# Check if daemon is started by using the pidfile.
+started()
+{
+	[ ! -e `pidfile $1` ] && return 3
+	if [ -n "$2" ] && [ "$2" == "log" ]; then
+		status_of_proc -p `pidfile $1` $1 $1 && return 0 || return $?
+	else
+		kill -0 `cat \`pidfile $1\`` 2> /dev/null || return 1
+		return 0
+	fi
+}
+
+# Loads the config via vtysh -b if configured to do so.
+vtysh_b ()
+{
+	# Rember, that all variables have been incremented by 1 in convert_daemon_prios()
+	if [ "$vtysh_enable" = 2 -a -f $C_PATH/frr.conf ]; then
+		$VTYSH -b
+	fi
+}
+
+# Check if the daemon is activated and if its executable and config files
+# are in place.
+# params:       daemon name
+# returns:      0=ok, 1=error
+check_daemon()
+{
+	if [ $1 != "watchfrr" -a $1 != "vtysh_enable" ]; then
+		# check for daemon binary
+		if [ ! -x "$D_PATH/$1" ]; then return 1; fi
+	fi
+
+	# If the integrated config file is used the others are not checked.
+	if [ -r "$C_PATH/frr.conf" ]; then
+		return 0
+	fi
+
+	# vtysh_enable has no config file nor binary so skip check.
+	# (Not sure why vtysh_enable is in this list but does not hurt)
+	if [ $1 != "watchfrr" -a $1 != "vtysh_enable" ]; then
+		# check for config file
+		if [ -n "$2" ]; then
+			if [ ! -r "$C_PATH/$1-$2.conf" ]; then
+				touch "$C_PATH/$1-$2.conf"
+				chownfrr "$C_PATH/$1-$2.conf"
+			fi
+		elif [ ! -r "$C_PATH/$1.conf" ]; then
+			touch "$C_PATH/$1.conf"
+			chownfrr "$C_PATH/$1.conf"
+		fi
+	fi
+	return 0
+}
+
+# Starts the server if it's not alrady running according to the pid file.
+# The Frr daemons creates the pidfile when starting.
+start()
+{
+	local dmn inst
+	dmn="$1"
+	inst="$2"
+
+	ulimit -n $MAX_FDS > /dev/null 2> /dev/null
+	if [ "$dmn" = "watchfrr" ]; then
+
+		# We may need to restart watchfrr if new daemons are added and/or
+		# removed
+		if started "$dmn" ; then
+			stop watchfrr
+		else
+			# Echo only once. watchfrr is printed in the stop above
+			echo -n " $dmn"
+		fi
+
+		eval "set - $watchfrr_options"
+		${SSD} \
+			--start \
+			--pidfile=`pidfile $dmn` \
+			--exec "$D_PATH/$dmn" \
+			-- \
+			"$@"
+
+	elif [ -n "$inst" ]; then
+		echo -n " $dmn-$inst"
+		if ! check_daemon $dmn $inst ; then
+			echo -n " (binary does not exist)"
+			return;
+		fi
+
+		${SSD} \
+			--start \
+			--pidfile=`pidfile $dmn-$inst` \
+			--exec "$D_PATH/$dmn" \
+			-- \
+			`eval echo "$""$dmn""_options"` $frr_global_options -n "$inst"
+	else
+		if ! check_daemon $dmn; then
+			echo -n " (binary does not exist)"
+			return;
+		fi
+
+		if [ "$valgrind_enable" = "yes" ]; then
+			${SSD} \
+				--start \
+				--pidfile=`pidfile $dmn` \
+				--exec "$valgrind" \
+				-- --trace-children=no --leak-check=full --log-file=/var/log/frr/$dmn-valgrind.log $D_PATH/$dmn \
+				`eval echo "$""$dmn""_options"` $frr_global_options
+		else
+			${SSD} \
+				--start \
+				--pidfile=`pidfile $dmn` \
+				--exec "$D_PATH/$dmn" \
+				-- \
+				`eval echo "$""$dmn""_options"` $frr_global_options
+		fi
+	fi
+
+	# Start the staticd automatically
+	if [ "$dmn" = "zebra" ]; then
+		echo -n "starting staticd since zebra is running"
+		if ! check_daemon staticd ; then
+			echo -n " (binary does not exist)"
+			return;
+		fi
+
+		${SSD} \
+			--start \
+			--pidfile=`pidfile staticd` \
+			--exec "$D_PATH/staticd" \
+			-- \
+			`eval echo "$"staticd"_options"` $frr_global_options
+	fi
+}
+
+# Stop the daemon given in the parameter, printing its name to the terminal.
+stop()
+{
+	local inst
+
+	if [ -n "$2" ]; then
+		inst="$1-$2"
+	else
+		inst="$1"
+	fi
+
+	if ! started "$inst" ; then
+		echo -n " ($inst)"
+		return 0
+	else
+		PIDFILE=`pidfile $inst`
+		PID=`cat $PIDFILE 2>/dev/null`
+		kill -2 $PID 2>/dev/null
+		#
+		#       Now we have to wait until $DAEMON has _really_ stopped.
+		#
+		if test -n "$PID" && kill -0 $PID 2>/dev/null; then
+			cnt=0
+			while kill -0 $PID 2>/dev/null; do
+				cnt=`expr $cnt + 1`
+				if [ $cnt -gt 60 ]; then
+					# Waited 120 secs now, fail.
+					echo -n "Failed.. "
+					break
+				fi
+				sleep 2
+			done
+		fi
+		rm -f `pidfile $inst`
+		rm -f `vtyfile $inst`
+
+		if [ "$1" = "zebra" ]; then
+			echo -n "Stopping staticd since zebra is running"
+			stop staticd
+		fi
+	fi
+}
+
+# Converts values from /etc/frr/daemons to all-numeric values.
+convert_daemon_prios()
+{
+	for name in $DAEMONS zebra vtysh_enable watchfrr_enable; do
+		# First, assign the value set by the user to $value
+		eval value=\${${name}:0:3}
+
+		# Daemon not activated or entry missing?
+		if [ "$value" = "no" -o "$value" = "" ]; then value=0; fi
+
+		# These strings parsed for backwards compatibility.
+		if [ "$value" = "yes"  -o  "$value" = "true" ]; then
+			value=1;
+		fi
+
+		# Zebra is threatened special. It must be between 0=off and the first
+		# user assigned value "1" so we increase all other enabled daemons' values.
+		if [ "$name" != "zebra" -a "$value" -gt 0 ]; then value=`expr "$value" + 1`; fi
+
+		# If e.g. name is zebra then we set "zebra=yes".
+		eval $name=$value
+	done
+}
+
+# Starts watchfrr for all wanted daemons.
+start_watchfrr()
+{
+	local daemon_name
+	local daemon_prio
+	local found_one
+	local daemon_inst
+
+	# Start the monitor daemon only if desired.
+	if [ 0 -eq "$watchfrr_enable" ]; then
+		return
+	fi
+
+	# Check variable type
+	if declare -p watchfrr_options | grep -q '^declare \-a'; then
+		# old array support
+		watchfrr_options="${watchfrr_options[@]}"
+	fi
+
+	# Which daemons have been started?
+	found_one=0
+	for daemon_name in $DAEMONS; do
+		eval daemon_prio=\$$daemon_name
+		if [ "$daemon_prio" -gt 0 ]; then
+			eval "daemon_inst=\${${daemon_name}_instances//,/ }"
+			if [ -n "$daemon_inst" ]; then
+				for inst in ${daemon_inst}; do
+					eval "inst_disable=\${${daemon_name}_${inst}}"
+					if [ -z ${inst_disable} ] || [ ${inst_disable} != 0 ]; then
+						if check_daemon $daemon_name $inst; then
+							watchfrr_options="$watchfrr_options ${daemon_name}-${inst}"
+						fi
+					fi
+				done
+			else
+				if check_daemon $daemon_name; then
+					watchfrr_options="$watchfrr_options $daemon_name"
+				fi
+			fi
+			found_one=1
+		fi
+	done
+
+	# Start if at least one daemon is activated.
+	if [ $found_one -eq 1 ]; then
+		start watchfrr
+		echo "."
+	fi
+}
+
+# Stopps watchfrr.
+stop_watchfrr()
+{
+	echo -n "Stopping Frr monitor daemon:"
+	stop watchfrr
+	echo "."
+}
+
+# Stops all daemons that have a lower level of priority than the given.
+# (technically if daemon_prio >= wanted_prio)
+stop_prio()
+{
+	local wanted_prio
+	local daemon_prio
+	local daemon_list
+	local daemon_inst
+	local inst
+
+	if [ -n "$2" ] && [[ "$2" =~ (.*)-(.*) ]]; then
+		daemon=${BASH_REMATCH[1]}
+		inst=${BASH_REMATCH[2]}
+	else
+		daemon="$2"
+	fi
+
+	wanted_prio=$1
+	daemon_list=${daemon:-$DAEMONS}
+
+	echo -n "Stopping Frr daemons (prio:$wanted_prio):"
+
+	for prio_i in `seq 10 -1 $wanted_prio`; do
+		for daemon_name in $daemon_list; do
+			eval daemon_prio=\${${daemon_name}:0:3}
+			daemon_inst=""
+			if [ $daemon_prio -eq $prio_i ]; then
+				eval "daemon_inst=\${${daemon_name}_instances//,/ }"
+				if [ -n "$daemon_inst" ]; then
+					for i in ${daemon_inst}; do
+						if [ -n "$inst" ] && [ "$i" == "$inst" ]; then
+							stop "$daemon_name" "$inst"
+						elif [ x"$inst"  == x ]; then
+							stop "$daemon_name" "$i"
+						fi
+					done
+				else
+					stop "$daemon_name"
+				fi
+			fi
+		done
+	done
+
+	echo "."
+	if [ -z "$inst" ]; then
+		# Now stop other daemons that're prowling, coz the daemons file changed
+		echo -n "Stopping other frr daemons"
+		if [ -n "$daemon" ]; then
+			eval "file_list_suffix="$V_PATH"/"$daemon*""
+		else
+			eval "file_list_suffix="$V_PATH/*""
+		fi
+		for pidfile in $file_list_suffix.pid; do
+			PID=`cat $pidfile 2>/dev/null`
+			${SSD} --stop --quiet --oknodo --pidfile "$pidfile"
+			echo -n "."
+			rm -rf "$pidfile"
+		done
+		echo "."
+
+		echo -n "Removing remaining .vty files"
+		for vtyfile in $file_list_suffix.vty; do
+			rm -rf "$vtyfile"
+		done
+		echo "."
+	fi
+}
+
+# Starts all daemons that have a higher level of priority than the given.
+# (technically if daemon_prio <= wanted_prio)
+start_prio()
+{
+	local wanted_prio
+	local daemon_prio
+	local daemon_list
+	local daemon_name
+	local daemon_inst
+	local inst
+
+	if [ -n "$2" ] && [[ "$2" =~ (.*)-(.*) ]]; then
+		daemon=${BASH_REMATCH[1]}
+		inst=${BASH_REMATCH[2]}
+	else
+		daemon="$2"
+	fi
+
+	wanted_prio=$1
+	daemon_list=${daemon:-$DAEMONS}
+
+	for prio_i in `seq 1 $wanted_prio`; do
+		for daemon_name in $daemon_list; do
+			eval daemon_prio=\$${daemon_name}
+			daemon_inst=""
+			if [ $daemon_prio -eq $prio_i ]; then
+				eval "daemon_inst=\${${daemon_name}_instances//,/ }"
+				if [ -n "$daemon_inst" ]; then
+					if [ `echo "$daemon_inst" | wc -w` -gt ${MAX_INSTANCES} ]; then
+						echo "Max instances supported is ${MAX_INSTANCES}. Aborting"
+						exit 1
+					fi
+					# Check if we're starting again by switching from single instance
+					# to MI version
+					if started "$daemon_name"; then
+						PIDFILE=`pidfile $daemon_name`
+						${SSD} \
+							--stop --quiet --oknodo \
+							--pidfile "$PIDFILE" \
+							--exec "$D_PATH/$daemon_name"
+
+						rm -f `pidfile $1`
+						rm -f `vtyfile $1`
+					fi
+
+					for i in ${daemon_inst}; do
+						if [ -n "$inst" ] && [ "$i" == "$inst" ]; then
+							start "$daemon_name" "$inst"
+						elif [ x"$inst" == x ]; then
+							start "$daemon_name" "$i"
+						fi
+					done
+				else
+					# Check if we're starting again by switching from
+					# single instance to MI version
+					eval "file_list_suffix="$V_PATH"/"$daemon_name-*""
+					for pidfile in $file_list_suffix.pid; do
+						${SSD} --stop --quiet --oknodo --pidfile "$pidfile"
+						rm -rf "$pidfile"
+					done
+					for vtyfile in $file_list_suffix.vty; do
+						rm -rf "$vtyfile"
+					done
+
+					start "$daemon_name"
+				fi
+			fi
+		done
+	done
+}
+
+check_status()
+{
+	local daemon_name
+	local daemon_prio
+	local daemon_inst
+	local failed_status=0
+
+	if [ -n "$1" ] && [[ "$1" =~ (.*)-(.*) ]]; then
+		daemon=${BASH_REMATCH[1]}
+		inst=${BASH_REMATCH[2]}
+	else
+		daemon="$1"
+	fi
+
+	daemon_list=${daemon:-$DAEMONS}
+
+	# Which daemons have been started?
+	for daemon_name in $daemon_list; do
+		eval daemon_prio=\$$daemon_name
+		if [ "$daemon_prio" -gt 0 ]; then
+			eval "daemon_inst=\${${daemon_name}_instances//,/ }"
+			if [ -n "$daemon_inst" ]; then
+				for i in ${daemon_inst}; do
+					if [ -n "$inst" -a "$inst" = "$i" ]; then
+						started "$1" "log" || failed_status=$?
+					elif [ -z "$inst" ]; then
+						started "$daemon_name-$i" "log" || failed_status=$?
+					fi
+				done
+			else
+				started "$daemon_name" "log" || failed_status=$?
+			fi
+		fi
+	done
+
+	# All daemons that need to have been started are up and running
+	return $failed_status
+}
+
+#########################################################
+#               Main program                            #
+#########################################################
+
+# Config broken but script must exit silently.
+[ ! -r "$C_PATH/daemons" ] && exit 0
+
+# Load configuration
+. "$C_PATH/daemons"
+if [ -e "$C_PATH/daemons.conf" ]; then
+	. "$C_PATH/daemons.conf"
+fi
+
+# Read configuration variable file if it is present
+[ -r /etc/default/frr ] && . /etc/default/frr
+
+if test -z "$frr_profile"; then
+	# try to autodetect config profile
+	if test -d /etc/cumulus; then
+		frr_profile=datacenter
+	# elif test ...; then
+	# -- add your distro/system here
+	elif test -n "$FRR_DEFAULT_PROFILE"; then
+		frr_profile="$FRR_DEFAULT_PROFILE"
+	fi
+fi
+test -n "$frr_profile" && frr_global_options="$frr_global_options -F $frr_profile"
+
+MAX_INSTANCES=${MAX_INSTANCES:=5}
+
+# Set priority of un-startable daemons to 'no' and substitute 'yes' to '0'
+convert_daemon_prios
+
+if [ ! -d $V_PATH ]; then
+	echo "Creating $V_PATH"
+	mkdir -p $V_PATH
+	chownfrr $V_PATH
+	chmod 755 /$V_PATH
+fi
+
+if [ -n "$3" ] && [ "$3" != "all" ]; then
+	dmn="$2"-"$3"
+elif [ -n "$2" ] && [ "$2" != "all" ]; then
+	dmn="$2"
+fi
+
+case "$1" in
+	start)
+		# Try to load this necessary (at least for 2.6) module.
+		if [ -d /lib/modules/`uname -r` ] ; then
+			echo "Loading capability module if not yet done."
+			set +e; LC_ALL=C modprobe -a capability 2>&1 | egrep -v "(not found|Can't locate)"; set -e
+		fi
+
+		# Start all daemons
+		cd $C_PATH/
+		if [ "$2" != "watchfrr" ]; then
+			start_prio 10 $dmn
+		fi
+		start_watchfrr
+		vtysh_b
+		;;
+
+	1|2|3|4|5|6|7|8|9|10)
+		# Stop/start daemons for the appropriate priority level
+		stop_prio $1
+		start_prio $1
+		vtysh_b
+		;;
+
+	stop|0)
+		# Stop all daemons at level '0' or 'stop'
+		stop_watchfrr
+		if [ "$dmn" != "watchfrr" ]; then
+			[ -n "${dmn}" ] && eval "${dmn/-/_}=0"
+			stop_prio 0 $dmn
+		fi
+
+		if [ -n "$dmn" -a "$dmn" != "zebra" ]; then
+			[ -n "$dmn" ] && eval "${dmn/-/_}=0"
+			start_watchfrr
+		fi
+		;;
+
+	reload)
+		# Just apply the commands that have changed, no restart necessary
+		if [ ! -x "$RELOAD_SCRIPT" ]; then
+			echo "Please install frr-pythontools package. Required for reload"
+			exit 0
+		fi
+
+		NEW_CONFIG_FILE="${2:-$C_PATH/frr.conf}"
+		[ ! -r $NEW_CONFIG_FILE ] && echo "Unable to read new configuration file $NEW_CONFIG_FILE" && exit 1
+		echo "Applying only incremental changes to running configuration from frr.conf"
+		"$RELOAD_SCRIPT" --reload $C_PATH/frr.conf
+		exit $?
+		;;
+
+	status)
+		check_status $dmn
+		exit $?
+		;;
+
+	restart|force-reload)
+		$0 stop $dmn
+		sleep 1
+		$0 start $dmn
+		;;
+
+	*)
+		echo "Usage: /etc/init.d/frr {start|stop|status|reload|restart|force-reload|<priority>} [daemon]"
+		echo "       E.g. '/etc/init.d/frr 5' would start all daemons with a prio 1-5."
+		echo "       reload applies only modifications from the running config to all daemons."
+		echo "       reload neither restarts starts any daemon nor starts any new ones."
+		echo "       Read /usr/share/doc/frr/README.Debian for details."
+		exit 1
+		;;
+esac
+
+echo "Exiting from the script"
+exit 0
diff -urpN frr-frr-8.1/usr/sbin/frr-reload frr/usr/sbin/frr-reload
--- frr-frr-8.1/usr/sbin/frr-reload	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/sbin/frr-reload	2021-08-31 15:25:51.990888469 +0700
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+if test -e /usr/lib/frr/frr-reload.py; then
+   exec /usr/lib/frr/frr-reload.py --reload /etc/frr/frr.conf
+fi
+>&2 echo "Please install frr-pythontools package. Required for reload"
+exit 1
diff -urpN frr-frr-8.1/usr/sbin/frr-reload.py frr/usr/sbin/frr-reload.py
--- frr-frr-8.1/usr/sbin/frr-reload.py	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/sbin/frr-reload.py	2021-08-31 15:25:51.994888474 +0700
@@ -0,0 +1,1581 @@
+#!/usr/bin/python
+# Frr Reloader
+# Copyright (C) 2014 Cumulus Networks, Inc.
+#
+# This file is part of Frr.
+#
+# Frr is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the
+# Free Software Foundation; either version 2, or (at your option) any
+# later version.
+#
+# Frr is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Frr; see the file COPYING.  If not, write to the Free
+# Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+#  02111-1307, USA.
+#
+"""
+This program
+- reads a frr configuration text file
+- reads frr's current running configuration via "vtysh -c 'show running'"
+- compares the two configs and determines what commands to execute to
+  synchronize frr's running configuration with the configuation in the
+  text file
+"""
+
+from __future__ import print_function, unicode_literals
+import argparse
+import copy
+import logging
+import os, os.path
+import random
+import re
+import string
+import subprocess
+import sys
+from collections import OrderedDict
+try:
+    from ipaddress import IPv6Address, ip_network
+except ImportError:
+    from ipaddr import IPv6Address, IPNetwork
+from pprint import pformat
+
+try:
+    dict.iteritems
+except AttributeError:
+    # Python 3
+    def iteritems(d):
+        return iter(d.items())
+else:
+    # Python 2
+    def iteritems(d):
+        return d.iteritems()
+
+log = logging.getLogger(__name__)
+
+
+class VtyshException(Exception):
+    pass
+
+class Vtysh(object):
+    def __init__(self, bindir=None, confdir=None, sockdir=None, pathspace=None):
+        self.bindir = bindir
+        self.confdir = confdir
+        self.pathspace = pathspace
+        self.common_args = [os.path.join(bindir or '', 'vtysh')]
+        if confdir:
+            self.common_args.extend(['--config_dir', confdir])
+        if sockdir:
+            self.common_args.extend(['--vty_socket', sockdir])
+        if pathspace:
+            self.common_args.extend(['-N', pathspace])
+
+    def _call(self, args, stdin=None, stdout=None, stderr=None):
+        kwargs = {}
+        if stdin is not None:
+            kwargs['stdin'] = stdin
+        if stdout is not None:
+            kwargs['stdout'] = stdout
+        if stderr is not None:
+            kwargs['stderr'] = stderr
+        return subprocess.Popen(self.common_args + args, **kwargs)
+
+    def _call_cmd(self, command, stdin=None, stdout=None, stderr=None):
+        if isinstance(command, list):
+            args = [item for sub in command for item in ['-c', sub]]
+        else:
+            args = ['-c', command]
+        return self._call(args, stdin, stdout, stderr)
+
+    def __call__(self, command):
+        """
+        Call a CLI command (e.g. "show running-config")
+
+        Output text is automatically redirected, decoded and returned.
+        Multiple commands may be passed as list.
+        """
+        proc = self._call_cmd(command, stdout=subprocess.PIPE)
+        stdout, stderr = proc.communicate()
+        if proc.wait() != 0:
+            raise VtyshException('vtysh returned status %d for command "%s"'
+                    % (proc.returncode, command))
+        return stdout.decode('UTF-8')
+
+    def is_config_available(self):
+        """
+        Return False if no frr daemon is running or some other vtysh session is
+        in 'configuration terminal' mode which will prevent us from making any
+        configuration changes.
+        """
+
+        output = self('configure')
+
+        if 'VTY configuration is locked by other VTY' in output:
+            log.error("vtysh 'configure' returned\n%s\n" % (output))
+            return False
+
+        return True
+
+    def exec_file(self, filename):
+        child = self._call(['-f', filename])
+        if child.wait() != 0:
+            raise VtyshException('vtysh (exec file) exited with status %d'
+                    % (child.returncode))
+
+    def mark_file(self, filename, stdin=None):
+        child = self._call(['-m', '-f', filename],
+                stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
+        try:
+            stdout, stderr = child.communicate()
+        except subprocess.TimeoutExpired:
+            child.kill()
+            stdout, stderr = child.communicate()
+            raise VtyshException('vtysh call timed out!')
+
+        if child.wait() != 0:
+            raise VtyshException('vtysh (mark file) exited with status %d:\n%s'
+                    % (child.returncode, stderr))
+
+        return stdout.decode('UTF-8')
+
+    def mark_show_run(self, daemon = None):
+        cmd = 'show running-config'
+        if daemon:
+            cmd += ' %s' % daemon
+        cmd += ' no-header'
+        show_run = self._call_cmd(cmd, stdout=subprocess.PIPE)
+        mark = self._call(['-m', '-f', '-'], stdin=show_run.stdout, stdout=subprocess.PIPE)
+
+        show_run.wait()
+        stdout, stderr = mark.communicate()
+        mark.wait()
+
+        if show_run.returncode != 0:
+            raise VtyshException('vtysh (show running-config) exited with status %d:'
+                    % (show_run.returncode))
+        if mark.returncode != 0:
+            raise VtyshException('vtysh (mark running-config) exited with status %d'
+                    % (mark.returncode))
+
+        return stdout.decode('UTF-8')
+
+class Context(object):
+
+    """
+    A Context object represents a section of frr configuration such as:
+!
+interface swp3
+ description swp3 -> r8's swp1
+ ipv6 nd suppress-ra
+ link-detect
+!
+
+or a single line context object such as this:
+
+ip forwarding
+
+    """
+
+    def __init__(self, keys, lines):
+        self.keys = keys
+        self.lines = lines
+
+        # Keep a dictionary of the lines, this is to make it easy to tell if a
+        # line exists in this Context
+        self.dlines = OrderedDict()
+
+        for ligne in lines:
+            self.dlines[ligne] = True
+
+    def add_lines(self, lines):
+        """
+        Add lines to specified context
+        """
+
+        self.lines.extend(lines)
+
+        for ligne in lines:
+            self.dlines[ligne] = True
+
+def get_normalized_es_id(line):
+    """
+    The es-id or es-sys-mac need to be converted to lower case
+    """
+    sub_strs = ["evpn mh es-id", "evpn mh es-sys-mac"]
+    for sub_str in sub_strs:
+        obj = re.match(sub_str + " (?P<esi>\S*)", line)
+        if obj:
+            line = "%s %s" % (sub_str, obj.group("esi").lower())
+            break
+    return line
+
+def get_normalized_mac_ip_line(line):
+    if line.startswith("evpn mh es"):
+        return get_normalized_es_id(line)
+
+    if not "ipv6 add" in line:
+        return get_normalized_ipv6_line(line)
+
+    return line
+
+class Config(object):
+
+    """
+    A frr configuration is stored in a Config object. A Config object
+    contains a dictionary of Context objects where the Context keys
+    ('router ospf' for example) are our dictionary key.
+    """
+
+    def __init__(self, vtysh):
+        self.lines = []
+        self.contexts = OrderedDict()
+        self.vtysh = vtysh
+
+    def load_from_file(self, filename):
+        """
+        Read configuration from specified file and slurp it into internal memory
+        The internal representation has been marked appropriately by passing it
+        through vtysh with the -m parameter
+        """
+        log.info('Loading Config object from file %s', filename)
+
+        file_output = self.vtysh.mark_file(filename)
+
+        for line in file_output.split('\n'):
+            line = line.strip()
+
+            # Compress duplicate whitespaces
+            line = ' '.join(line.split())
+
+            if ":" in line:
+                line = get_normalized_mac_ip_line(line)
+
+            self.lines.append(line)
+
+        self.load_contexts()
+
+    def load_from_show_running(self, daemon):
+        """
+        Read running configuration and slurp it into internal memory
+        The internal representation has been marked appropriately by passing it
+        through vtysh with the -m parameter
+        """
+        log.info('Loading Config object from vtysh show running')
+
+        config_text = self.vtysh.mark_show_run(daemon)
+
+        for line in config_text.split('\n'):
+            line = line.strip()
+
+            if (line == 'Building configuration...' or
+                line == 'Current configuration:' or
+                    not line):
+                continue
+
+            self.lines.append(line)
+
+        self.load_contexts()
+
+    def get_lines(self):
+        """
+        Return the lines read in from the configuration
+        """
+
+        return '\n'.join(self.lines)
+
+    def get_contexts(self):
+        """
+        Return the parsed context as strings for display, log etc.
+        """
+
+        for (_, ctx) in sorted(iteritems(self.contexts)):
+            print(str(ctx) + '\n')
+
+    def save_contexts(self, key, lines):
+        """
+        Save the provided key and lines as a context
+        """
+
+        if not key:
+            return
+
+        '''
+            IP addresses specified in "network" statements, "ip prefix-lists"
+            etc. can differ in the host part of the specification the user
+            provides and what the running config displays. For example, user
+            can specify 11.1.1.1/24, and the running config displays this as
+            11.1.1.0/24. Ensure we don't do a needless operation for such
+            lines. IS-IS & OSPFv3 have no "network" support.
+        '''
+        re_key_rt = re.match(r'(ip|ipv6)\s+route\s+([A-Fa-f:.0-9/]+)(.*)$', key[0])
+        if re_key_rt:
+            addr = re_key_rt.group(2)
+            if '/' in addr:
+                try:
+                    if 'ipaddress' not in sys.modules:
+                        newaddr = IPNetwork(addr)
+                        key[0] = '%s route %s/%s%s' % (re_key_rt.group(1),
+                                                       newaddr.network,
+                                                       newaddr.prefixlen,
+                                                       re_key_rt.group(3))
+                    else:
+                        newaddr = ip_network(addr, strict=False)
+                        key[0] = '%s route %s/%s%s' % (re_key_rt.group(1),
+                                                       str(newaddr.network_address),
+                                                       newaddr.prefixlen,
+                                                       re_key_rt.group(3))
+                except ValueError:
+                    pass
+
+        re_key_rt = re.match(
+            r'(ip|ipv6)\s+prefix-list(.*)(permit|deny)\s+([A-Fa-f:.0-9/]+)(.*)$',
+            key[0]
+        )
+        if re_key_rt:
+            addr = re_key_rt.group(4)
+            if '/' in addr:
+                try:
+                    if 'ipaddress' not in sys.modules:
+                        newaddr = '%s/%s' % (IPNetwork(addr).network,
+                                             IPNetwork(addr).prefixlen)
+                    else:
+                        network_addr = ip_network(addr, strict=False)
+                        newaddr = '%s/%s' % (str(network_addr.network_address),
+                                             network_addr.prefixlen)
+                except ValueError:
+                    newaddr = addr
+            else:
+                newaddr = addr
+
+            legestr = re_key_rt.group(5)
+            re_lege = re.search(r'(.*)le\s+(\d+)\s+ge\s+(\d+)(.*)', legestr)
+            if re_lege:
+                legestr = '%sge %s le %s%s' % (re_lege.group(1),
+                                               re_lege.group(3),
+                                               re_lege.group(2),
+                                               re_lege.group(4))
+            re_lege = re.search(r'(.*)ge\s+(\d+)\s+le\s+(\d+)(.*)', legestr)
+
+            if (re_lege and ((re_key_rt.group(1) == "ip" and
+                              re_lege.group(3) == "32") or
+                             (re_key_rt.group(1) == "ipv6" and
+                              re_lege.group(3) == "128"))):
+                legestr = '%sge %s%s' % (re_lege.group(1),
+                                         re_lege.group(2),
+                                         re_lege.group(4))
+
+            key[0] = '%s prefix-list%s%s %s%s' % (re_key_rt.group(1),
+                                                  re_key_rt.group(2),
+                                                  re_key_rt.group(3),
+                                                  newaddr,
+                                                  legestr)
+
+        if lines and key[0].startswith('router bgp'):
+            newlines = []
+            for line in lines:
+                re_net = re.match(r'network\s+([A-Fa-f:.0-9/]+)(.*)$', line)
+                if re_net:
+                    addr = re_net.group(1)
+                    if '/' not in addr and key[0].startswith('router bgp'):
+                        # This is most likely an error because with no
+                        # prefixlen, BGP treats the prefixlen as 8
+                        addr = addr + '/8'
+
+                    try:
+                        if 'ipaddress' not in sys.modules:
+                            newaddr = IPNetwork(addr)
+                            line = 'network %s/%s %s' % (newaddr.network,
+                                                         newaddr.prefixlen,
+                                                         re_net.group(2))
+                        else:
+                            network_addr = ip_network(addr, strict=False)
+                            line = 'network %s/%s %s' % (str(network_addr.network_address),
+                                                         network_addr.prefixlen,
+                                                         re_net.group(2))
+                        newlines.append(line)
+                    except ValueError:
+                        # Really this should be an error. Whats a network
+                        # without an IP Address following it ?
+                        newlines.append(line)
+                else:
+                    newlines.append(line)
+            lines = newlines
+
+        '''
+          More fixups in user specification and what running config shows.
+          "null0" in routes must be replaced by Null0.
+        '''
+        if (key[0].startswith('ip route') or key[0].startswith('ipv6 route') and
+                'null0' in key[0]):
+            key[0] = re.sub(r'\s+null0(\s*$)', ' Null0', key[0])
+
+        if lines:
+            if tuple(key) not in self.contexts:
+                ctx = Context(tuple(key), lines)
+                self.contexts[tuple(key)] = ctx
+            else:
+                ctx = self.contexts[tuple(key)]
+                ctx.add_lines(lines)
+
+        else:
+            if tuple(key) not in self.contexts:
+                ctx = Context(tuple(key), [])
+                self.contexts[tuple(key)] = ctx
+
+    def load_contexts(self):
+        """
+        Parse the configuration and create contexts for each appropriate block
+        """
+
+        current_context_lines = []
+        ctx_keys = []
+
+        '''
+        The end of a context is flagged via the 'end' keyword:
+
+!
+interface swp52
+ ipv6 nd suppress-ra
+ link-detect
+!
+end
+router bgp 10
+ bgp router-id 10.0.0.1
+ bgp log-neighbor-changes
+ no bgp default ipv4-unicast
+ neighbor EBGP peer-group
+ neighbor EBGP advertisement-interval 1
+ neighbor EBGP timers connect 10
+ neighbor 2001:40:1:4::6 remote-as 40
+ neighbor 2001:40:1:8::a remote-as 40
+!
+end
+ address-family ipv6
+ neighbor IBGPv6 activate
+ neighbor 2001:10::2 peer-group IBGPv6
+ neighbor 2001:10::3 peer-group IBGPv6
+ exit-address-family
+!
+end
+ address-family evpn
+  neighbor LEAF activate
+  advertise-all-vni
+  vni 10100
+   rd 65000:10100
+   route-target import 10.1.1.1:10100
+   route-target export 10.1.1.1:10100
+  exit-vni
+ exit-address-family
+!
+end
+router ospf
+ ospf router-id 10.0.0.1
+ log-adjacency-changes detail
+ timers throttle spf 0 50 5000
+!
+end
+        '''
+
+        # The code assumes that its working on the output from the "vtysh -m"
+        # command. That provides the appropriate markers to signify end of
+        # a context. This routine uses that to build the contexts for the
+        # config.
+        #
+        # There are single line contexts such as "log file /media/node/zebra.log"
+        # and multi-line contexts such as "router ospf" and subcontexts
+        # within a context such as "address-family" within "router bgp"
+        # In each of these cases, the first line of the context becomes the
+        # key of the context. So "router bgp 10" is the key for the non-address
+        # family part of bgp, "router bgp 10, address-family ipv6 unicast" is
+        # the key for the subcontext and so on.
+        ctx_keys = []
+        main_ctx_key = []
+        new_ctx = True
+
+        # the keywords that we know are single line contexts. bgp in this case
+        # is not the main router bgp block, but enabling multi-instance
+        oneline_ctx_keywords = ("access-list ",
+                                "agentx",
+                                "allow-external-route-update",
+                                "bgp ",
+                                "debug ",
+                                "domainname ",
+                                "dump ",
+                                "enable ",
+                                "frr ",
+                                "hostname ",
+                                "ip ",
+                                "ipv6 ",
+                                "log ",
+                                "mpls lsp",
+                                "mpls label",
+                                "no ",
+                                "password ",
+                                "ptm-enable",
+                                "router-id ",
+                                "service ",
+                                "table ",
+                                "username ",
+                                "zebra ",
+                                "vrrp autoconfigure",
+                                "evpn mh")
+
+        for line in self.lines:
+
+            if not line:
+                continue
+
+            if line.startswith('!') or line.startswith('#'):
+                continue
+
+            if (len(ctx_keys) == 2
+                and ctx_keys[0].startswith('bfd')
+                and ctx_keys[1].startswith('profile ')
+                and line == 'end'):
+                log.debug('LINE %-50s: popping from sub context, %-50s', line, ctx_keys)
+
+                if main_ctx_key:
+                    self.save_contexts(ctx_keys, current_context_lines)
+                    ctx_keys = copy.deepcopy(main_ctx_key)
+                    current_context_lines = []
+                    continue
+
+            # one line contexts
+            # there is one exception though: ldpd accepts a 'router-id' clause
+            # as part of its 'mpls ldp' config context. If we are processing
+            # ldp configuration and encounter a router-id we should NOT switch
+            # to a new context
+            if new_ctx is True and any(line.startswith(keyword) for keyword in oneline_ctx_keywords) and not (
+                ctx_keys and ctx_keys[0].startswith("mpls ldp") and line.startswith("router-id ")):
+                self.save_contexts(ctx_keys, current_context_lines)
+
+                # Start a new context
+                main_ctx_key = []
+                ctx_keys = [line, ]
+                current_context_lines = []
+
+                log.debug('LINE %-50s: entering new context, %-50s', line, ctx_keys)
+                self.save_contexts(ctx_keys, current_context_lines)
+                new_ctx = True
+
+            elif line == "end":
+                self.save_contexts(ctx_keys, current_context_lines)
+                log.debug('LINE %-50s: exiting old context, %-50s', line, ctx_keys)
+
+                # Start a new context
+                new_ctx = True
+                main_ctx_key = []
+                ctx_keys = []
+                current_context_lines = []
+
+            elif line == "exit" and ctx_keys[0].startswith("rpki"):
+                self.save_contexts(ctx_keys, current_context_lines)
+                log.debug("LINE %-50s: exiting old context, %-50s", line, ctx_keys)
+
+                # Start a new context
+                new_ctx = True
+                main_ctx_key = []
+                ctx_keys = []
+                current_context_lines = []
+
+            elif line == "exit-vrf":
+                self.save_contexts(ctx_keys, current_context_lines)
+                current_context_lines.append(line)
+                log.debug('LINE %-50s: append to current_context_lines, %-50s', line, ctx_keys)
+
+                #Start a new context
+                new_ctx = True
+                main_ctx_key = []
+                ctx_keys = []
+                current_context_lines = []
+
+            elif line in ["exit-address-family", "exit", "exit-vnc"]:
+                # if this exit is for address-family ipv4 unicast, ignore the pop
+                if main_ctx_key:
+                    self.save_contexts(ctx_keys, current_context_lines)
+
+                    # Start a new context
+                    ctx_keys = copy.deepcopy(main_ctx_key)
+                    current_context_lines = []
+                    log.debug('LINE %-50s: popping from subcontext to ctx%-50s', line, ctx_keys)
+
+            elif line in ["exit-vni", "exit-ldp-if"]:
+                if sub_main_ctx_key:
+                    self.save_contexts(ctx_keys, current_context_lines)
+
+                    # Start a new context
+                    ctx_keys = copy.deepcopy(sub_main_ctx_key)
+                    current_context_lines = []
+                    log.debug('LINE %-50s: popping from sub-subcontext to ctx%-50s', line, ctx_keys)
+
+            elif new_ctx is True:
+                if not main_ctx_key:
+                    ctx_keys = [line, ]
+                else:
+                    ctx_keys = copy.deepcopy(main_ctx_key)
+                    main_ctx_key = []
+
+                current_context_lines = []
+                new_ctx = False
+                log.debug('LINE %-50s: entering new context, %-50s', line, ctx_keys)
+            elif (line.startswith("address-family ") or
+                  line.startswith("vnc defaults") or
+                  line.startswith("vnc l2-group") or
+                  line.startswith("vnc nve-group") or
+                  line.startswith("peer") or
+                  line.startswith("key ") or
+                  line.startswith("member pseudowire")):
+                main_ctx_key = []
+
+                # Save old context first
+                self.save_contexts(ctx_keys, current_context_lines)
+                current_context_lines = []
+                main_ctx_key = copy.deepcopy(ctx_keys)
+                log.debug('LINE %-50s: entering sub-context, append to ctx_keys', line)
+
+                if line == "address-family ipv6" and not ctx_keys[0].startswith("mpls ldp"):
+                    ctx_keys.append("address-family ipv6 unicast")
+                elif line == "address-family ipv4" and not ctx_keys[0].startswith("mpls ldp"):
+                    ctx_keys.append("address-family ipv4 unicast")
+                elif line == "address-family evpn":
+                    ctx_keys.append("address-family l2vpn evpn")
+                else:
+                    ctx_keys.append(line)
+
+            elif ((line.startswith("vni ") and
+                   len(ctx_keys) == 2 and
+                   ctx_keys[0].startswith('router bgp') and
+                   ctx_keys[1] == 'address-family l2vpn evpn')):
+
+                # Save old context first
+                self.save_contexts(ctx_keys, current_context_lines)
+                current_context_lines = []
+                sub_main_ctx_key = copy.deepcopy(ctx_keys)
+                log.debug('LINE %-50s: entering sub-sub-context, append to ctx_keys', line)
+                ctx_keys.append(line)
+            
+            elif ((line.startswith("interface ") and
+                   len(ctx_keys) == 2 and
+                   ctx_keys[0].startswith('mpls ldp') and
+                   ctx_keys[1].startswith('address-family'))):
+
+                # Save old context first
+                self.save_contexts(ctx_keys, current_context_lines)
+                current_context_lines = []
+                sub_main_ctx_key = copy.deepcopy(ctx_keys)
+                log.debug('LINE %-50s: entering sub-sub-context, append to ctx_keys', line)
+                ctx_keys.append(line)
+
+            elif (
+                line.startswith('profile ')
+                and len(ctx_keys) == 1
+                and ctx_keys[0].startswith('bfd')
+            ):
+
+                # Save old context first
+                self.save_contexts(ctx_keys, current_context_lines)
+                current_context_lines = []
+                main_ctx_key = copy.deepcopy(ctx_keys)
+                log.debug(
+                    "LINE %-50s: entering BFD profile sub-context, append to ctx_keys",
+                    line
+                )
+                ctx_keys.append(line)
+
+            else:
+                # Continuing in an existing context, add non-commented lines to it
+                current_context_lines.append(line)
+                log.debug('LINE %-50s: append to current_context_lines, %-50s', line, ctx_keys)
+
+        # Save the context of the last one
+        self.save_contexts(ctx_keys, current_context_lines)
+
+
+def lines_to_config(ctx_keys, line, delete):
+    """
+    Return the command as it would appear in frr.conf
+    """
+    cmd = []
+
+    if line:
+        for (i, ctx_key) in enumerate(ctx_keys):
+            cmd.append(' ' * i + ctx_key)
+
+        line = line.lstrip()
+        indent = len(ctx_keys) * ' '
+
+        # There are some commands that are on by default so their "no" form will be
+        # displayed in the config.  "no bgp default ipv4-unicast" is one of these.
+        # If we need to remove this line we do so by adding "bgp default ipv4-unicast",
+        # not by doing a "no no bgp default ipv4-unicast"
+        if delete:
+            if line.startswith('no '):
+                cmd.append('%s%s' % (indent, line[3:]))
+            else:
+                cmd.append('%sno %s' % (indent, line))
+
+        else:
+            cmd.append(indent + line)
+
+    # If line is None then we are typically deleting an entire
+    # context ('no router ospf' for example)
+    else:
+        for i, ctx_key in enumerate(ctx_keys[:-1]):
+            cmd.append('%s%s' % (' ' * i, ctx_key))
+
+        # Only put the 'no' on the last sub-context
+        if delete:
+            if ctx_keys[-1].startswith('no '):
+                cmd.append('%s%s' % (' ' * (len(ctx_keys) - 1), ctx_keys[-1][3:]))
+            else:
+                cmd.append('%sno %s' % (' ' * (len(ctx_keys) - 1), ctx_keys[-1]))
+        else:
+            cmd.append('%s%s' % (' ' * (len(ctx_keys) - 1), ctx_keys[-1]))
+
+    return cmd
+
+
+def get_normalized_ipv6_line(line):
+    """
+    Return a normalized IPv6 line as produced by frr,
+    with all letters in lower case and trailing and leading
+    zeros removed, and only the network portion present if
+    the IPv6 word is a network
+    """
+    norm_line = ""
+    words = line.split(' ')
+    for word in words:
+        if ":" in word:
+            norm_word = None
+            if "/" in word:
+                try:
+                    if 'ipaddress' not in sys.modules:
+                        v6word = IPNetwork(word)
+                        norm_word = '%s/%s' % (v6word.network, v6word.prefixlen)
+                    else:
+                        v6word = ip_network(word, strict=False)
+                        norm_word = '%s/%s' % (str(v6word.network_address), v6word.prefixlen)
+                except ValueError:
+                    pass
+            if not norm_word:
+                try:
+                    norm_word = '%s' % IPv6Address(word)
+                except ValueError:
+                    norm_word = word
+        else:
+            norm_word = word
+        norm_line = norm_line + " " + norm_word
+
+    return norm_line.strip()
+
+
+def line_exist(lines, target_ctx_keys, target_line, exact_match=True):
+    for (ctx_keys, line) in lines:
+        if ctx_keys == target_ctx_keys:
+            if exact_match:
+                if line == target_line:
+                    return True
+            else:
+                if line.startswith(target_line):
+                    return True
+    return False
+
+def check_for_exit_vrf(lines_to_add, lines_to_del):
+
+    # exit-vrf is a bit tricky.  If the new config is missing it but we
+    # have configs under a vrf, we need to add it at the end to do the
+    # right context changes.  If exit-vrf exists in both the running and
+    # new config, we cannot delete it or it will break context changes.
+    add_exit_vrf = False
+    index = 0
+
+    for (ctx_keys, line) in lines_to_add:
+        if add_exit_vrf == True:
+            if ctx_keys[0] != prior_ctx_key:
+                insert_key=(prior_ctx_key),
+                lines_to_add.insert(index, ((insert_key, "exit-vrf")))
+                add_exit_vrf = False
+
+        if ctx_keys[0].startswith('vrf') and line:
+            if line is not "exit-vrf":
+                add_exit_vrf = True
+                prior_ctx_key = (ctx_keys[0])
+            else:
+                add_exit_vrf = False
+        index+=1
+
+    for (ctx_keys, line) in lines_to_del:
+        if line == "exit-vrf":
+            if (line_exist(lines_to_add, ctx_keys, line)):
+                lines_to_del.remove((ctx_keys, line))
+
+    return (lines_to_add, lines_to_del)
+
+def ignore_delete_re_add_lines(lines_to_add, lines_to_del):
+
+    # Quite possibly the most confusing (while accurate) variable names in history
+    lines_to_add_to_del = []
+    lines_to_del_to_del = []
+
+    for (ctx_keys, line) in lines_to_del:
+        deleted = False
+
+        if ctx_keys[0].startswith('router bgp') and line:
+
+            if line.startswith('neighbor '):
+                '''
+                BGP changed how it displays swpX peers that are part of peer-group. Older
+                versions of frr would display these on separate lines:
+                    neighbor swp1 interface
+                    neighbor swp1 peer-group FOO
+
+                but today we display via a single line
+                    neighbor swp1 interface peer-group FOO
+
+                This change confuses frr-reload.py so check to see if we are deleting
+                    neighbor swp1 interface peer-group FOO
+
+                and adding
+                    neighbor swp1 interface
+                    neighbor swp1 peer-group FOO
+
+                If so then chop the del line and the corresponding add lines
+                '''
+
+                re_swpx_int_peergroup = re.search('neighbor (\S+) interface peer-group (\S+)', line)
+                re_swpx_int_v6only_peergroup = re.search('neighbor (\S+) interface v6only peer-group (\S+)', line)
+
+                if re_swpx_int_peergroup or re_swpx_int_v6only_peergroup:
+                    swpx_interface = None
+                    swpx_peergroup = None
+
+                    if re_swpx_int_peergroup:
+                        swpx = re_swpx_int_peergroup.group(1)
+                        peergroup = re_swpx_int_peergroup.group(2)
+                        swpx_interface = "neighbor %s interface" % swpx
+                    elif re_swpx_int_v6only_peergroup:
+                        swpx = re_swpx_int_v6only_peergroup.group(1)
+                        peergroup = re_swpx_int_v6only_peergroup.group(2)
+                        swpx_interface = "neighbor %s interface v6only" % swpx
+
+                    swpx_peergroup = "neighbor %s peer-group %s" % (swpx, peergroup)
+                    found_add_swpx_interface = line_exist(lines_to_add, ctx_keys, swpx_interface)
+                    found_add_swpx_peergroup = line_exist(lines_to_add, ctx_keys, swpx_peergroup)
+                    tmp_ctx_keys = tuple(list(ctx_keys))
+
+                    if not found_add_swpx_peergroup:
+                        tmp_ctx_keys = list(ctx_keys)
+                        tmp_ctx_keys.append('address-family ipv4 unicast')
+                        tmp_ctx_keys = tuple(tmp_ctx_keys)
+                        found_add_swpx_peergroup = line_exist(lines_to_add, tmp_ctx_keys, swpx_peergroup)
+
+                        if not found_add_swpx_peergroup:
+                            tmp_ctx_keys = list(ctx_keys)
+                            tmp_ctx_keys.append('address-family ipv6 unicast')
+                            tmp_ctx_keys = tuple(tmp_ctx_keys)
+                            found_add_swpx_peergroup = line_exist(lines_to_add, tmp_ctx_keys, swpx_peergroup)
+
+                    if found_add_swpx_interface and found_add_swpx_peergroup:
+                        deleted = True
+                        lines_to_del_to_del.append((ctx_keys, line))
+                        lines_to_add_to_del.append((ctx_keys, swpx_interface))
+                        lines_to_add_to_del.append((tmp_ctx_keys, swpx_peergroup))
+
+                '''
+                Changing the bfd timers on neighbors is allowed without doing
+                a delete/add process. Since doing a "no neighbor blah bfd ..."
+                will cause the peer to bounce unnecessarily, just skip the delete
+                and just do the add.
+                '''
+                re_nbr_bfd_timers = re.search(r'neighbor (\S+) bfd (\S+) (\S+) (\S+)', line)
+
+                if re_nbr_bfd_timers:
+                    nbr = re_nbr_bfd_timers.group(1)
+                    bfd_nbr = "neighbor %s" % nbr
+                    bfd_search_string =  bfd_nbr + r' bfd (\S+) (\S+) (\S+)'
+
+                    for (ctx_keys, add_line) in lines_to_add:
+                        if ctx_keys[0].startswith('router bgp'):
+                            re_add_nbr_bfd_timers = re.search(bfd_search_string, add_line)
+
+                            if re_add_nbr_bfd_timers:
+                                found_add_bfd_nbr = line_exist(lines_to_add, ctx_keys, bfd_nbr, False)
+
+                                if found_add_bfd_nbr:
+                                    lines_to_del_to_del.append((ctx_keys, line))
+
+                '''
+                We changed how we display the neighbor interface command. Older
+                versions of frr would display the following:
+                    neighbor swp1 interface
+                    neighbor swp1 remote-as external
+                    neighbor swp1 capability extended-nexthop
+
+                but today we display via a single line
+                    neighbor swp1 interface remote-as external
+
+                and capability extended-nexthop is no longer needed because we
+                automatically enable it when the neighbor is of type interface.
+
+                This change confuses frr-reload.py so check to see if we are deleting
+                    neighbor swp1 interface remote-as (external|internal|ASNUM)
+
+                and adding
+                    neighbor swp1 interface
+                    neighbor swp1 remote-as (external|internal|ASNUM)
+                    neighbor swp1 capability extended-nexthop
+
+                If so then chop the del line and the corresponding add lines
+                '''
+                re_swpx_int_remoteas = re.search('neighbor (\S+) interface remote-as (\S+)', line)
+                re_swpx_int_v6only_remoteas = re.search('neighbor (\S+) interface v6only remote-as (\S+)', line)
+
+                if re_swpx_int_remoteas or re_swpx_int_v6only_remoteas:
+                    swpx_interface = None
+                    swpx_remoteas = None
+
+                    if re_swpx_int_remoteas:
+                        swpx = re_swpx_int_remoteas.group(1)
+                        remoteas = re_swpx_int_remoteas.group(2)
+                        swpx_interface = "neighbor %s interface" % swpx
+                    elif re_swpx_int_v6only_remoteas:
+                        swpx = re_swpx_int_v6only_remoteas.group(1)
+                        remoteas = re_swpx_int_v6only_remoteas.group(2)
+                        swpx_interface = "neighbor %s interface v6only" % swpx
+
+                    swpx_remoteas = "neighbor %s remote-as %s" % (swpx, remoteas)
+                    found_add_swpx_interface = line_exist(lines_to_add, ctx_keys, swpx_interface)
+                    found_add_swpx_remoteas = line_exist(lines_to_add, ctx_keys, swpx_remoteas)
+                    tmp_ctx_keys = tuple(list(ctx_keys))
+
+                    if found_add_swpx_interface and found_add_swpx_remoteas:
+                        deleted = True
+                        lines_to_del_to_del.append((ctx_keys, line))
+                        lines_to_add_to_del.append((ctx_keys, swpx_interface))
+                        lines_to_add_to_del.append((tmp_ctx_keys, swpx_remoteas))
+
+            '''
+            We made the 'bgp bestpath as-path multipath-relax' command
+            automatically assume 'no-as-set' since the lack of this option caused
+            weird routing problems. When the running config is shown in
+            releases with this change, the no-as-set keyword is not shown as it
+            is the default. This causes frr-reload to unnecessarily unapply
+            this option only to apply it back again, causing unnecessary session
+            resets.
+            '''
+            if 'multipath-relax' in line:
+                re_asrelax_new = re.search('^bgp\s+bestpath\s+as-path\s+multipath-relax$', line)
+                old_asrelax_cmd = 'bgp bestpath as-path multipath-relax no-as-set'
+                found_asrelax_old = line_exist(lines_to_add, ctx_keys, old_asrelax_cmd)
+
+                if re_asrelax_new and found_asrelax_old:
+                    deleted = True
+                    lines_to_del_to_del.append((ctx_keys, line))
+                    lines_to_add_to_del.append((ctx_keys, old_asrelax_cmd))
+
+            '''
+            If we are modifying the BGP table-map we need to avoid a del/add and
+            instead modify the table-map in place via an add.  This is needed to
+            avoid installing all routes in the RIB the second the 'no table-map'
+            is issued.
+            '''
+            if line.startswith('table-map'):
+                found_table_map = line_exist(lines_to_add, ctx_keys, 'table-map', False)
+
+                if found_table_map:
+                    lines_to_del_to_del.append((ctx_keys, line))
+
+        '''
+        More old-to-new config handling. ip import-table no longer accepts
+        distance, but we honor the old syntax. But 'show running' shows only
+        the new syntax. This causes an unnecessary 'no import-table' followed
+        by the same old 'ip import-table' which causes perturbations in
+        announced routes leading to traffic blackholes. Fix this issue.
+        '''
+        re_importtbl = re.search('^ip\s+import-table\s+(\d+)$', ctx_keys[0])
+        if re_importtbl:
+            table_num = re_importtbl.group(1)
+            for ctx in lines_to_add:
+                if ctx[0][0].startswith('ip import-table %s distance' % table_num):
+                    lines_to_del_to_del.append((('ip import-table %s' % table_num,), None))
+                    lines_to_add_to_del.append((ctx[0], None))
+
+        '''
+        ip/ipv6 prefix-list can be specified without a seq number. However,
+        the running config always adds 'seq x', where x is a number incremented
+        by 5 for every element, to the prefix list. So, ignore such lines as
+        well. Sample prefix-list lines:
+             ip prefix-list PR-TABLE-2 seq 5 permit 20.8.2.0/24 le 32
+             ip prefix-list PR-TABLE-2 seq 10 permit 20.8.2.0/24 le 32
+             ipv6 prefix-list vrfdev6-12 permit 2000:9:2::/64 gt 64
+        '''
+        re_ip_pfxlst = re.search('^(ip|ipv6)(\s+prefix-list\s+)(\S+\s+)(seq \d+\s+)(permit|deny)(.*)$',
+                                 ctx_keys[0])
+        if re_ip_pfxlst:
+            tmpline = (re_ip_pfxlst.group(1) + re_ip_pfxlst.group(2) +
+                       re_ip_pfxlst.group(3) + re_ip_pfxlst.group(5) +
+                       re_ip_pfxlst.group(6))
+            for ctx in lines_to_add:
+                if ctx[0][0] == tmpline:
+                    lines_to_del_to_del.append((ctx_keys, None))
+                    lines_to_add_to_del.append(((tmpline,), None))
+
+        if (len(ctx_keys) == 3 and
+            ctx_keys[0].startswith('router bgp') and
+            ctx_keys[1] == 'address-family l2vpn evpn' and
+            ctx_keys[2].startswith('vni')):
+
+            re_route_target = re.search('^route-target import (.*)$', line) if line is not None else False
+
+            if re_route_target:
+                rt = re_route_target.group(1).strip()
+                route_target_import_line = line
+                route_target_export_line = "route-target export %s" % rt
+                route_target_both_line = "route-target both %s" % rt
+
+                found_route_target_export_line = line_exist(lines_to_del, ctx_keys, route_target_export_line)
+                found_route_target_both_line = line_exist(lines_to_add, ctx_keys, route_target_both_line)
+
+                '''
+                If the running configs has
+                    route-target import 1:1
+                    route-target export 1:1
+
+                and the config we are reloading against has
+                    route-target both 1:1
+
+                then we can ignore deleting the import/export and ignore adding the 'both'
+                '''
+                if found_route_target_export_line and found_route_target_both_line:
+                    lines_to_del_to_del.append((ctx_keys, route_target_import_line))
+                    lines_to_del_to_del.append((ctx_keys, route_target_export_line))
+                    lines_to_add_to_del.append((ctx_keys, route_target_both_line))
+
+        # Deleting static routes under a vrf can lead to time-outs if each is sent
+        # as separate vtysh -c commands. Change them from being in lines_to_del and
+        # put the "no" form in lines_to_add
+        if ctx_keys[0].startswith('vrf ') and line:
+            if (line.startswith('ip route') or
+                line.startswith('ipv6 route')):
+                add_cmd = ('no ' + line)
+                lines_to_add.append((ctx_keys, add_cmd))
+                lines_to_del_to_del.append((ctx_keys, line))
+
+        if not deleted:
+            found_add_line = line_exist(lines_to_add, ctx_keys, line)
+
+            if found_add_line:
+                lines_to_del_to_del.append((ctx_keys, line))
+                lines_to_add_to_del.append((ctx_keys, line))
+            else:
+                '''
+                We have commands that used to be displayed in the global part
+                of 'router bgp' that are now displayed under 'address-family ipv4 unicast'
+
+                # old way
+                router bgp 64900
+                  neighbor ISL advertisement-interval 0
+
+                vs.
+
+                # new way
+                router bgp 64900
+                  address-family ipv4 unicast
+                    neighbor ISL advertisement-interval 0
+
+                Look to see if we are deleting it in one format just to add it back in the other
+                '''
+                if ctx_keys[0].startswith('router bgp') and len(ctx_keys) > 1 and ctx_keys[1] == 'address-family ipv4 unicast':
+                    tmp_ctx_keys = list(ctx_keys)[:-1]
+                    tmp_ctx_keys = tuple(tmp_ctx_keys)
+
+                    found_add_line = line_exist(lines_to_add, tmp_ctx_keys, line)
+
+                    if found_add_line:
+                        lines_to_del_to_del.append((ctx_keys, line))
+                        lines_to_add_to_del.append((tmp_ctx_keys, line))
+
+    for (ctx_keys, line) in lines_to_del_to_del:
+        lines_to_del.remove((ctx_keys, line))
+
+    for (ctx_keys, line) in lines_to_add_to_del:
+        lines_to_add.remove((ctx_keys, line))
+
+    return (lines_to_add, lines_to_del)
+
+
+def ignore_unconfigurable_lines(lines_to_add, lines_to_del):
+    """
+    There are certain commands that cannot be removed.  Remove
+    those commands from lines_to_del.
+    """
+    lines_to_del_to_del = []
+
+    for (ctx_keys, line) in lines_to_del:
+
+        if (ctx_keys[0].startswith('frr version') or
+            ctx_keys[0].startswith('frr defaults') or
+            ctx_keys[0].startswith('username') or
+            ctx_keys[0].startswith('password') or
+            ctx_keys[0].startswith('line vty') or
+
+            # This is technically "no"able but if we did so frr-reload would
+            # stop working so do not let the user shoot themselves in the foot
+            # by removing this.
+            ctx_keys[0].startswith('service integrated-vtysh-config')):
+
+            log.info('"%s" cannot be removed' % (ctx_keys[-1],))
+            lines_to_del_to_del.append((ctx_keys, line))
+
+    for (ctx_keys, line) in lines_to_del_to_del:
+        lines_to_del.remove((ctx_keys, line))
+
+    return (lines_to_add, lines_to_del)
+
+
+def compare_context_objects(newconf, running):
+    """
+    Create a context diff for the two specified contexts
+    """
+
+    # Compare the two Config objects to find the lines that we need to add/del
+    lines_to_add = []
+    lines_to_del = []
+    delete_bgpd = False
+
+    # Find contexts that are in newconf but not in running
+    # Find contexts that are in running but not in newconf
+    for (running_ctx_keys, running_ctx) in iteritems(running.contexts):
+
+        if running_ctx_keys not in newconf.contexts:
+
+            # We check that the len is 1 here so that we only look at ('router bgp 10')
+            # and not ('router bgp 10', 'address-family ipv4 unicast'). The
+            # latter could cause a false delete_bgpd positive if ipv4 unicast is in
+            # running but not in newconf.
+            if "router bgp" in running_ctx_keys[0] and len(running_ctx_keys) == 1:
+                delete_bgpd = True
+                lines_to_del.append((running_ctx_keys, None))
+
+            # We cannot do 'no interface' or 'no vrf' in FRR, and so deal with it
+            elif running_ctx_keys[0].startswith('interface') or running_ctx_keys[0].startswith('vrf'):
+                for line in running_ctx.lines:
+                    lines_to_del.append((running_ctx_keys, line))
+
+            # If this is an address-family under 'router bgp' and we are already deleting the
+            # entire 'router bgp' context then ignore this sub-context
+            elif "router bgp" in running_ctx_keys[0] and len(running_ctx_keys) > 1 and delete_bgpd:
+                continue
+
+            # Delete an entire vni sub-context under "address-family l2vpn evpn"
+            elif ("router bgp" in running_ctx_keys[0] and
+                  len(running_ctx_keys) > 2 and
+                  running_ctx_keys[1].startswith('address-family l2vpn evpn') and
+                  running_ctx_keys[2].startswith('vni ')):
+                lines_to_del.append((running_ctx_keys, None))
+
+            elif ("router bgp" in running_ctx_keys[0] and
+                  len(running_ctx_keys) > 1 and
+                  running_ctx_keys[1].startswith('address-family')):
+                # There's no 'no address-family' support and so we have to
+                # delete each line individually again
+                for line in running_ctx.lines:
+                    lines_to_del.append((running_ctx_keys, line))
+
+            # Some commands can happen at higher counts that make
+            # doing vtysh -c inefficient (and can time out.)  For
+            # these commands, instead of adding them to lines_to_del,
+            # add the "no " version to lines_to_add.
+            elif (running_ctx_keys[0].startswith('ip route') or
+                  running_ctx_keys[0].startswith('ipv6 route') or
+                  running_ctx_keys[0].startswith('access-list') or
+                  running_ctx_keys[0].startswith('ipv6 access-list') or
+                  running_ctx_keys[0].startswith('ip prefix-list') or
+                  running_ctx_keys[0].startswith('ipv6 prefix-list')):
+                add_cmd = ('no ' + running_ctx_keys[0],)
+                lines_to_add.append((add_cmd, None))
+
+            # if this an interface sub-subcontext in an address-family block in ldpd and
+            # we are already deleting the whole context, then ignore this
+            elif (len(running_ctx_keys) > 2 and running_ctx_keys[0].startswith('mpls ldp') and
+                  running_ctx_keys[1].startswith('address-family') and
+                  (running_ctx_keys[:2], None) in lines_to_del):
+                continue
+
+            # same thing for a pseudowire sub-context inside an l2vpn context
+            elif (len(running_ctx_keys) > 1 and running_ctx_keys[0].startswith('l2vpn') and
+                  running_ctx_keys[1].startswith('member pseudowire') and
+                  (running_ctx_keys[:1], None) in lines_to_del):
+                continue
+
+            # Non-global context
+            elif running_ctx_keys and not any("address-family" in key for key in running_ctx_keys):
+                lines_to_del.append((running_ctx_keys, None))
+
+            elif running_ctx_keys and not any("vni" in key for key in running_ctx_keys):
+                lines_to_del.append((running_ctx_keys, None))
+
+            # Global context
+            else:
+                for line in running_ctx.lines:
+                    lines_to_del.append((running_ctx_keys, line))
+
+    # Find the lines within each context to add
+    # Find the lines within each context to del
+    for (newconf_ctx_keys, newconf_ctx) in iteritems(newconf.contexts):
+
+        if newconf_ctx_keys in running.contexts:
+            running_ctx = running.contexts[newconf_ctx_keys]
+
+            for line in newconf_ctx.lines:
+                if line not in running_ctx.dlines:
+                    lines_to_add.append((newconf_ctx_keys, line))
+
+            for line in running_ctx.lines:
+                if line not in newconf_ctx.dlines:
+                    lines_to_del.append((newconf_ctx_keys, line))
+
+    for (newconf_ctx_keys, newconf_ctx) in iteritems(newconf.contexts):
+
+        if newconf_ctx_keys not in running.contexts:
+            lines_to_add.append((newconf_ctx_keys, None))
+
+            for line in newconf_ctx.lines:
+                lines_to_add.append((newconf_ctx_keys, line))
+
+    (lines_to_add, lines_to_del) = check_for_exit_vrf(lines_to_add, lines_to_del)
+    (lines_to_add, lines_to_del) = ignore_delete_re_add_lines(lines_to_add, lines_to_del)
+    (lines_to_add, lines_to_del) = ignore_unconfigurable_lines(lines_to_add, lines_to_del)
+
+    return (lines_to_add, lines_to_del)
+
+
+if __name__ == '__main__':
+    # Command line options
+    parser = argparse.ArgumentParser(description='Dynamically apply diff in frr configs')
+    parser.add_argument('--input', help='Read running config from file instead of "show running"')
+    group = parser.add_mutually_exclusive_group(required=True)
+    group.add_argument('--reload', action='store_true', help='Apply the deltas', default=False)
+    group.add_argument('--test', action='store_true', help='Show the deltas', default=False)
+    level_group = parser.add_mutually_exclusive_group()
+    level_group.add_argument('--debug', action='store_true',
+                             help='Enable debugs (synonym for --log-level=debug)', default=False)
+    level_group.add_argument('--log-level', help='Log level', default="info",
+                             choices=("critical", "error", "warning", "info", "debug"))
+    parser.add_argument('--stdout', action='store_true', help='Log to STDOUT', default=False)
+    parser.add_argument('--pathspace', '-N', metavar='NAME', help='Reload specified path/namespace', default=None)
+    parser.add_argument('filename', help='Location of new frr config file')
+    parser.add_argument('--overwrite', action='store_true', help='Overwrite frr.conf with running config output', default=False)
+    parser.add_argument('--bindir', help='path to the vtysh executable', default='/usr/bin')
+    parser.add_argument('--confdir', help='path to the daemon config files', default='/etc/frr')
+    parser.add_argument('--rundir', help='path for the temp config file', default='/var/run/frr')
+    parser.add_argument('--vty_socket', help='socket to be used by vtysh to connect to the daemons', default=None)
+    parser.add_argument('--daemon', help='daemon for which want to replace the config', default='')
+
+    args = parser.parse_args()
+
+    # Logging
+    # For --test log to stdout
+    # For --reload log to /var/log/frr/frr-reload.log
+    if args.test or args.stdout:
+        logging.basicConfig(format='%(asctime)s %(levelname)5s: %(message)s')
+
+        # Color the errors and warnings in red
+        logging.addLevelName(logging.ERROR, "\033[91m  %s\033[0m" % logging.getLevelName(logging.ERROR))
+        logging.addLevelName(logging.WARNING, "\033[91m%s\033[0m" % logging.getLevelName(logging.WARNING))
+
+    elif args.reload:
+        if not os.path.isdir('/var/log/frr/'):
+            os.makedirs('/var/log/frr/')
+
+        logging.basicConfig(filename='/var/log/frr/frr-reload.log',
+                            format='%(asctime)s %(levelname)5s: %(message)s')
+
+    # argparse should prevent this from happening but just to be safe...
+    else:
+        raise Exception('Must specify --reload or --test')
+    log = logging.getLogger(__name__)
+
+    if args.debug:
+        log.setLevel(logging.DEBUG)
+    else:
+        log.setLevel(args.log_level.upper())
+
+    if args.reload and not args.stdout:
+        # Additionally send errors and above to STDOUT, with no metadata,
+        # when we are logging to a file. This specifically does not follow
+        # args.log_level, and is analagous to behaviour in earlier versions
+        # which additionally logged most errors using print().
+
+        stdout_hdlr = logging.StreamHandler(sys.stdout)
+        stdout_hdlr.setLevel(logging.ERROR)
+        stdout_hdlr.setFormatter(logging.Formatter())
+        log.addHandler(stdout_hdlr)
+
+    # Verify the new config file is valid
+    if not os.path.isfile(args.filename):
+        log.error("Filename %s does not exist" % args.filename)
+        sys.exit(1)
+
+    if not os.path.getsize(args.filename):
+        log.error("Filename %s is an empty file" % args.filename)
+        sys.exit(1)
+
+    # Verify that confdir is correct
+    if not os.path.isdir(args.confdir):
+        log.error("Confdir %s is not a valid path" % args.confdir)
+        sys.exit(1)
+
+    # Verify that bindir is correct
+    if not os.path.isdir(args.bindir) or not os.path.isfile(args.bindir + '/vtysh'):
+        log.error("Bindir %s is not a valid path to vtysh" % args.bindir)
+        sys.exit(1)
+
+    # verify that the vty_socket, if specified, is valid
+    if args.vty_socket and not os.path.isdir(args.vty_socket):
+        log.error('vty_socket %s is not a valid path' % args.vty_socket)
+        sys.exit(1)
+
+    # verify that the daemon, if specified, is valid
+    if args.daemon and args.daemon not in ['zebra', 'bgpd', 'fabricd', 'isisd', 'ospf6d', 'ospfd', 'pbrd', 'pimd', 'ripd', 'ripngd', 'sharpd', 'staticd', 'vrrpd', 'ldpd']:
+        log.error("Daemon %s is not a valid option for 'show running-config'" % args.daemon)
+        sys.exit(1)
+
+    vtysh = Vtysh(args.bindir, args.confdir, args.vty_socket, args.pathspace)
+
+    # Verify that 'service integrated-vtysh-config' is configured
+    if args.pathspace:
+        vtysh_filename = args.confdir + '/' + args.pathspace + '/vtysh.conf'
+    else:
+        vtysh_filename = args.confdir + '/vtysh.conf'
+    service_integrated_vtysh_config = True
+
+    if os.path.isfile(vtysh_filename):
+        with open(vtysh_filename, 'r') as fh:
+            for line in fh.readlines():
+                line = line.strip()
+
+                if line == 'no service integrated-vtysh-config':
+                    service_integrated_vtysh_config = False
+                    break
+
+    if not service_integrated_vtysh_config and not args.daemon:
+        log.error("'service integrated-vtysh-config' is not configured, this is required for 'service frr reload'")
+        sys.exit(1)
+
+    log.info('Called via "%s"', str(args))
+
+    # Create a Config object from the config generated by newconf
+    newconf = Config(vtysh)
+    try:
+        newconf.load_from_file(args.filename)
+        reload_ok = True
+    except VtyshException as ve:
+        log.error("vtysh failed to process new configuration: {}".format(ve))
+        reload_ok = False
+
+    if args.test:
+
+        # Create a Config object from the running config
+        running = Config(vtysh)
+
+        if args.input:
+            running.load_from_file(args.input)
+        else:
+            running.load_from_show_running(args.daemon)
+
+        (lines_to_add, lines_to_del) = compare_context_objects(newconf, running)
+        lines_to_configure = []
+
+        if lines_to_del:
+            print("\nLines To Delete")
+            print("===============")
+
+            for (ctx_keys, line) in lines_to_del:
+
+                if line == '!':
+                    continue
+
+                cmd = '\n'.join(lines_to_config(ctx_keys, line, True))
+                lines_to_configure.append(cmd)
+                print(cmd)
+
+        if lines_to_add:
+            print("\nLines To Add")
+            print("============")
+
+            for (ctx_keys, line) in lines_to_add:
+
+                if line == '!':
+                    continue
+
+                cmd = '\n'.join(lines_to_config(ctx_keys, line, False))
+                lines_to_configure.append(cmd)
+                print(cmd)
+
+    elif args.reload:
+
+        # We will not be able to do anything, go ahead and exit(1)
+        if not vtysh.is_config_available():
+            sys.exit(1)
+
+        log.debug('New Frr Config\n%s', newconf.get_lines())
+
+        # This looks a little odd but we have to do this twice...here is why
+        # If the user had this running bgp config:
+        #
+        # router bgp 10
+        #  neighbor 1.1.1.1 remote-as 50
+        #  neighbor 1.1.1.1 route-map FOO out
+        #
+        # and this config in the newconf config file
+        #
+        # router bgp 10
+        #  neighbor 1.1.1.1 remote-as 999
+        #  neighbor 1.1.1.1 route-map FOO out
+        #
+        #
+        # Then the script will do
+        # - no neighbor 1.1.1.1 remote-as 50
+        # - neighbor 1.1.1.1 remote-as 999
+        #
+        # The problem is the "no neighbor 1.1.1.1 remote-as 50" will also remove
+        # the "neighbor 1.1.1.1 route-map FOO out" line...so we compare the
+        # configs again to put this line back.
+
+        # There are many keywords in FRR that can only appear one time under
+        # a context, take "bgp router-id" for example. If the config that we are
+        # reloading against has the following:
+        #
+        # router bgp 10
+        #   bgp router-id 1.1.1.1
+        #   bgp router-id 2.2.2.2
+        #
+        # The final config needs to contain "bgp router-id 2.2.2.2". On the
+        # first pass we will add "bgp router-id 2.2.2.2" but then on the second
+        # pass we will see that "bgp router-id 1.1.1.1" is missing and add that
+        # back which cancels out the "bgp router-id 2.2.2.2". The fix is for the
+        # second pass to include all of the "adds" from the first pass.
+        lines_to_add_first_pass = []
+
+        for x in range(2):
+            running = Config(vtysh)
+            running.load_from_show_running(args.daemon)
+            log.debug('Running Frr Config (Pass #%d)\n%s', x, running.get_lines())
+
+            (lines_to_add, lines_to_del) = compare_context_objects(newconf, running)
+
+            if x == 0:
+                lines_to_add_first_pass = lines_to_add
+            else:
+                lines_to_add.extend(lines_to_add_first_pass)
+
+            # Only do deletes on the first pass. The reason being if we
+            # configure a bgp neighbor via "neighbor swp1 interface" FRR
+            # will automatically add:
+            #
+            # interface swp1
+            #  ipv6 nd ra-interval 10
+            #  no ipv6 nd suppress-ra
+            # !
+            #
+            # but those lines aren't in the config we are reloading against so
+            # on the 2nd pass they will show up in lines_to_del.  This could
+            # apply to other scenarios as well where configuring FOO adds BAR
+            # to the config.
+            if lines_to_del and x == 0:
+                for (ctx_keys, line) in lines_to_del:
+
+                    if line == '!':
+                        continue
+
+                    # 'no' commands are tricky, we can't just put them in a file and
+                    # vtysh -f that file. See the next comment for an explanation
+                    # of their quirks
+                    cmd = lines_to_config(ctx_keys, line, True)
+                    original_cmd = cmd
+
+                    # Some commands in frr are picky about taking a "no" of the entire line.
+                    # OSPF is bad about this, you can't "no" the entire line, you have to "no"
+                    # only the beginning. If we hit one of these command an exception will be
+                    # thrown.  Catch it and remove the last '-c', 'FOO' from cmd and try again.
+                    #
+                    # Example:
+                    # frr(config-if)# ip ospf authentication message-digest 1.1.1.1
+                    # frr(config-if)# no ip ospf authentication message-digest 1.1.1.1
+                    #  % Unknown command.
+                    # frr(config-if)# no ip ospf authentication message-digest
+                    #  % Unknown command.
+                    # frr(config-if)# no ip ospf authentication
+                    # frr(config-if)#
+
+                    while True:
+                        try:
+                            vtysh(['configure'] + cmd)
+
+                        except VtyshException:
+
+                            # - Pull the last entry from cmd (this would be
+                            #   'no ip ospf authentication message-digest 1.1.1.1' in
+                            #   our example above
+                            # - Split that last entry by whitespace and drop the last word
+                            log.info('Failed to execute %s', ' '.join(cmd))
+                            last_arg = cmd[-1].split(' ')
+
+                            if len(last_arg) <= 2:
+                                log.error('"%s" we failed to remove this command', ' -- '.join(original_cmd))
+                                break
+
+                            new_last_arg = last_arg[0:-1]
+                            cmd[-1] = ' '.join(new_last_arg)
+                        else:
+                            log.info('Executed "%s"', ' '.join(cmd))
+                            break
+
+            if lines_to_add:
+                lines_to_configure = []
+
+                for (ctx_keys, line) in lines_to_add:
+
+                    if line == '!':
+                        continue
+
+                    # Don't run "no" commands twice since they can error
+                    # out the second time due to first deletion
+                    if x == 1 and ctx_keys[0].startswith('no '):
+                        continue
+
+                    cmd = '\n'.join(lines_to_config(ctx_keys, line, False)) + '\n'
+                    lines_to_configure.append(cmd)
+
+                if lines_to_configure:
+                    random_string = ''.join(random.SystemRandom().choice(
+                                            string.ascii_uppercase +
+                                            string.digits) for _ in range(6))
+
+                    filename = args.rundir + "/reload-%s.txt" % random_string
+                    log.info("%s content\n%s" % (filename, pformat(lines_to_configure)))
+
+                    with open(filename, 'w') as fh:
+                        for line in lines_to_configure:
+                            fh.write(line + '\n')
+
+                    try:
+                        vtysh.exec_file(filename)
+                    except VtyshException as e:
+                        log.warning("frr-reload.py failed due to\n%s" % e.args)
+                        reload_ok = False
+                    os.unlink(filename)
+
+        # Make these changes persistent
+        target = str(args.confdir + '/frr.conf')
+        if args.overwrite or (not args.daemon and args.filename != target):
+            vtysh('write')
+
+    if not reload_ok:
+        sys.exit(1)
diff -urpN frr-frr-8.1/usr/sbin/frrcommon.sh frr/usr/sbin/frrcommon.sh
--- frr-frr-8.1/usr/sbin/frrcommon.sh	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/sbin/frrcommon.sh	2021-08-31 15:25:51.994888474 +0700
@@ -0,0 +1,357 @@
+#!/bin/bash
+#
+# This is a "library" of sorts for use by the other FRR shell scripts.  It
+# has most of the daemon start/stop logic, but expects the following shell
+# functions/commands to be provided by the "calling" script:
+#
+#   log_success_msg
+#   log_warning_msg
+#   log_failure_msg
+#
+# (coincidentally, these are LSB standard functions.)
+#
+# Sourcing this file in a shell script will load FRR config variables but
+# not perform any action.  Note there is an "exit 1" if the main config
+# file does not exist.
+#
+# This script should be installed in  /usr/sbin/frrcommon.sh
+
+# FRR_PATHSPACE is passed in from watchfrr
+suffix="${FRR_PATHSPACE:+/${FRR_PATHSPACE}}"
+nsopt="${FRR_PATHSPACE:+-N ${FRR_PATHSPACE}}"
+
+PATH=/bin:/usr/bin:/sbin:/usr/sbin
+D_PATH="/usr/sbin" # /usr/lib/frr
+C_PATH="/tmp${suffix}" # /etc/frr
+V_PATH="/var/run${suffix}" # /var/run/frr
+VTYSH="/usr/bin/vtysh" # /usr/bin/vtysh
+FRR_USER="root" # frr
+FRR_GROUP="root" # frr
+FRR_VTY_GROUP="" # frrvty
+FRR_CONFIG_MODE="0600" # 0600
+FRR_DEFAULT_PROFILE="traditional" # traditional / datacenter
+
+# ORDER MATTERS FOR $DAEMONS!
+# - keep zebra first
+# - watchfrr does NOT belong in this list
+
+DAEMONS="zebra bgpd ripd ripngd ospfd ospf6d isisd babeld pimd ldpd nhrpd eigrpd sharpd pbrd staticd bfdd fabricd vrrpd"
+RELOAD_SCRIPT="$D_PATH/frr-reload.py"
+
+#
+# general helpers
+#
+
+debug() {
+	[ -n "$watchfrr_debug" ] || return 0
+
+	printf '%s %s(%s):' "`date +%Y-%m-%dT%H:%M:%S.%N`" "$0" $$ >&2
+	# this is to show how arguments are split regarding whitespace & co.
+	# (e.g. for use with `debug "message" "$@"`)
+	while [ $# -gt 0 ]; do
+		printf ' "%s"' "$1" >&2
+		shift
+	done
+	printf '\n' >&2
+}
+
+chownfrr() {
+	[ -n "$FRR_USER" ] && chown "$FRR_USER" "$1"
+	[ -n "$FRR_GROUP" ] && chgrp "$FRR_GROUP" "$1"
+	[ -n "$FRR_CONFIG_MODE" ] && chmod "$FRR_CONFIG_MODE" "$1"
+}
+
+vtysh_b () {
+	[ "$1" = "watchfrr" ] && return 0
+	[ -r "$C_PATH/frr.conf" ] || return 0
+	if [ -n "$1" ]; then
+		"$VTYSH" `echo $nsopt` -b -d "$1"
+	else
+		"$VTYSH" `echo $nsopt` -b
+	fi
+}
+
+daemon_inst() {
+	# note this sets global variables ($dmninst, $daemon, $inst)
+	dmninst="$1"
+	daemon="${dmninst%-*}"
+	inst=""
+	[ "$daemon" != "$dmninst" ] && inst="${dmninst#*-}"
+}
+
+daemon_list() {
+	# note $1 and $2 specify names for global variables to be set
+	local enabled disabled evar dvar
+	enabled=""
+	disabled=""
+	evar="$1"
+	dvar="$2"
+
+	for daemon in $DAEMONS; do
+		eval cfg=\$$daemon
+		eval inst=\$${daemon}_instances
+		[ "$daemon" = zebra -o "$daemon" = staticd ] && cfg=yes
+		if [ -n "$cfg" -a "$cfg" != "no" -a "$cfg" != "0" ]; then
+			if ! daemon_prep "$daemon" "$inst"; then
+				continue
+			fi
+			debug "$daemon enabled"
+
+			if [ -n "$inst" ]; then
+				debug "$daemon multi-instance $inst"
+				oldifs="${IFS}"
+				IFS="${IFS},"
+				for i in $inst; do
+					enabled="$enabled $daemon-$i"
+				done
+				IFS="${oldifs}"
+			else
+			    enabled="$enabled $daemon"
+			fi
+		else
+			debug "$daemon disabled"
+			disabled="$disabled $daemon"
+		fi
+	done
+
+	enabled="${enabled# }"
+	disabled="${disabled# }"
+	[ -z "$evar" ] && echo "$enabled"
+	[ -n "$evar" ] && eval $evar="\"$enabled\""
+	[ -n "$dvar" ] && eval $dvar="\"$disabled\""
+}
+
+#
+# individual daemon management
+#
+
+daemon_prep() {
+	local daemon inst cfg
+	daemon="$1"
+	inst="$2"
+	[ "$daemon" = "watchfrr" ] && return 0
+	[ -x "$D_PATH/$daemon" ] || {
+		log_failure_msg "cannot start $daemon${inst:+ (instance $inst)}: daemon binary not installed"
+		return 1
+	}
+	[ -r "$C_PATH/frr.conf" ] && return 0
+
+	cfg="$C_PATH/$daemon${inst:+-$inst}.conf"
+	if [ ! -r "$cfg" ]; then
+		touch "$cfg"
+		chownfrr "$cfg"
+	fi
+	return 0
+}
+
+daemon_start() {
+	local dmninst daemon inst args instopt wrap bin
+	daemon_inst "$1"
+
+	ulimit -n $MAX_FDS > /dev/null 2> /dev/null
+	daemon_prep "$daemon" "$inst" || return 1
+	if test ! -d "$V_PATH"; then
+		mkdir -p "$V_PATH"
+		chown frr "$V_PATH"
+	fi
+
+	eval wrap="\$${daemon}_wrap"
+	bin="$D_PATH/$daemon"
+	instopt="${inst:+-n $inst}"
+	eval args="\$${daemon}_options"
+
+	if eval "$all_wrap $wrap $bin $nsopt -d $frr_global_options $instopt $args"; then
+		log_success_msg "Started $dmninst"
+		vtysh_b "$daemon"
+	else
+		log_failure_msg "Failed to start $dmninst!"
+	fi
+}
+
+daemon_stop() {
+	local dmninst daemon inst pidfile vtyfile pid cnt fail
+	daemon_inst "$1"
+
+	pidfile="$V_PATH/$daemon${inst:+-$inst}.pid"
+	vtyfile="$V_PATH/$daemon${inst:+-$inst}.vty"
+
+	[ -r "$pidfile" ] || fail="pid file not found"
+	[ -z "$fail" ] && pid="`cat \"$pidfile\"`"
+	[ -z "$fail" -a -z "$pid" ] && fail="pid file is empty"
+	[ -n "$fail" ] || kill -0 "$pid" 2>/dev/null || fail="pid $pid not running"
+
+	if [ -n "$fail" ]; then
+		log_failure_msg "Cannot stop $dmninst: $fail"
+		return 1
+	fi
+
+	debug "kill -2 $pid"
+	kill -2 "$pid"
+	cnt=1200
+	while kill -0 "$pid" 2>/dev/null; do
+		sleep .1
+		[ $(( cnt -= 1 )) -gt 0 ] || break
+	done
+	if kill -0 "$pid" 2>/dev/null; then
+		log_failure_msg "Failed to stop $dmninst, pid $pid still running"
+		still_running=1
+		return 1
+	else
+		log_success_msg "Stopped $dmninst"
+		rm -f "$pidfile"
+		return 0
+	fi
+}
+
+daemon_status() {
+	local dmninst daemon inst pidfile pid fail
+	daemon_inst "$1"
+
+	pidfile="$V_PATH/$daemon${inst:+-$inst}.pid"
+
+	[ -r "$pidfile" ] || return 3
+	pid="`cat \"$pidfile\"`"
+	[ -z "$pid" ] && return 1
+	kill -0 "$pid" 2>/dev/null || return 1
+	return 0
+}
+
+print_status() {
+	daemon_status "$1"
+	rv=$?
+	if [ "$rv" -eq 0 ]; then
+		log_success_msg "Status of $1: running"
+	else
+		log_failure_msg "Status of $1: FAILED"
+	fi
+	return $rv
+}
+
+#
+# all-daemon commands
+#
+
+all_start() {
+	daemon_list daemons
+	for dmninst in $daemons; do
+		daemon_start "$dmninst"
+	done
+}
+
+all_stop() {
+	local pids reversed
+
+	daemon_list daemons disabled
+	[ "$1" = "--reallyall" ] && daemons="$daemons $disabled"
+
+	reversed=""
+	for dmninst in $daemons; do
+		reversed="$dmninst $reversed"
+	done
+
+	for dmninst in $reversed; do
+		daemon_stop "$dmninst" &
+		pids="$pids $!"
+	done
+	for pid in $pids; do
+		wait $pid
+	done
+}
+
+all_status() {
+	local fail
+
+	daemon_list daemons
+	fail=0
+	for dmninst in $daemons; do
+		print_status "$dmninst" || fail=1
+	done
+	return $fail
+}
+
+#
+# config sourcing
+#
+
+load_old_config() {
+	oldcfg="$1"
+	[ -r "$oldcfg" ] || return 0
+	[ -s "$oldcfg" ] || return 0
+	grep -v '^[[:blank:]]*\(#\|$\)' "$oldcfg" > /dev/null || return 0
+
+	log_warning_msg "Reading deprecated $oldcfg.  Please move its settings to $C_PATH/daemons and remove it."
+
+	# save off settings from daemons for the OR below
+	for dmn in $DAEMONS; do eval "_new_$dmn=\${$dmn:-no}"; done
+
+	. "$oldcfg"
+
+	# OR together the daemon enabling options between config files
+	for dmn in $DAEMONS; do eval "test \$_new_$dmn != no && $dmn=\$_new_$dmn; unset _new_$dmn"; done
+}
+
+[ -r "$C_PATH/daemons" ] || {
+	log_failure_msg "cannot run $@: $C_PATH/daemons does not exist"
+	exit 1
+}
+. "$C_PATH/daemons"
+
+if [ -z "$FRR_PATHSPACE" ]; then
+	load_old_config "$C_PATH/daemons.conf"
+	load_old_config "/etc/default/frr"
+	load_old_config "/etc/sysconfig/frr"
+fi
+
+if { declare -p watchfrr_options 2>/dev/null || true; } | grep -q '^declare \-a'; then
+	log_warning_msg "watchfrr_options contains a bash array value." \
+		"The configured value is intentionally ignored since it is likely wrong." \
+		"Please remove or fix the setting."
+	unset watchfrr_options
+fi
+
+if test -z "$frr_profile"; then
+	# try to autodetect config profile
+	if test -d /etc/cumulus; then
+		frr_profile=datacenter
+	# elif test ...; then
+	# -- add your distro/system here
+	elif test -n "$FRR_DEFAULT_PROFILE"; then
+		frr_profile="$FRR_DEFAULT_PROFILE"
+	fi
+fi
+test -n "$frr_profile" && frr_global_options="$frr_global_options -F $frr_profile"
+
+#
+# other defaults and dispatch
+#
+
+frrcommon_main() {
+	local cmd
+
+	debug "frrcommon_main" "$@"
+
+	cmd="$1"
+	shift
+
+	if [ "$1" = "all" -o -z "$1" ]; then
+		case "$cmd" in
+		start)	all_start;;
+		stop)	all_stop;;
+		restart)
+			all_stop
+			all_start
+			;;
+		*)	$cmd "$@";;
+		esac
+	else
+		case "$cmd" in
+		start)	daemon_start "$@";;
+		stop)	daemon_stop "$@";;
+		restart)
+			daemon_stop "$@"
+			daemon_start "$@"
+			;;
+		*)	$cmd "$@";;
+		esac
+	fi
+}
diff -urpN frr-frr-8.1/usr/sbin/frrinit.sh frr/usr/sbin/frrinit.sh
--- frr-frr-8.1/usr/sbin/frrinit.sh	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/sbin/frrinit.sh	2021-08-31 15:25:51.994888474 +0700
@@ -0,0 +1,118 @@
+#!/bin/bash
+#
+### BEGIN INIT INFO
+# Provides: frr
+# Required-Start: $local_fs $network $remote_fs $syslog
+# Required-Stop: $local_fs $network $remote_fs $syslog
+# Default-Start:  2 3 4 5
+# Default-Stop: 0 1 6
+# Short-Description: start and stop the FRR routing suite
+# Description: FRR is a routing suite for IP routing protocols like
+#              BGP, OSPF, RIP and others. This script contols the main
+#              "watchfrr" daemon.
+### END INIT INFO
+#
+# This is the main init script for FRR.  It mostly wraps frrcommon.sh which
+# provides the actual functions to start/stop/restart things.
+#
+
+if [ -r "/lib/lsb/init-functions" ]; then
+	. /lib/lsb/init-functions
+else
+	log_success_msg() {
+		echo "$@"
+	}
+	log_warning_msg() {
+		echo "$@" >&2
+	}
+	log_failure_msg() {
+		echo "$@" >&2
+	}
+fi
+
+# "/usr/lib/frr/frrinit.sh start somenamespace"
+FRR_PATHSPACE="$2"
+
+self="`dirname $0`"
+if [ -r "$self/frrcommon.sh" ]; then
+	. "$self/frrcommon.sh"
+else
+	. "/usr/sbin/frrcommon.sh"
+fi
+
+case "$1" in
+start)
+	daemon_list daemons
+	watchfrr_options="$watchfrr_options $daemons"
+	daemon_start watchfrr
+	;;
+stop)
+	daemon_stop watchfrr
+	all_stop --reallyall
+	exit ${still_running:-0}
+	;;
+
+restart|force-reload)
+	daemon_stop watchfrr
+	all_stop --reallyall
+
+	daemon_list daemons
+	watchfrr_options="$watchfrr_options $daemons"
+	daemon_start watchfrr
+	;;
+
+status)
+	fail=0
+	print_status watchfrr || fail=1
+	all_status || fail=1
+	exit $fail
+	;;
+
+reload)
+	if [ ! -x "$RELOAD_SCRIPT" ]; then
+		log_failure_msg "The frr-pythontools package is required for reload functionality."
+		exit 1
+	fi
+
+	# systemd doesn't set WATCHDOG_USEC for reload commands.
+	watchfrr_pidfile="$V_PATH/watchfrr.pid"
+	watchfrr_pid="`cat \"$watchfrr_pidfile\"`"
+	if [ -d "/proc/$watchfrr_pid" ]; then
+		wdt="`tr '\0' '\n' < /proc/$watchfrr_pid/environ | grep '^WATCHDOG_USEC='`"
+		wdt="${wdt#WATCHDOG_USEC=}"
+		[ -n "$wdt" ] && : ${WATCHDOG_USEC:=$wdt}
+		[ -n "$WATCHDOG_USEC" ] && export WATCHDOG_USEC
+	fi
+
+	# restart watchfrr to pick up added daemons.
+	# NB: This will NOT cause the other daemons to be restarted.
+	daemon_list daemons
+	watchfrr_options="$watchfrr_options $daemons"
+	daemon_stop watchfrr && \
+		daemon_start watchfrr
+
+	# make systemd not kill watchfrr after ExecReload completes
+	# 3 goats were sacrificed to restore sanity after coding this
+	watchfrr_pid="`cat \"$watchfrr_pidfile\"`"
+	if [ -f "/proc/$watchfrr_pid/cgroup" -a -d "/sys/fs/cgroup/systemd" ]; then
+		cg="`egrep '^[0-9]+:name=systemd:' \"/proc/$watchfrr_pid/cgroup\"`"
+		cg="${cg#*:*:}"
+
+		cgmain="$cg"
+		cgmain="${cgmain%/.control}"
+		cgmain="${cgmain%/control}"
+
+		[ -n "$cg" -a "$cg" != "$cgmain" ] && \
+			echo "$watchfrr_pid" > "/sys/fs/cgroup/systemd/$cgmain/tasks"
+	fi
+
+	NEW_CONFIG_FILE="${2:-$C_PATH/frr.conf}"
+	[ ! -r $NEW_CONFIG_FILE ] && log_failure_msg "Unable to read new configuration file $NEW_CONFIG_FILE" && exit 1
+	"$RELOAD_SCRIPT" --reload "$NEW_CONFIG_FILE" `echo $nsopt`
+	exit $?
+	;;
+
+*)
+	log_failure_msg "Unknown command: $1" >&2
+	exit 1
+esac
diff -urpN frr-frr-8.1/usr/sbin/generate_support_bundle.py frr/usr/sbin/generate_support_bundle.py
--- frr-frr-8.1/usr/sbin/generate_support_bundle.py	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/sbin/generate_support_bundle.py	2021-08-31 15:25:51.994888474 +0700
@@ -0,0 +1,112 @@
+#!/usr/bin/python
+
+########################################################
+### Python Script to generate the FRR support bundle ###
+########################################################
+import os
+import subprocess
+import datetime
+
+TOOLS_DIR="tools/"
+ETC_DIR="/etc/frr/"
+LOG_DIR="/var/log/frr/"
+SUCCESS = 1
+FAIL = 0
+
+inputFile = ETC_DIR + "support_bundle_commands.conf"
+
+# Open support bundle configuration file
+def openConfFile(i_file):
+  try:
+    with open(i_file) as supportBundleConfFile:
+      lines = filter(None, (line.rstrip() for line in supportBundleConfFile))
+    return lines
+  except IOError:
+    return ([])
+
+# Create the output file name
+def createOutputFile(procName):
+  fileName = procName + "_support_bundle.log"
+  oldFile = LOG_DIR + fileName
+  cpFileCmd = "cp " + oldFile + " " + oldFile + ".prev"
+  rmFileCmd = "rm -rf " + oldFile
+  print("Making backup of " + oldFile)
+  os.system(cpFileCmd)
+  print("Removing " + oldFile)
+  os.system(rmFileCmd)
+  return fileName
+
+# Open the output file for this process
+def openOutputFile(fileName):
+  crt_file_cmd = LOG_DIR + fileName
+  print(crt_file_cmd)
+  try:
+    outputFile = open(crt_file_cmd, "w")
+    return outputFile
+  except IOError:
+    return ()
+
+# Close the output file for this process
+def closeOutputFile(file):
+  try:
+    file.close()
+    return SUCCESS
+  except IOError:
+    return FAIL
+
+# Execute the command over vtysh and store in the
+# output file
+def executeCommand(cmd, outputFile):
+  cmd_exec_str = "vtysh -c \"" + cmd + "\" "
+  try:
+    cmd_output = subprocess.check_output(cmd_exec_str, shell=True)
+    try:
+      dateTime = datetime.datetime.now()
+      outputFile.write(">>[" + str(dateTime) + "]" + cmd + "\n")
+      outputFile.write(cmd_output)
+      outputFile.write("########################################################\n")
+      outputFile.write('\n')
+    except:
+      print("Writing to ouptut file Failed")
+  except subprocess.CalledProcessError as e:
+    dateTime = datetime.datetime.now()
+    outputFile.write(">>[" + str(dateTime) + "]" + cmd + "\n")
+    outputFile.write(e.output)
+    outputFile.write("########################################################\n")
+    outputFile.write('\n')
+    print("Error:" + e.output)
+
+
+# Process the support bundle configuration file
+# and call appropriate functions
+def processConfFile(lines):
+  for line in lines:
+    if line[0][0] == '#':
+      continue
+    cmd_line = line.split(':')
+    if cmd_line[0] == "PROC_NAME":
+      outputFileName = createOutputFile(cmd_line[1])
+      if outputFileName:
+        print(outputFileName, "created for", cmd_line[1])
+    elif cmd_line[0] == "CMD_LIST_START":
+      outputFile = openOutputFile(outputFileName)
+      if outputFile:
+        print(outputFileName, "opened")
+      else:
+        print(outputFileName, "open failed")
+        return FAIL
+    elif cmd_line[0] == "CMD_LIST_END":
+      if closeOutputFile(outputFile):
+        print(outputFileName, "closed")
+      else:
+        print(outputFileName, "close failed")
+    else:
+      print("Execute:" , cmd_line[0])
+      executeCommand(cmd_line[0], outputFile)
+      
+# Main Function
+lines = openConfFile(inputFile)
+if not lines:
+  print("File support_bundle_commands.conf not present in /etc/frr/ directory")
+else:
+  processConfFile(lines)
Binary files frr-frr-8.1/usr/sbin/ospfd and frr/usr/sbin/ospfd differ
Binary files frr-frr-8.1/usr/sbin/ripd and frr/usr/sbin/ripd differ
Binary files frr-frr-8.1/usr/sbin/ripngd and frr/usr/sbin/ripngd differ
Binary files frr-frr-8.1/usr/sbin/ssd and frr/usr/sbin/ssd differ
Binary files frr-frr-8.1/usr/sbin/watchfrr and frr/usr/sbin/watchfrr differ
diff -urpN frr-frr-8.1/usr/sbin/watchfrr.sh frr/usr/sbin/watchfrr.sh
--- frr-frr-8.1/usr/sbin/watchfrr.sh	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/sbin/watchfrr.sh	2021-08-31 15:25:51.994888474 +0700
@@ -0,0 +1,33 @@
+#!/bin/bash
+#
+# This is NOT the init script!  This is the watchfrr start/stop/restart
+# command handler, passed to watchfrr with the -s/-r/-k commands.  It is used
+# internally by watchfrr to start the protocol daemons with the appropriate
+# options.
+#
+# This script should be installed in  /usr/sbin/watchfrr.sh
+
+log_success_msg() {
+	:
+}
+
+log_warning_msg() {
+	echo "$@" >&2
+	[ -x /usr/bin/logger ] && echo "$@" \
+		| /usr/bin/logger -t watchfrr.sh -p daemon.warn
+}
+
+log_failure_msg() {
+	echo "$@" >&2
+	[ -x /usr/bin/logger ] && echo "$@" \
+		| /usr/bin/logger -t watchfrr.sh -p daemon.err
+}
+
+self="`dirname $0`"
+if [ -r "$self/frrcommon.sh" ]; then
+	. "$self/frrcommon.sh"
+else
+	. "/usr/sbin/frrcommon.sh"
+fi
+
+frrcommon_main "$@"
Binary files frr-frr-8.1/usr/sbin/zebra and frr/usr/sbin/zebra differ
diff -urpN frr-frr-8.1/usr/share/yang/frr-bfdd.yang frr/usr/share/yang/frr-bfdd.yang
--- frr-frr-8.1/usr/share/yang/frr-bfdd.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-bfdd.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,471 @@
+module frr-bfdd {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/bfdd";
+  prefix frr-bfdd;
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+  import ietf-yang-types {
+    prefix yang;
+  }
+  import frr-interface {
+    prefix frr-interface;
+  }
+  import frr-route-types {
+    prefix frr-route-types;
+  }
+
+  organization "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines a model for managing FRR bfdd daemon.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-05-09 {
+    description "Initial revision.";
+    reference
+      "RFC 5880: Bidirectional Forwarding Detection (BFD).
+       RFC 5881: Bidirectional Forwarding Detection (BFD)
+                 for IPv4 and IPv6 (Single Hop).
+       RFC 5883: Bidirectional Forwarding Detection (BFD) for Multihop Paths.";
+  }
+
+
+  /*
+   * BFD types declaration.
+   */
+  typedef multiplier {
+    description "Detection multiplier";
+    type uint8 {
+      range 2..255;
+    }
+  }
+
+  typedef discriminator {
+    description "BFD session identification";
+    type uint32 {
+      range 1..4294967295;
+    }
+  }
+
+  typedef state {
+    description "BFD session state";
+    type enumeration {
+      enum admin-down {
+        value 0;
+        description "Administratively down";
+      }
+      enum down {
+        value 1;
+        description "Down";
+      }
+      enum init {
+        value 2;
+        description "Initializing";
+      }
+      enum up {
+        value 3;
+        description "Up";
+      }
+    }
+  }
+
+  typedef diagnostic {
+    description "BFD session diagnostic";
+    type enumeration {
+      enum ok {
+        value 0;
+        description "Ok";
+      }
+      enum control-expired {
+        value 1;
+        description "Control timer expired";
+      }
+      enum echo-failed {
+        value 2;
+        description "Echo function failed";
+      }
+      enum neighbor-down {
+        value 3;
+        description "Neighbor signaled session down";
+      }
+      enum forwarding-reset {
+        value 4;
+        description "Forwarding plane reset";
+      }
+      enum path-down {
+        value 5;
+        description "Path down";
+      }
+      enum concatenated-path-down {
+        value 6;
+        description "Concatenated path down";
+      }
+      enum administratively-down {
+        value 7;
+        description "Administratively down";
+      }
+      enum reverse-concat-path-down {
+        value 8;
+        description "Reverse concatenated path down";
+      }
+    }
+  }
+
+  typedef profile-name {
+    type string {
+      length "1..64";
+    }
+    description "Profile name format";
+  }
+
+  typedef profile-ref {
+    type leafref {
+      path "/frr-bfdd:bfdd/frr-bfdd:bfd/frr-bfdd:profile/frr-bfdd:name";
+      require-instance false;
+    }
+    description "Reference to a BFD profile";
+  }
+
+  /*
+   * Shared BFD items.
+   */
+  grouping session-common {
+    description "Common BFD session settings";
+
+    leaf detection-multiplier {
+      type multiplier;
+      default 3;
+      description "Local session detection multiplier";
+    }
+
+    leaf desired-transmission-interval {
+      type uint32;
+      units microseconds;
+      default 300000;
+      description "Minimum desired control packet transmission interval";
+    }
+
+    leaf required-receive-interval {
+      type uint32;
+      units microseconds;
+      default 300000;
+      description "Minimum required control packet receive interval";
+    }
+
+    leaf administrative-down {
+      type boolean;
+      default false;
+      description "Disables or enables the session administratively";
+    }
+
+    leaf passive-mode {
+      type boolean;
+      default false;
+      description
+        "Don't attempt to start session establishment.";
+    }
+  }
+
+  grouping session-echo {
+    description "BFD session echo settings";
+
+    leaf echo-mode {
+      type boolean;
+      default false;
+      description "Use echo packets to detect failures";
+    }
+
+    leaf desired-echo-transmission-interval {
+      type uint32;
+      units microseconds;
+      default 50000;
+      description "Minimum desired control packet transmission interval";
+    }
+  }
+
+  grouping session-multi-hop {
+    description "BFD session multi hop settings.";
+
+    leaf minimum-ttl {
+      type uint8 {
+        range 1..254;
+      }
+      description
+        "Minimum expected TTL on received packets.";
+    }
+  }
+
+  grouping session-states {
+    /*
+     * Local settings.
+     */
+    leaf local-discriminator {
+      type discriminator;
+      description "Local session identifier";
+    }
+
+    leaf local-state {
+      type state;
+      description "Local session state";
+    }
+
+    leaf local-diagnostic {
+      type diagnostic;
+      description "Local session diagnostic";
+    }
+
+    leaf local-multiplier {
+      type multiplier;
+      description "Local session current multiplier";
+    }
+
+    /*
+     * Remote settings.
+     */
+    leaf remote-discriminator {
+      type discriminator;
+      description "Remote session identifier";
+    }
+
+    leaf remote-state {
+      type state;
+      description "Remote session state";
+    }
+
+    leaf remote-diagnostic {
+      type diagnostic;
+      description "Local session diagnostic";
+    }
+
+    leaf remote-multiplier {
+      type multiplier;
+      description "Remote session detection multiplier";
+    }
+
+    /*
+     * Negotiated settings.
+     */
+    leaf negotiated-transmission-interval {
+      description "Negotiated transmit interval";
+      type uint32;
+      units microseconds;
+    }
+
+    leaf negotiated-receive-interval {
+      description "Negotiated receive interval";
+      type uint32;
+      units microseconds;
+    }
+
+    leaf detection-mode {
+      description "Detection mode";
+
+      type enumeration {
+        enum async-with-echo {
+          value "1";
+          description "Async with echo";
+        }
+        enum async-without-echo {
+          value "2";
+          description "Async without echo";
+        }
+        enum demand-with-echo {
+          value "3";
+          description "Demand with echo";
+        }
+        enum demand-without-echo {
+          value "4";
+          description "Demand without echo";
+        }
+      }
+    }
+
+    /*
+     * Statistics.
+     */
+    leaf last-down-time {
+      type yang:date-and-time;
+      description "Time and date of the last time session was down";
+    }
+
+    leaf last-up-time {
+      type yang:date-and-time;
+      description "Time and date of the last time session was up";
+    }
+
+    leaf session-down-count {
+      type uint32;
+      description "Number of times the session went down";
+    }
+
+    leaf session-up-count {
+      type uint32;
+      description "Number of times the session went up";
+    }
+
+    leaf control-packet-input-count {
+      type uint64;
+      description "Number of control packets received";
+    }
+
+    leaf control-packet-output-count {
+      type uint64;
+      description "Number of control packets sent";
+    }
+
+    /*
+     * Echo mode operational data.
+     */
+    leaf negotiated-echo-transmission-interval {
+      type uint32;
+      units microseconds;
+      description "Negotiated echo transmit interval";
+    }
+
+    /*
+     * Statistics.
+     */
+    leaf echo-packet-input-count {
+      type uint64;
+      description "Number of echo packets received";
+    }
+
+    leaf echo-packet-output-count {
+      type uint64;
+      description "Number of echo packets sent";
+    }
+  }
+
+  /*
+   * BFD operational.
+   */
+  container bfdd {
+    container bfd {
+      presence "Present if the BFD protocol is enabled";
+
+      list profile {
+        key "name";
+        description "BFD pre configuration profiles";
+
+        leaf name {
+          type profile-name;
+          description "Profile name";
+        }
+
+        uses session-common;
+        uses session-echo;
+        uses session-multi-hop;
+      }
+
+      container sessions {
+        list single-hop {
+          key "dest-addr interface vrf";
+          description "List of single hop sessions";
+
+          leaf dest-addr {
+            type inet:ip-address;
+            description "IP address of the peer";
+          }
+
+          leaf interface {
+            type string {
+              length "0..16";
+            }
+            description "Interface to use to contact peer";
+          }
+
+          leaf vrf {
+            type string;
+            description "Virtual Routing Domain name";
+          }
+
+          leaf source-addr {
+            type inet:ip-address;
+            description "Local IP address";
+          }
+
+          leaf profile {
+            type profile-ref;
+            description "Override defaults with profile.";
+          }
+
+          uses session-common;
+          uses session-echo;
+
+          container stats {
+            uses session-states;
+            config false;
+          }
+        }
+
+        list multi-hop {
+          key "source-addr dest-addr interface vrf";
+          description "List of multi hop sessions";
+
+          leaf source-addr {
+            type inet:ip-address;
+            description "Local IP address";
+          }
+
+          leaf dest-addr {
+            type inet:ip-address;
+            description "IP address of the peer";
+          }
+
+          leaf interface {
+            type string {
+              length "0..16";
+            }
+            description "Interface to use to contact peer";
+          }
+
+          leaf vrf {
+            type string;
+            description "Virtual Routing Domain name";
+          }
+
+          leaf profile {
+            type profile-ref;
+            description "Override defaults with profile.";
+          }
+
+          uses session-common;
+          uses session-multi-hop;
+
+          container stats {
+            uses session-states;
+            config false;
+          }
+        }
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-filter.yang frr/usr/share/yang/frr-filter.yang
--- frr-frr-8.1/usr/share/yang/frr-filter.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-filter.yang	2021-08-31 15:25:52.002888483 +0700
@@ -0,0 +1,356 @@
+module frr-filter {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/filter";
+  prefix frr-filter;
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+  import ietf-yang-types {
+    prefix yang;
+  }
+
+  organization "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines filter settings
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-07-04 {
+    description "Initial revision";
+  }
+
+  /*
+   * Types.
+   */
+  typedef access-list-name {
+    description "Access list name formatting";
+    type string {
+      length 1..128;
+    }
+  }
+
+  typedef access-list-sequence {
+    description "Access list sequence number";
+    type uint32 {
+      range "1..4294967295";
+    }
+  }
+
+  typedef access-list-action {
+    description "Access list return action on match";
+    type enumeration {
+      enum deny {
+        description "Deny an entry";
+        value 0;
+      }
+      enum permit {
+        description "Accept an entry";
+        value 1;
+      }
+    }
+  }
+
+  /*
+   * Configuration data.
+   */
+  container lib {
+    list access-list {
+      description "Access list instance";
+
+      key "type name";
+
+      leaf type {
+        description "Access list content type";
+        type enumeration {
+          enum ipv4 {
+            description "Internet Protocol address version 4";
+            value 0;
+          }
+          enum ipv6 {
+            description "Internet Protocol address version 6";
+            value 1;
+          }
+          enum mac {
+            description "Media Access Control address";
+            value 2;
+          }
+        }
+      }
+
+      leaf name {
+        description "Access list name";
+        type access-list-name;
+      }
+
+      leaf remark {
+        description "Access list remark";
+        type string;
+      }
+
+      list entry {
+        description "Access list entry";
+
+        key "sequence";
+
+        leaf sequence {
+          description "Access list sequence value";
+          type access-list-sequence;
+        }
+
+        leaf action {
+          description "Access list action on match";
+          type access-list-action;
+          mandatory true;
+        }
+
+        choice value {
+          description "Access list value to match";
+          mandatory true;
+
+          case ipv4-prefix {
+            when "../type = 'ipv4'";
+
+            choice style {
+              description "Access list entry style selection: zebra or cisco.";
+              mandatory true;
+
+              case zebra {
+                leaf ipv4-prefix {
+                  description "Configure IPv4 prefix to match";
+                  type inet:ipv4-prefix;
+                }
+
+                leaf ipv4-exact-match {
+                  description "Exact match of prefix";
+                  type boolean;
+                  default false;
+                }
+              }
+              case cisco {
+                choice standard-value {
+                  description "Source value to match";
+
+                  leaf host {
+                    description "Host to match";
+                    type inet:ipv4-address;
+                  }
+                  container network {
+                    leaf address {
+                      mandatory true;
+                      description "Network address part.";
+                      type inet:ipv4-address;
+                    }
+                    leaf mask {
+                      mandatory true;
+                      description "Network mask/wildcard part.";
+                      type inet:ipv4-address;
+                    }
+                  }
+                  leaf source-any {
+                    /*
+                     * Was `any`, however it conflicts with `any` leaf
+                     * outside this choice.
+                     */
+                    description "Match any";
+                    type empty;
+                  }
+                }
+
+                choice extended-value {
+                  description "Destination value to match";
+
+                  leaf destination-host {
+                    description "Host to match";
+                    type inet:ipv4-address;
+                  }
+                  container destination-network {
+                    leaf address {
+                      mandatory true;
+                      description "Network address part.";
+                      type inet:ipv4-address;
+                    }
+                    leaf mask {
+                      mandatory true;
+                      description "Network mask/wildcard part.";
+                      type inet:ipv4-address;
+                    }
+                  }
+                  leaf destination-any {
+                    description "Match any";
+                    type empty;
+                  }
+                }
+              }
+            }
+          }
+          case ipv6-prefix {
+            when "../type = 'ipv6'";
+
+            leaf ipv6-prefix {
+              description "Configure IPv6 prefix to match";
+              type inet:ipv6-prefix;
+            }
+
+            leaf ipv6-exact-match {
+              description "Exact match of prefix";
+              type boolean;
+              default false;
+            }
+          }
+          case mac {
+            when "../type = 'mac'";
+
+            leaf mac {
+              description "Configure MAC address to match";
+              type yang:mac-address;
+            }
+          }
+          case any {
+            leaf any {
+              description "Match anything";
+              type empty;
+            }
+          }
+        }
+      }
+    }
+
+    list prefix-list {
+      description "Prefix list instance";
+
+      key "type name";
+
+      leaf type {
+        description "Prefix list type";
+        type enumeration {
+          enum ipv4 {
+            description "Internet Protocol address version 4";
+            value 0;
+          }
+          enum ipv6 {
+            description "Internet Protocol address version 6";
+            value 1;
+          }
+        }
+      }
+
+      leaf name {
+        description "Prefix list name";
+        type access-list-name;
+      }
+
+      leaf remark {
+        description "Prefix list user description";
+        type string;
+      }
+
+      list entry {
+        description "Prefix list entry";
+
+        key "sequence";
+
+        leaf sequence {
+          description "Access list sequence value";
+          type access-list-sequence;
+        }
+
+        leaf action {
+          description "Prefix list action on match";
+          type access-list-action;
+          mandatory true;
+        }
+
+        choice value {
+          description "Prefix list value to match";
+          mandatory true;
+
+          case ipv4-prefix {
+            when "../type = 'ipv4'";
+
+            leaf ipv4-prefix {
+              description "Configure IPv4 prefix to match";
+              type inet:ipv4-prefix;
+            }
+
+            leaf ipv4-prefix-length-greater-or-equal {
+              description
+                "Specifies if matching prefixes with length greater than
+                 or equal to value";
+              type uint8 {
+                range "0..32";
+              }
+            }
+
+            leaf ipv4-prefix-length-lesser-or-equal {
+              description
+                "Specifies if matching prefixes with length lesser than
+                 or equal to value";
+              type uint8 {
+                range "0..32";
+              }
+            }
+          }
+          case ipv6-prefix {
+            when "../type = 'ipv6'";
+
+            leaf ipv6-prefix {
+              description "Configure IPv6 prefix to match";
+              type inet:ipv6-prefix;
+            }
+
+            leaf ipv6-prefix-length-greater-or-equal {
+              description
+                "Specifies if matching prefixes with length greater than
+                 or equal to value";
+              type uint8 {
+                range "0..128";
+              }
+            }
+
+            leaf ipv6-prefix-length-lesser-or-equal {
+              description
+                "Specifies if matching prefixes with length lesser than
+                 or equal to value";
+              type uint8 {
+                range "0..128";
+              }
+            }
+          }
+          case any {
+            leaf any {
+              description "Match anything";
+              type empty;
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-interface.yang frr/usr/share/yang/frr-interface.yang
--- frr-frr-8.1/usr/share/yang/frr-interface.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-interface.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,320 @@
+module frr-interface {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/interface";
+  prefix frr-interface;
+
+  import frr-vrf {
+    prefix frr-vrf;
+  }
+
+  import ietf-interfaces {
+    prefix ietf-if;
+  }
+
+  import ietf-yang-types {
+    prefix yang;
+  }
+
+  organization
+    "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines a model for managing FRR interfaces.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2020-02-05 {
+    description
+      "Added operational data";
+  }
+  revision 2019-09-09 {
+    description
+      "Added interface-ref typedef";
+  }
+  revision 2018-03-28 {
+    description
+      "Initial revision.";
+  }
+
+  identity other {
+    base ietf-if:interface-type;
+    description
+      "Other type";
+  }
+
+  identity unknown {
+    base ietf-if:interface-type;
+    description
+      "Unknown type";
+  }
+
+  identity ethernet {
+    base ietf-if:interface-type;
+    description
+      "Ethernet type";
+  }
+
+  identity exper-ethernet {
+    base ietf-if:interface-type;
+    description
+      "Experimental Ethernet type";
+  }
+
+  identity loopback {
+    base ietf-if:interface-type;
+    description
+      "Loopback type";
+  }
+
+  identity pimreg {
+    base ietf-if:interface-type;
+    description
+      "PIMSM Registration.";
+  }
+
+  identity ipip {
+    base ietf-if:interface-type;
+    description
+      "IPIP Tunnel.";
+  }
+
+  identity ipip6 {
+    base ietf-if:interface-type;
+    description
+      "IPIP6 Tunnel.";
+  }
+
+  identity ipgre {
+    base ietf-if:interface-type;
+    description
+      "GRE over IP.";
+  }
+
+  typedef interface-ref {
+    type leafref {
+      path "/frr-interface:lib/frr-interface:interface/frr-interface:name";
+      require-instance false;
+    }
+    description
+      "Reference to an interface";
+  }
+
+  typedef if-flags-type {
+    type enumeration {
+      enum "up" {
+        value 1;
+        description
+          "Active and ready to transfer packets.";
+      }
+      enum "broadcast" {
+        value 2;
+        description
+          "Broadcast enabled.";
+      }
+      enum "debug" {
+        value 3;
+        description
+          "Debug mode.";
+      }
+      enum "loopback" {
+        value 4;
+        description
+          "Loopback interface.";
+      }
+      enum "point-to-point" {
+        value 5;
+        description
+          "Point-to-Point link.";
+      }
+      enum "notrailers" {
+        value 6;
+        description
+          "This flag is unused in Linux, but it exists for BSD compatibility.
+          Avoid use of trailers";
+      }
+      enum "running" {
+        value 7;
+        description
+          "Up and Running.";
+      }
+      enum "noarp" {
+        value 8;
+        description
+          "Can't perform address resolution protocol.";
+      }
+      enum "promisc" {
+        value 9;
+        description
+          "Promiscuous mode. Receive all packets.";
+      }
+      enum "allmulti" {
+        value 10;
+        description
+          "Receive all multicast packets.";
+      }
+      enum "simplex" {
+        value 11;
+        description
+          "Does not Rx or Tx at the sametime.";
+      }
+      enum "link0" {
+        value 12;
+        description
+          "Link0.";
+      }
+      enum "link1" {
+        value 13;
+        description
+          "Link1.";
+      }
+      enum "link2" {
+        value 14;
+        description
+          "Link2.";
+      }
+      enum "multicast" {
+        value 15;
+        description
+          "Supports multicast transmission.";
+      }
+      enum "notransmit" {
+        value 16;
+        description
+          "Interface is no transmit mode.";
+      }
+      enum "nortexch" {
+        value 17;
+        description
+          "No routing info exchange.";
+      }
+      enum "virtual" {
+        value 18;
+        description
+          "Virtual interface.";
+      }
+      enum "ipv4" {
+        value 19;
+        description
+          "IPv4 enabled.";
+      }
+      enum "ipv6" {
+        value 20;
+        description
+          "IPv6 enabled.";
+      }
+    }
+  }
+
+  grouping if-common-operational {
+    leaf if-index {
+      type int32 {
+        range "0..2147483647";
+      }
+      description
+        "Interface index.";
+    }
+
+    leaf mtu {
+      type uint16;
+      description
+        "The size of the largest IPV4 packet that the interface
+         will send and receive.";
+    }
+
+    leaf mtu6 {
+      type uint32;
+      description
+        "The size of the largest IPV6 packet that the interface
+         will send and receive.";
+    }
+
+    leaf speed {
+      type uint32;
+      description
+        "Interface speed.";
+    }
+
+    leaf metric {
+      type uint32;
+      description
+        "Interface metric.";
+    }
+
+    leaf flags {
+      type if-flags-type;
+      description
+        "Interface flags.";
+    }
+
+    leaf type {
+      type identityref {
+        base ietf-if:interface-type;
+      }
+      description
+        "The link type of the interface.";
+    }
+
+    leaf phy-address {
+      type yang:mac-address;
+      description
+        "The interface's MAC address.";
+    }
+  }
+
+  container lib {
+    list interface {
+      key "name vrf";
+      description
+        "Interface.";
+      leaf name {
+        type string {
+          length "1..16";
+        }
+        description
+          "Interface name.";
+      }
+
+      leaf vrf {
+        type frr-vrf:vrf-ref;
+        description
+          "VRF this interface is associated with.";
+      }
+
+      leaf description {
+        type string;
+        description
+          "Interface description.";
+      }
+
+      container state {
+        config false;
+        uses if-common-operational;
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-module-translator.yang frr/usr/share/yang/frr-module-translator.yang
--- frr-frr-8.1/usr/share/yang/frr-module-translator.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-module-translator.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,93 @@
+module frr-module-translator {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/frr-module-translator";
+  prefix frr-module-translator;
+
+  organization
+    "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "A model for FRR YANG module translators.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2018-07-31 {
+    description
+      "Initial revision.";
+  }
+
+  container frr-module-translator {
+    leaf family {
+      type string {
+        length "0 .. 32";
+      }
+      mandatory true;
+      description
+        "Family of YANG models.";
+    }
+    list module {
+      key "name";
+      ordered-by user;
+      description
+        "YANG module.";
+
+      leaf name {
+        type string;
+        description
+          "Module name.";
+      }
+      leaf deviations {
+        type string;
+        mandatory true;
+        description
+          "Module containing the YANG deviations.";
+      }
+      list mappings {
+        key "custom";
+        description
+          "YANG mappings between the custom module and FRR native modules.";
+
+        leaf custom {
+          type string {
+            length "0 .. 256";
+          }
+          description
+            "YANG path of the custom module.";
+        }
+        leaf native {
+          type string {
+            length "0 .. 256";
+          }
+          mandatory true;
+          description
+            "Corresponding path of the native YANG modules";
+        }
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-nexthop.yang frr/usr/share/yang/frr-nexthop.yang
--- frr-frr-8.1/usr/share/yang/frr-nexthop.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-nexthop.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,318 @@
+module frr-nexthop {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/nexthop";
+  prefix frr-nexthop;
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+
+  import ietf-routing-types {
+    prefix rt-types;
+  }
+
+  import frr-interface {
+    prefix frr-interface;
+  }
+
+  import frr-vrf {
+    prefix frr-vrf;
+  }
+
+  organization
+    "FRRouting";
+  contact
+    "FRR Users List: <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines a model for managing FRR nexthop information.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-08-15 {
+    description
+      "Initial revision.";
+  }
+
+  typedef optional-ip-address {
+    type union {
+      type inet:ip-address;
+      type string {
+        pattern '';
+      }
+    }
+  }
+
+  /*
+   * Nexthop types.
+   */
+  typedef nexthop-type {
+    type enumeration {
+      enum "ifindex" {
+        value 1;
+        description
+          "Specific interface.";
+      }
+      enum "ip4" {
+        value 2;
+        description
+          "IPv4 address.";
+      }
+      enum "ip4-ifindex" {
+        value 3;
+        description
+          "IPv4 address and interface.";
+      }
+      enum "ip6" {
+        value 4;
+        description
+          "IPv6 address.";
+      }
+      enum "ip6-ifindex" {
+        value 5;
+        description
+          "IPv6 address and interface.";
+      }
+      enum "blackhole" {
+        value 6;
+        description
+          "Unreachable or prohibited.";
+      }
+    }
+    description
+      "Nexthop types.";
+  }
+
+  /*
+   * Blockhole nexthop type.
+   */
+  typedef blackhole-type {
+    type enumeration {
+      enum "unspec" {
+        value 0;
+        description
+          "Generic unreachable.";
+      }
+      enum "null" {
+        value 1;
+        description
+          "Null type.";
+      }
+      enum "reject" {
+        value 2;
+        description
+          "ICMP unreachable.";
+      }
+      enum "prohibited" {
+        value 3;
+        description
+          "ICMP admin-prohibited.";
+      }
+    }
+    default "null";
+    description
+      "Nexthop blackhole types.";
+  }
+
+  typedef nexthop-group-ref {
+    type leafref {
+      path "/frr-nexthop:frr-nexthop-group/frr-nexthop:nexthop-groups/frr-nexthop:name";
+      require-instance false;
+    }
+  }
+
+  /*
+   * Common nexthop attributes grouping.
+   */
+  grouping frr-nexthop-attributes {
+    leaf nh-type {
+      type nexthop-type;
+      mandatory true;
+      description
+        "The nexthop type.";
+    }
+
+    leaf vrf {
+      type string;
+      description
+        "The nexthop vrf name, if different from the route.";
+    }
+    leaf gateway {
+      type frr-nexthop:optional-ip-address;
+      description
+        "The nexthop gateway address.";
+    }
+
+    leaf interface {
+      type string;
+      description
+        "The nexthop egress interface.";
+    }
+
+    leaf bh-type {
+      when "../nh-type = 'blackhole'";
+      type blackhole-type;
+      description
+        "A blackhole sub-type, if the nexthop is a blackhole type.";
+    }
+
+    leaf onlink {
+      when "../nh-type = 'ip4-ifindex' or
+            ../nh-type = 'ip6-ifindex'";
+      type boolean;
+      default "false";
+      description
+        "Nexthop is directly connected.";
+    }
+
+    leaf srte-color {
+      when "../nh-type = 'ip4' or
+            ../nh-type = 'ip6' or
+            ../nh-type = 'ip4-ifindex' or
+            ../nh-type = 'ip6-ifindex'";
+      type uint32;
+      description
+        "The nexthop SR-TE color";
+    }
+
+    uses rt-types:mpls-label-stack {
+      description
+        "Nexthop's MPLS label stack.";
+    }
+  }
+
+  /*
+   * operational common attributes for nexthop
+   */
+  grouping frr-nexthop-operational {
+    leaf duplicate {
+      type empty;
+      config false;
+      description
+        "Duplicate nexthop";
+    }
+
+    leaf recursive {
+      type empty;
+      config false;
+      description
+        "Nexthop resolved through another gateway.";
+    }
+
+    leaf active {
+      type empty;
+      config false;
+      description
+        "Nexthop is active.";
+    }
+
+    leaf fib {
+      type empty;
+      config false;
+      description
+        "Nexthop is installed in fib.";
+    }
+
+    leaf weight {
+      type uint8;
+      config false;
+      description
+        "Weight to be used by the nexthop for purposes of ECMP";
+    }
+  }
+
+  grouping nexthop-grouping {
+    list nexthop {
+      key "nh-type vrf gateway interface";
+      min-elements 1;
+      description
+        "A list of nexthop objects.";
+      uses frr-nexthop-attributes;
+    }
+  }
+
+  /*
+   * Single nexthop grouping.
+   */
+  grouping frr-nexthop {
+    container frr-nexthops {
+      description
+        "FRR nexthop object.";
+      uses nexthop-grouping;
+    }
+  }
+
+
+  /*
+   * Container for FRR nexthop group.
+   */
+  grouping frr-nexthop-grouping {
+    list nexthop-groups {
+      key "name";
+      description
+        "List of nexthop groups, each contains group of nexthops";
+      leaf name {
+        type string;
+        description
+          "The nexthop-group name.";
+      }
+
+      uses frr-nexthop;
+    }
+  }
+
+  /* Operational nexthop-group */
+  grouping frr-nexthop-group-operational {
+    container nexthop-group {
+      description
+        "A group of nexthops.";
+      leaf id {
+        type uint32;
+        description
+          "The nexthop-group id.";
+      }
+
+      uses nexthop-grouping;
+    }
+  }
+
+  container frr-nexthop-group {
+    description
+      "A nexthop-group, represented as a list of nexthop objects.";
+    uses frr-nexthop-grouping;
+  }
+
+  /*
+   * Augment weight attributes to nexthop group.
+   */
+  augment "/frr-nexthop-group/nexthop-groups/frr-nexthops/nexthop" {
+    leaf weight {
+      type uint8;
+      description
+        "Weight to be used by the nexthop for purposes of ECMP";
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-ripd.yang frr/usr/share/yang/frr-ripd.yang
--- frr-frr-8.1/usr/share/yang/frr-ripd.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-ripd.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,637 @@
+module frr-ripd {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/ripd";
+  prefix frr-ripd;
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+  import ietf-yang-types {
+    prefix yang;
+  }
+  import frr-interface {
+    prefix frr-interface;
+  }
+  import frr-route-types {
+    prefix frr-route-types;
+  }
+
+  organization
+    "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines a model for managing FRR ripd daemon.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-09-09 {
+    description
+      "Changed interface references to use
+      frr-interface:interface-ref typedef";
+  }
+  revision 2017-12-06 {
+    description
+      "Initial revision.";
+    reference
+      "RFC 1058: Routing Information Protocol.
+       RFC 2453: RIP Version 2.";
+  }
+
+  container ripd {
+    /*
+     * Routing instance configuration.
+     */
+    list instance {
+      key "vrf";
+      description
+        "RIP routing instance.";
+
+      leaf vrf {
+        type string;
+        description
+          "VRF name.";
+      }
+      leaf allow-ecmp {
+        type boolean;
+        default "false";
+        description
+          "Allow equal-cost multi-path.";
+      }
+      leaf default-information-originate {
+        type boolean;
+        default "false";
+        description
+          "Control distribution of default route.";
+      }
+      leaf default-metric {
+        type uint8 {
+          range "1..16";
+        }
+        default "1";
+        description
+          "Default metric of redistributed routes.";
+      }
+      container distance {
+        description
+          "Administrative distance.";
+        leaf default {
+          type uint8 {
+            range "0..255";
+          }
+          default "0";
+          description
+            "Default administrative distance.";
+        }
+        list source {
+          key "prefix";
+          description
+            "Custom administrative distance per IP prefix.";
+          leaf prefix {
+            type inet:ipv4-prefix;
+            description
+              "Prefix.";
+          }
+          leaf distance {
+            type uint8 {
+              range "1..255";
+            }
+            mandatory true;
+            description
+              "Administrative distance.";
+          }
+          leaf access-list {
+            type string;
+            description
+              "Access-list name.";
+          }
+        }
+      }
+      leaf-list explicit-neighbor {
+        type inet:ipv4-address;
+        description
+          "Specifies the RIP neighbors. Useful for a
+           non-broadcast multiple access (NBMA) network.";
+      }
+      leaf-list network {
+        type inet:ipv4-prefix;
+        description
+          "Enable RIP on the specified IP network.";
+      }
+      leaf-list interface {
+        type frr-interface:interface-ref;
+        description
+          "Enable RIP on the specified interface.";
+      }
+      list offset-list {
+        key "interface direction";
+        description
+          "Offset-list to modify route metric.";
+        leaf interface {
+          type union {
+            type frr-interface:interface-ref;
+            type enumeration {
+              enum '*' {
+                description
+                  "Match all interfaces.";
+              }
+            }
+          }
+          description
+            "Interface to match. Use '*' to match all interfaces.";
+        }
+        leaf direction {
+          type enumeration {
+            enum in {
+              value 0;
+              description
+                "Incoming updates.";
+            }
+            enum out {
+              value 1;
+              description
+                "Outgoing updates.";
+            }
+          }
+          description
+            "Incoming or outgoing updates.";
+        }
+        leaf access-list {
+          type string;
+          mandatory true;
+          description
+            "Access-list name.";
+        }
+        leaf metric {
+          type uint8 {
+            range "0..16";
+          }
+          mandatory true;
+          description
+            "Route metric.";
+        }
+      }
+      leaf passive-default {
+        type boolean;
+        default "false";
+        description
+          "Control whether interfaces are in the passive mode
+           by default or not.";
+      }
+      leaf-list passive-interface {
+        when "../passive-default = 'false'";
+        type frr-interface:interface-ref;
+        description
+          "A list of interfaces where the sending of RIP packets
+           is disabled.";
+      }
+      leaf-list non-passive-interface {
+        when "../passive-default = 'true'";
+        type frr-interface:interface-ref;
+        description
+          "A list of interfaces where the sending of RIP packets
+           is enabled.";
+      }
+      list redistribute {
+        key "protocol";
+        description
+          "Redistributes routes learned from other routing protocols.";
+        leaf protocol {
+          type frr-route-types:frr-route-types-v4;
+          description
+            "Routing protocol.";
+          must '. != "rip"';
+        }
+        leaf route-map {
+          type string {
+            length "1..max";
+          }
+          description
+            "Applies the conditions of the specified route-map to
+             routes that are redistributed into the RIP routing
+             instance.";
+        }
+        leaf metric {
+          type uint8 {
+            range "0..16";
+          }
+          description
+            "Metric used for the redistributed route. If a metric is
+             not specified, the metric configured with the
+             default-metric attribute in RIP router configuration is
+             used. If the default-metric attribute has not been
+             configured, the default metric for redistributed routes
+             is 0.";
+        }
+      }
+      leaf-list static-route {
+        type inet:ipv4-prefix;
+        description
+          "RIP static routes.";
+      }
+      container timers {
+        description
+          "Settings of basic timers";
+        leaf flush-interval {
+          type uint32 {
+            range "5..2147483647";
+          }
+          units "seconds";
+          default "120";
+          description
+            "Interval before a route is flushed from the routing
+             table.";
+        }
+        leaf holddown-interval {
+          type uint32 {
+            range "5..2147483647";
+          }
+          units "seconds";
+          default "180";
+          description
+            "Interval before better routes are released.";
+        }
+        leaf update-interval {
+          type uint32 {
+            range "5..2147483647";
+          }
+          units "seconds";
+          default "30";
+          description
+            "Interval at which RIP updates are sent.";
+        }
+      }
+      container version {
+        leaf receive {
+          type enumeration {
+            enum "1" {
+              value 1;
+              description
+                "Accept RIPv1 updates only.";
+            }
+            enum "2" {
+              value 2;
+              description
+                "Accept RIPv2 updates only.";
+            }
+            enum "1-2" {
+              value 3;
+              description
+                "Accept both RIPv1 and RIPv2 updates.";
+            }
+          }
+          default "1-2";
+          description
+            "Advertisement reception - Version control.";
+        }
+        leaf send {
+          type enumeration {
+            enum "1" {
+              value 1;
+              description
+                "Send RIPv1 updates only.";
+            }
+            enum "2" {
+              value 2;
+              description
+                "Send RIPv2 updates only.";
+            }
+          }
+          default "2";
+          description
+            "Advertisement transmission - Version control.";
+        }
+        must
+          '(./receive = "1" and ./send = "1") or ' +
+          '(./receive = "2" and ./send = "2") or ' +
+          '(./receive = "1-2" and ./send = "2")';
+      }
+
+      /*
+       * Operational data.
+       */
+      container state {
+        config false;
+        description
+          "Operational data.";
+
+        container neighbors {
+          description
+            "Neighbor information.";
+          list neighbor {
+            key "address";
+            description
+              "A RIP neighbor.";
+            leaf address {
+              type inet:ipv4-address;
+              description
+                "IP address that a RIP neighbor is using as its
+                 source address.";
+            }
+            leaf last-update {
+              type yang:date-and-time;
+              description
+                "The time when the most recent RIP update was
+                 received from this neighbor.";
+            }
+            leaf bad-packets-rcvd {
+              type yang:counter32;
+              description
+                "The number of RIP invalid packets received from
+                 this neighbor which were subsequently discarded
+                 for any reason (e.g. a version 0 packet, or an
+                 unknown command type).";
+            }
+            leaf bad-routes-rcvd {
+              type yang:counter32;
+              description
+                "The number of routes received from this neighbor,
+                 in valid RIP packets, which were ignored for any
+                 reason (e.g. unknown address family, or invalid
+                 metric).";
+            }
+          }
+        }
+        container routes {
+          description
+            "Route information.";
+          list route {
+            key "prefix";
+            description
+              "A RIP IPv4 route.";
+            leaf prefix {
+              type inet:ipv4-prefix;
+              description
+                "IP address (in the form A.B.C.D) and prefix length,
+                 separated by the slash (/) character. The range of
+                 values for the prefix-length is 0 to 32.";
+            }
+            leaf next-hop {
+              type inet:ipv4-address;
+              description
+                "Next hop IPv4 address.";
+            }
+            leaf interface {
+              type string;
+              description
+                "The interface that the route uses.";
+            }
+            leaf metric {
+              type uint8 {
+                range "0..16";
+              }
+              description
+                "Route metric.";
+            }
+          }
+        }
+      }
+    }
+  }
+
+  /*
+   * Per-interface configuration data
+   */
+  augment "/frr-interface:lib/frr-interface:interface" {
+    container rip {
+      description
+        "RIP interface parameters.";
+      leaf split-horizon {
+        type enumeration {
+          enum "disabled" {
+            value 0;
+            description
+              "Disables split-horizon processing.";
+          }
+          enum "simple" {
+            value 1;
+            description
+              "Enables simple split-horizon processing.";
+          }
+          enum "poison-reverse" {
+            value 2;
+            description
+              "Enables split-horizon processing with poison
+               reverse.";
+          }
+        }
+        default "simple";
+        description
+          "Controls RIP split-horizon processing on the specified
+           interface.";
+      }
+      leaf v2-broadcast {
+        type boolean;
+        default "false";
+        description
+          "Send IP broadcast v2 update.";
+      }
+      leaf version-receive {
+        type enumeration {
+          enum "unspecified" {
+            value 0;
+            description
+              "Inherit configuration from the routing instance.";
+          }
+          enum "1" {
+            value 1;
+            description
+              "Accept RIPv1 updates only.";
+          }
+          enum "2" {
+            value 2;
+            description
+              "Accept RIPv2 updates only.";
+          }
+          enum "both" {
+            value 3;
+            description
+              "Accept both RIPv1 and RIPv2 updates.";
+          }
+          enum "none" {
+            value 4;
+            description
+              "Do not accept neither RIPv1 nor RIPv2 updates.";
+          }
+        }
+        default "unspecified";
+        description
+          "Advertisement reception - Version control.";
+      }
+      leaf version-send {
+        type enumeration {
+          enum "unspecified" {
+            value 0;
+            description
+              "Inherit configuration from the routing instance.";
+          }
+          enum "1" {
+            value 1;
+            description
+              "Send RIPv1 updates only.";
+          }
+          enum "2" {
+            value 2;
+            description
+              "Send RIPv2 updates only.";
+          }
+          enum "both" {
+            value 3;
+            description
+              "Send both RIPv1 and RIPv2 updates.";
+          }
+          enum "none" {
+            value 4;
+            description
+              "Do not send neither RIPv1 nor RIPv2 updates.";
+          }
+        }
+        default "unspecified";
+        description
+          "Advertisement transmission - Version control.";
+      }
+      container authentication-scheme {
+        description
+          "Specify the authentication scheme for the RIP interface";
+        leaf mode {
+          type enumeration {
+            enum "none" {
+              value 0;
+              description
+                "No authentication.";
+            }
+            enum "plain-text" {
+              value 2;
+              description
+                "Plain-text authentication.";
+            }
+            enum "md5" {
+              value 3;
+              description
+                "MD5 authentication.";
+            }
+          }
+          default "none";
+          description
+            "Specify the authentication mode.";
+        }
+        leaf md5-auth-length {
+          when "../mode = 'md5'";
+          type enumeration {
+            enum "16" {
+              value 16;
+              description
+                "RFC compatible.";
+            }
+            enum "20" {
+              value 20;
+              description
+                "Old ripd compatible.";
+            }
+          }
+          default "20";
+          description
+            "MD5 authentication data length.";
+        }
+      }
+      choice authentication-data {
+        description
+          "Choose whether to use a simple password or a key-chain.";
+        leaf authentication-password {
+          type string {
+            length "1..16";
+          }
+          description
+            "Authentication string.";
+        }
+        leaf authentication-key-chain {
+          type string;
+          description
+            "Key-chain name.";
+        }
+      }
+    }
+  }
+
+  /*
+   * RPCs
+   */
+  rpc clear-rip-route {
+    description
+      "Clears RIP routes from the IP routing table and routes
+       redistributed into the RIP protocol.";
+
+    input {
+      leaf vrf {
+        type string;
+        description
+          "VRF name identifying a specific RIP instance.
+           This leaf is optional for the rpc.
+           If it is specified, the rpc will clear all routes in the
+           specified RIP instance;
+           if it is not specified, the rpc will clear all routes in
+           all RIP instances.";
+      }
+    }
+  }
+
+  /*
+   * Notifications
+   */
+  notification authentication-type-failure {
+    description
+      "This notification is sent when the system
+       receives a PDU with the wrong authentication type
+       field.";
+    leaf interface-name {
+      type string;
+      description
+        "Describes the name of the RIP interface.";
+    }
+    leaf raw-pdu {
+      type binary;
+      description
+        "Received raw PDU.";
+    }
+  }
+  notification authentication-failure {
+    description
+      "This notification is sent when the system
+       receives a PDU with the wrong authentication
+       information.";
+    leaf interface-name {
+      type string;
+      description
+        "Describes the name of the RIP interface.";
+    }
+    leaf raw-pdu {
+      type binary;
+      description
+        "Received raw PDU.";
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-ripngd.yang frr/usr/share/yang/frr-ripngd.yang
--- frr-frr-8.1/usr/share/yang/frr-ripngd.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-ripngd.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,373 @@
+module frr-ripngd {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/ripngd";
+  prefix frr-ripngd;
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+  import ietf-yang-types {
+    prefix yang;
+  }
+  import frr-interface {
+    prefix frr-interface;
+  }
+  import frr-route-types {
+    prefix frr-route-types;
+  }
+
+  organization
+    "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines a model for managing FRR ripngd daemon.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-09-09 {
+    description
+      "Changed interface references to use
+      frr-interface:interface-ref typedef";
+  }
+  revision 2018-11-27 {
+    description
+      "Initial revision.";
+    reference
+      "RFC 2080: RIPng for IPv6.";
+  }
+
+  container ripngd {
+    /*
+     * Routing instance configuration.
+     */
+    list instance {
+      key "vrf";
+      description
+        "RIPng routing instance.";
+
+      leaf vrf {
+        type string;
+        description
+          "VRF name.";
+      }
+      leaf allow-ecmp {
+        type boolean;
+        default "false";
+        description
+          "Allow equal-cost multi-path.";
+      }
+      leaf default-information-originate {
+        type boolean;
+        default "false";
+        description
+          "Control distribution of default route.";
+      }
+      leaf default-metric {
+        type uint8 {
+          range "1..16";
+        }
+        default "1";
+        description
+          "Default metric of redistributed routes.";
+      }
+      leaf-list network {
+        type inet:ipv6-prefix;
+        description
+          "Enable RIPng on the specified IPv6 network.";
+      }
+      leaf-list interface {
+        type frr-interface:interface-ref;
+        description
+          "Enable RIPng on the specified interface.";
+      }
+      list offset-list {
+        key "interface direction";
+        description
+          "Offset-list to modify route metric.";
+        leaf interface {
+          type union {
+            type frr-interface:interface-ref;
+            type enumeration {
+              enum '*' {
+                description
+                  "Match all interfaces.";
+              }
+            }
+          }
+          description
+            "Interface to match. Use '*' to match all interfaces.";
+        }
+        leaf direction {
+          type enumeration {
+            enum in {
+              value 0;
+              description
+                "Incoming updates.";
+            }
+            enum out {
+              value 1;
+              description
+                "Outgoing updates.";
+            }
+          }
+          description
+            "Incoming or outgoing updates.";
+        }
+        leaf access-list {
+          type string;
+          mandatory true;
+          description
+            "Access-list name.";
+        }
+        leaf metric {
+          type uint8 {
+            range "0..16";
+          }
+          mandatory true;
+          description
+            "Route metric.";
+        }
+      }
+      leaf-list passive-interface {
+        type frr-interface:interface-ref;
+        description
+          "A list of interfaces where the sending of RIPng packets
+           is disabled.";
+      }
+      list redistribute {
+        key "protocol";
+        description
+          "Redistributes routes learned from other routing protocols.";
+        leaf protocol {
+          type frr-route-types:frr-route-types-v6;
+          description
+            "Routing protocol.";
+          must '. != "ripng"';
+        }
+        leaf route-map {
+          type string {
+            length "1..max";
+          }
+          description
+            "Applies the conditions of the specified route-map to
+             routes that are redistributed into the RIPng routing
+             instance.";
+        }
+        leaf metric {
+          type uint8 {
+            range "0..16";
+          }
+          description
+            "Metric used for the redistributed route. If a metric is
+             not specified, the metric configured with the
+             default-metric attribute in RIPng router configuration is
+             used. If the default-metric attribute has not been
+             configured, the default metric for redistributed routes
+             is 0.";
+        }
+      }
+      leaf-list static-route {
+        type inet:ipv6-prefix;
+        description
+          "RIPng static routes.";
+      }
+      leaf-list aggregate-address {
+        type inet:ipv6-prefix;
+        description
+          "RIPng aggregate route announcement.";
+      }
+      container timers {
+        description
+          "Settings of basic timers";
+        leaf flush-interval {
+          type uint16 {
+            range "1..65535";
+          }
+          units "seconds";
+          default "120";
+          description
+            "Interval before a route is flushed from the routing
+             table.";
+        }
+        leaf holddown-interval {
+          type uint16 {
+            range "1..65535";
+          }
+          units "seconds";
+          default "180";
+          description
+            "Interval before better routes are released.";
+        }
+        leaf update-interval {
+          type uint16 {
+            range "1..65535";
+          }
+          units "seconds";
+          default "30";
+          description
+            "Interval at which RIPng updates are sent.";
+        }
+      }
+
+      /*
+       * Operational data.
+       */
+      container state {
+        config false;
+        description
+          "Operational data.";
+
+        container neighbors {
+          description
+            "Neighbor information.";
+          list neighbor {
+            key "address";
+            description
+              "A RIPng neighbor.";
+            leaf address {
+              type inet:ipv6-address;
+              description
+                "IPv6 address that a RIPng neighbor is using as its
+                 source address.";
+            }
+            leaf last-update {
+              type yang:date-and-time;
+              description
+                "The time when the most recent RIPng update was
+                 received from this neighbor.";
+            }
+            leaf bad-packets-rcvd {
+              type yang:counter32;
+              description
+                "The number of RIPng invalid packets received from
+                 this neighbor which were subsequently discarded
+                 for any reason (e.g. a version 0 packet, or an
+                 unknown command type).";
+            }
+            leaf bad-routes-rcvd {
+              type yang:counter32;
+              description
+                "The number of routes received from this neighbor,
+                 in valid RIPng packets, which were ignored for any
+                 reason (e.g. unknown address family, or invalid
+                 metric).";
+            }
+          }
+        }
+        container routes {
+          description
+            "Route information.";
+          list route {
+            key "prefix";
+            description
+              "A RIPng IPv6 route.";
+            leaf prefix {
+              type inet:ipv6-prefix;
+              description
+                "IPv6 address and prefix length, in the format
+                 specified in RFC6991.";
+            }
+            leaf next-hop {
+              type inet:ipv6-address;
+              description
+                "Next hop IPv6 address.";
+            }
+            leaf interface {
+              type string;
+              description
+                "The interface that the route uses.";
+            }
+            leaf metric {
+              type uint8 {
+                range "0..16";
+              }
+              description
+                "Route metric.";
+            }
+          }
+        }
+      }
+    }
+  }
+
+  /*
+   * Per-interface configuration data
+   */
+  augment "/frr-interface:lib/frr-interface:interface" {
+    container ripng {
+      description
+        "RIPng interface parameters.";
+      leaf split-horizon {
+        type enumeration {
+          enum "disabled" {
+            value 0;
+            description
+              "Disables split-horizon processing.";
+          }
+          enum "simple" {
+            value 1;
+            description
+              "Enables simple split-horizon processing.";
+          }
+          enum "poison-reverse" {
+            value 2;
+            description
+              "Enables split-horizon processing with poison
+               reverse.";
+          }
+        }
+        default "simple";
+        description
+          "Controls RIPng split-horizon processing on the specified
+           interface.";
+      }
+    }
+  }
+
+  /*
+   * RPCs
+   */
+  rpc clear-ripng-route {
+    description
+      "Clears RIPng routes from the IPv6 routing table and routes
+       redistributed into the RIPng protocol.";
+
+    input {
+      leaf vrf {
+        type string;
+        description
+          "VRF name identifying a specific RIPng instance.
+           This leaf is optional for the rpc.
+           If it is specified, the rpc will clear all routes in the
+           specified RIPng instance;
+           if it is not specified, the rpc will clear all routes in
+           all RIPng instances.";
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-route-map.yang frr/usr/share/yang/frr-route-map.yang
--- frr-frr-8.1/usr/share/yang/frr-route-map.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-route-map.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,429 @@
+module frr-route-map {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/route-map";
+  prefix frr-route-map;
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+
+  import frr-filter {
+    prefix filter;
+  }
+
+  import frr-interface {
+    prefix frr-interface;
+  }
+
+  organization
+    "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines route map settings
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-07-01 {
+    description
+      "Initial revision";
+  }
+
+  /*
+   * Types.
+   */
+  typedef route-map-sequence {
+    type uint16 {
+      range "1..65535";
+    }
+    description
+      "Route map valid sequence numbers.";
+  }
+
+  typedef route-map-name {
+    type string;
+    description
+      "Route map name format.";
+  }
+
+  typedef route-map-ref {
+    type leafref {
+      path "/frr-route-map:lib/frr-route-map:route-map/frr-route-map:name";
+      require-instance false;
+    }
+    description
+      "Reference to a route-map.";
+  }
+
+  /*
+   * Operational data.
+   */
+  container lib {
+    list route-map {
+      key "name";
+      description
+        "Route map instance.";
+      leaf name {
+        type route-map-name;
+        description
+          "Route map instance name.";
+      }
+
+      list entry {
+        key "sequence";
+        description
+          "Route map entry.";
+        leaf sequence {
+          description
+            "Route map instance priority (low number means higher priority).";
+          type route-map-sequence;
+        }
+
+        leaf description {
+          description "Route map description.";
+          type string;
+        }
+
+        leaf action {
+          description
+            "Route map actions: permit (executes action), deny (quits evaluation).";
+          mandatory true;
+          type enumeration {
+            enum permit {
+              description
+                "Executes configured action and permits the prefix/route
+                 if the conditions matched. An alternative exit action can
+                 be configured to continue processing the route map list
+                 or jump to process another route map.";
+              value 0;
+            }
+            enum deny {
+              description
+                "If all conditions are met the prefix/route is denied and
+                 route map processing stops.";
+              value 1;
+            }
+          }
+        }
+
+        leaf call {
+          description
+            "Call another route map before calling `exit-policy`. If the
+             called route map returns deny then this route map will also
+             return deny.";
+          type route-map-name;
+        }
+
+        leaf exit-policy {
+          description "What do to after route map successful match, set and call.";
+          type enumeration {
+            enum permit-or-deny {
+              description "End route map evaluation and return.";
+              value 0;
+            }
+            enum next {
+              description
+                "Proceed evaluating next route map entry per sequence.";
+              value 1;
+            }
+            enum goto {
+              description
+                "Go to route map entry with the provided sequence number.";
+              value 2;
+            }
+          }
+          default "permit-or-deny";
+        }
+
+        leaf goto-value {
+          when "../exit-policy = 'goto'";
+          description
+            "Sequence number to jump (when using `goto` exit policy).";
+          mandatory true;
+          type route-map-sequence;
+        }
+
+        list match-condition {
+          key "condition";
+          description
+            "Route map match conditions.";
+          leaf condition {
+            description "Match condition.";
+            type enumeration {
+              enum interface {
+                description "Match interface.";
+                value 0;
+              }
+              enum ipv4-address-list {
+                description "Match an IPv4 access-list.";
+                value 1;
+              }
+              enum ipv4-prefix-list {
+                description "Match an IPv4 prefix-list.";
+                value 2;
+              }
+              enum ipv4-next-hop-list {
+                description "Match an IPv4 next-hop.";
+                value 3;
+              }
+              enum ipv4-next-hop-prefix-list {
+                description "Match an IPv4 next-hop prefix list.";
+                value 4;
+              }
+              enum ipv4-next-hop-type {
+                description "Match an IPv4 next-hop type.";
+                value 5;
+              }
+              enum ipv6-address-list {
+                description "Match an IPv6 access-list.";
+                value 6;
+              }
+              enum ipv6-prefix-list {
+                description "Match an IPv6 prefix-list.";
+                value 7;
+              }
+              enum ipv6-next-hop-type {
+                description "Match an IPv6 next-hop type.";
+                value 8;
+              }
+              enum metric {
+                description "Match a route metric.";
+                value 9;
+              }
+              enum tag {
+                description "Match a route tag.";
+                value 10;
+              }
+              /* zebra specific conditions. */
+              enum ipv4-prefix-length {
+                description "Match IPv4 prefix length.";
+                value 100;
+              }
+              enum ipv6-prefix-length {
+                description "Match IPv6 prefix length.";
+                value 101;
+              }
+              enum ipv4-next-hop-prefix-length {
+                description "Match next-hop prefix length.";
+                value 102;
+              }
+              enum source-protocol {
+                description "Match source protocol.";
+                value 103;
+              }
+              enum source-instance {
+                description "Match source protocol instance.";
+                value 104;
+              }
+            }
+          }
+
+          choice condition-value {
+            description
+              "Value to match (interpretation depends on condition type).";
+            mandatory true;
+            case interface {
+              when "./condition = 'interface'";
+              leaf interface {
+                type frr-interface:interface-ref;
+              }
+            }
+
+            case list-name {
+              when "./condition = 'ipv4-address-list' or
+                    ./condition = 'ipv4-prefix-list' or
+                    ./condition = 'ipv4-next-hop-list' or
+                    ./condition = 'ipv4-next-hop-prefix-list' or
+                    ./condition = 'ipv6-address-list' or
+                    ./condition = 'ipv6-prefix-list'";
+              leaf list-name {
+                type filter:access-list-name;
+              }
+            }
+
+            case ipv4-next-hop-type {
+              when "./condition = 'ipv4-next-hop-type'";
+              leaf ipv4-next-hop-type {
+                type enumeration {
+                  enum blackhole {
+                    value 0;
+                  }
+                }
+              }
+            }
+
+            case ipv6-next-hop-type {
+              when "./condition = 'ipv6-next-hop-type'";
+              leaf ipv6-next-hop-type {
+                type enumeration {
+                  enum blackhole {
+                    value 0;
+                  }
+                }
+              }
+            }
+
+            case metric {
+              when "./condition = 'metric'";
+              leaf metric {
+                type uint32 {
+                  range "1..4294967295";
+                }
+              }
+            }
+
+            case tag {
+              when "./condition = 'tag'";
+              leaf tag {
+                type uint32 {
+                  range "1..4294967295";
+                }
+              }
+            }
+          }
+        }
+
+        list set-action {
+          description "Route map set actions.";
+
+          key "action";
+
+          leaf action {
+            description "Action to do when the route map matches.";
+            type enumeration {
+              enum ipv4-next-hop {
+                description "Set IPv4 address of the next hop.";
+                value 0;
+              }
+              enum ipv6-next-hop {
+                description "Set IPv6 address of the next hop.";
+                value 1;
+              }
+              enum metric {
+                description "Set prefix/route metric.";
+                value 2;
+              }
+              enum tag {
+                description "Set tag.";
+                value 3;
+              }
+              /* zebra specific conditions. */
+              enum source {
+                description "Set source address for route.";
+                value 100;
+              }
+            }
+          }
+
+          choice action-value {
+            description
+              "Value to set (interpretation depends on action-type).";
+            case ipv4-address {
+              when "./action = 'ipv4-next-hop'";
+              leaf ipv4-address {
+                description "IPv4 address.";
+                type inet:ipv4-address;
+              }
+            }
+
+            case ipv6-address {
+              when "./action = 'ipv6-next-hop'";
+              leaf ipv6-address {
+                description "IPv6 address.";
+                type inet:ipv6-address;
+              }
+            }
+
+            case metric {
+              when "./action = 'metric'";
+              choice metric-value {
+                description "Metric to set or use.";
+                case value {
+                  leaf value {
+                    description "Use the following metric value.";
+                    type uint32 {
+                      range "0..4294967295";
+                    }
+                  }
+                }
+
+                case add-metric {
+                  leaf add-metric {
+                    description "Add value to metric.";
+                    type uint32 {
+                      range "0..4294967295";
+                    }
+                  }
+                }
+
+                case subtract-metric {
+                  leaf subtract-metric {
+                    description "Subtract value from metric.";
+                    type uint32 {
+                      range "0..4294967295";
+                    }
+                  }
+                }
+
+                case use-round-trip-time {
+                  leaf use-round-trip-time {
+                    description "Use the round trip time as metric.";
+                    type boolean;
+                  }
+                }
+
+                case add-round-trip-time {
+                  leaf add-round-trip-time {
+                    description "Add round trip time to metric.";
+                    type boolean;
+                  }
+                }
+
+                case subtract-round-trip-time {
+                  leaf subtract-round-trip-time {
+                    description "Subtract round trip time to metric.";
+                    type boolean;
+                  }
+                }
+              }
+            }
+
+            case tag {
+              when "./action = 'tag'";
+              leaf tag {
+                description "Tag value.";
+                type uint32 {
+                  range "0..4294967295";
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-route-types.yang frr/usr/share/yang/frr-route-types.yang
--- frr-frr-8.1/usr/share/yang/frr-route-types.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-route-types.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,142 @@
+module frr-route-types {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/route-types";
+  prefix frr-route-types;
+
+  organization
+    "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines typedefs for route types.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2018-03-28 {
+    description
+      "Initial revision.";
+  }
+
+  typedef frr-route-types-v4 {
+    type enumeration {
+      enum kernel {
+        value 1;
+      }
+      enum connected {
+        value 2;
+      }
+      enum static {
+        value 3;
+      }
+      enum rip {
+        value 4;
+      }
+      enum ospf {
+        value 6;
+      }
+      enum isis {
+        value 8;
+      }
+      enum bgp {
+        value 9;
+      }
+      enum eigrp {
+        value 11;
+      }
+      enum nhrp {
+        value 12;
+      }
+      enum table {
+        value 15;
+      }
+      enum vnc {
+        value 17;
+      }
+      enum babel {
+        value 22;
+      }
+      enum sharp {
+        value 23;
+      }
+      enum openfabric {
+        value 26;
+      }
+    }
+  }
+
+  typedef frr-route-types-v6 {
+    type enumeration {
+      enum kernel {
+        value 1;
+      }
+      enum connected {
+        value 2;
+      }
+      enum static {
+        value 3;
+      }
+      enum ripng {
+        value 5;
+      }
+      enum ospf6 {
+        value 7;
+      }
+      enum isis {
+        value 8;
+      }
+      enum bgp {
+        value 9;
+      }
+      enum nhrp {
+        value 12;
+      }
+      enum table {
+        value 15;
+      }
+      enum vnc {
+        value 17;
+      }
+      enum babel {
+        value 22;
+      }
+      enum sharp {
+        value 23;
+      }
+      enum openfabric {
+        value 26;
+      }
+    }
+  }
+
+  typedef frr-route-types {
+    description "Route types as enumerated in `lib/route_types.txt`";
+    type union {
+      type frr-route-types-v4;
+      type frr-route-types-v6;
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-routing.yang frr/usr/share/yang/frr-routing.yang
--- frr-frr-8.1/usr/share/yang/frr-routing.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-routing.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,259 @@
+module frr-routing {
+  yang-version "1.1";
+  namespace "http://frrouting.org/yang/routing";
+  prefix "rt";
+
+  import ietf-yang-types {
+    prefix "yang";
+  }
+
+  import frr-vrf {
+    prefix frr-vrf;
+  }
+
+  organization
+    "FRRouting";
+
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+
+  description
+    "This YANG module defines essential components for the management
+     of a routing subsystem.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-08-15 {
+    description
+      "Initial revision.";
+  }
+
+  /* Identities */
+
+  identity address-family {
+    description
+      "Base identity from which identities describing address
+       families are derived.";
+  }
+
+  identity ipv4 {
+    base address-family;
+    description
+      "This identity represents an IPv4 address family.";
+  }
+
+  identity ipv6 {
+    base address-family;
+    description
+      "This identity represents an IPv6 address family.";
+  }
+
+  identity afi-safi-type {
+    description
+      "Base identity type (AFI,SAFI) tuples for RIB";
+  }
+
+  identity ipv4-unicast {
+    base afi-safi-type;
+    description
+      "This identity represents the IPv4 unicast address family.";
+  }
+
+  identity ipv6-unicast {
+    base afi-safi-type;
+    description
+      "This identity represents the IPv6 unicast address family.";
+  }
+
+  identity ipv4-multicast {
+    base afi-safi-type;
+    description
+      "This identity represents the IPv4 multicast address family.";
+  }
+
+  identity ipv6-multicast {
+    base afi-safi-type;
+    description
+      "This identity represents the IPv6 multicast address family.";
+  }
+
+  identity ipv4-labeled-unicast {
+    base afi-safi-type;
+    description
+      "This identity represents the IPv4 labeled unicast address family.";
+  }
+
+
+  identity ipv6-labeled-unicast {
+    base afi-safi-type;
+    description
+      "This identity represents the IPv6 labeled unicast address family.";
+  }
+
+
+  identity l3vpn-ipv4-unicast {
+    base afi-safi-type;
+    description
+      "This identity represents the L3vpn IPv4 unicast address family.";
+  }
+
+
+  identity l3vpn-ipv6-unicast {
+    base afi-safi-type;
+    description
+      "This identity represents the L3vpn IPv6 unicast address family.";
+  }
+
+
+  identity l3vpn-ipv4-multicast {
+    base afi-safi-type;
+    description
+      "This identity represents the L3vpn IPv4 multicast address family.";
+  }
+
+
+  identity l3vpn-ipv6-multicast {
+    base afi-safi-type;
+    description
+      "This identity represents the L3vpn IPv6 multicast address family.";
+  }
+
+
+  identity l2vpn-vpls {
+    base afi-safi-type;
+    description
+      "This identity represents the L2vpn VPLS  address family.";
+  }
+
+
+  identity l2vpn-evpn {
+    base afi-safi-type;
+    description
+      "This identity represents the L2vpn EVPN address family.";
+  }
+
+
+  identity ipv4-flowspec {
+    base afi-safi-type;
+    description
+      "This identity represents the IPv4 flowspec address family.";
+  }
+
+
+  identity ipv6-flowspec {
+    base afi-safi-type;
+    description
+      "This identity represents the IPv6 flowspec address family.";
+  }
+
+
+  identity control-plane-protocol {
+    description
+      "Base identity from which control-plane protocol identities are
+       derived.";
+  }
+
+  identity routing-protocol {
+    base control-plane-protocol;
+    description
+      "Identity from which Layer 3 routing protocol identities are
+       derived.";
+  }
+
+  /* Type Definitions */
+
+  typedef administrative-distance {
+    type uint8 {
+      range "1..255";
+    }
+    description
+      "Admin distance associated with the route.";
+  }
+
+  /* Groupings */
+
+  grouping address-family {
+    description
+      "This grouping provides a leaf identifying an address
+       family.";
+    leaf address-family {
+      type identityref {
+        base address-family;
+      }
+      mandatory true;
+      description
+        "Address family.";
+    }
+  }
+
+  grouping router-id {
+    description
+      "This grouping provides a router ID.";
+    leaf router-id {
+      type yang:dotted-quad;
+      description
+        "A 32-bit number in the form of a dotted quad that is used by
+         some routing protocols identifying a router.";
+      reference
+        "RFC 2328: OSPF Version 2";
+    }
+  }
+
+  /* Data nodes */
+
+  container routing {
+    description
+      "Configuration parameters for the routing subsystem.";
+    container control-plane-protocols {
+      description
+        "Support for control-plane protocol instances.";
+      list control-plane-protocol {
+        key "type name vrf";
+        description
+          "Each entry contains a control-plane protocol instance.";
+        leaf type {
+          type identityref {
+            base control-plane-protocol;
+          }
+          description
+            "Type of the control-plane protocol";
+        }
+        leaf name {
+          type string;
+          description
+            "An arbitrary name of the control-plane protocol
+             instance.";
+        }
+        leaf vrf {
+          type string;
+          description
+            "vrf for control-plane protocol";
+        }
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-test-module.yang frr/usr/share/yang/frr-test-module.yang
--- frr-frr-8.1/usr/share/yang/frr-test-module.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-test-module.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,85 @@
+module frr-test-module {
+  yang-version 1.1;
+  namespace "urn:frr-test-module";
+  prefix frr-test-module;
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+  import ietf-yang-types {
+    prefix yang;
+  }
+  import frr-interface {
+    prefix frr-interface;
+  }
+
+  description
+    "FRRouting internal testing module.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2018-11-26 {
+    description
+      "Initial revision.";
+  }
+
+  container frr-test-module {
+    config false;
+    container vrfs {
+      list vrf {
+        key "name";
+
+        leaf name {
+          type string;
+        }
+        container interfaces {
+          leaf-list interface {
+            type string;
+          }
+        }
+        container routes {
+          list route {
+            leaf prefix {
+              type inet:ipv4-prefix;
+            }
+            leaf next-hop {
+              type inet:ipv4-address;
+            }
+            leaf interface {
+              type string;
+            }
+            leaf metric {
+              type uint8;
+            }
+            leaf active {
+              type empty;
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-vrf.yang frr/usr/share/yang/frr-vrf.yang
--- frr-frr-8.1/usr/share/yang/frr-vrf.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-vrf.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,85 @@
+module frr-vrf {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/vrf";
+  prefix frr-vrf;
+
+  organization
+    "Free Range Routing";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines a model for managing FRR VRF.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-12-06 {
+    description
+      "Initial revision.";
+  }
+
+  typedef vrf-ref {
+    type leafref {
+      path "/frr-vrf:lib/frr-vrf:vrf/frr-vrf:name";
+      require-instance false;
+    }
+    description
+      "Reference to a VRF";
+  }
+
+  container lib {
+    list vrf {
+      key "name";
+      description
+        "VRF.";
+      leaf name {
+        type string {
+          length "1..36";
+        }
+        description
+          "VRF name.";
+      }
+
+      container state {
+        config false;
+        leaf id {
+          type uint32 {
+            range "0..4294967295";
+          }
+          description
+            "VRF Id.";
+        }
+
+        leaf active {
+          type boolean;
+          default "false";
+          description
+            "VRF active in kernel.";
+        }
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/frr-zebra.yang frr/usr/share/yang/frr-zebra.yang
--- frr-frr-8.1/usr/share/yang/frr-zebra.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/frr-zebra.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,2239 @@
+module frr-zebra {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/zebra";
+  prefix frr-zebra;
+
+  import ietf-yang-types {
+    prefix yang;
+  }
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+
+  import frr-route-map {
+    prefix frr-route-map;
+  }
+
+  import frr-route-types {
+    prefix frr-route-types;
+  }
+
+  import ietf-routing-types {
+    prefix rt-types;
+  }
+
+  import frr-nexthop {
+    prefix frr-nh;
+  }
+
+  import frr-routing {
+    prefix frr-rt;
+  }
+
+  import frr-interface {
+    prefix frr-interface;
+  }
+
+  import frr-vrf {
+    prefix frr-vrf;
+  }
+
+  organization
+    "FRRouting";
+  contact
+    "FRR Users List: <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description
+    "This module defines a model for managing the FRR zebra daemon.
+
+     Copyright 2020 FRRouting
+
+     Redistribution and use in source and binary forms, with or without
+     modification, are permitted provided that the following conditions
+     are met:
+
+     1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+     2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+     \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";
+
+  revision 2019-06-01 {
+    description
+      "Initial revision.";
+  }
+
+  typedef unix-timestamp {
+    type uint32;
+    units "seconds";
+    description
+      "An absolute time in seconds since the unix epoch.";
+  }
+
+  identity zebra-interface-type {
+    description
+      "zebra interface type.";
+  }
+
+  identity zif-other {
+    base zebra-interface-type;
+    description
+      "Zebra interface type other.";
+  }
+
+  identity zif-bridge {
+    base zebra-interface-type;
+    description
+      "Zebra interface type bridge.";
+  }
+
+  identity zif-vlan {
+    base zebra-interface-type;
+    description
+      "Zebra interface type vlan.";
+  }
+
+  identity zif-vxlan {
+    base zebra-interface-type;
+    description
+      "Zebra interface type vxlan.";
+  }
+
+  identity zif-vrf {
+    base zebra-interface-type;
+    description
+      "Zebra interface type vrf.";
+  }
+
+  identity zif-veth {
+    base zebra-interface-type;
+    description
+      "Zebra interface type veth.";
+  }
+
+  identity zif-bond {
+    base zebra-interface-type;
+    description
+      "Zebra interface type bond.";
+  }
+
+  identity zif-bond-slave {
+    base zebra-interface-type;
+    description
+      "Zebra interface type bond slave.";
+  }
+
+  identity zif-macvlan {
+    base zebra-interface-type;
+    description
+      "Zebra interface type macvlan.";
+  }
+
+  /*
+   * Multicast RPF mode configurable type
+   */
+
+  typedef mcast-rpf-lookup-mode {
+    type enumeration {
+      enum "none" {
+        value 0;
+        description
+          "No mode set.";
+      }
+      enum "mrib-only" {
+        value 1;
+        description
+          "Lookup in unicast RIB only.";
+      }
+      enum "urib-only" {
+        value 2;
+        description
+          "Lookup in multicast RIB only.";
+      }
+      enum "mrib-then-urib" {
+        value 3;
+        description
+          "Try multicast RIB first, fall back to unicast RIB.";
+      }
+      enum "lower-distance" {
+        value 4;
+        description
+          "Lookup both unicast and mcast, use entry with lower distance.";
+      }
+      enum "longer-prefix" {
+        value 5;
+        description
+          "Lookup both unicast and mcast, use entry with longer prefix.";
+      }
+    }
+    description
+      "Multicast RPF lookup behavior";
+  }
+
+  // End of ip6-route
+  /*
+   * VxLAN Network Identifier type
+   */
+
+  typedef vni-id-type {
+    type uint32 {
+      range "0..16777215";
+    }
+    description
+      "A VxLAN network identifier value.";
+  }
+
+  typedef vni-vtep-flood-type {
+    type enumeration {
+      enum "head-end-repl" {
+        value 0;
+        description
+          "Head-end replication.";
+      }
+      enum "disabled" {
+        value 1;
+        description
+          "Flooding disabled.";
+      }
+      enum "pim-sm" {
+        value 2;
+        description
+          "Multicast PIM-SM.";
+      }
+    }
+  }
+
+  /*
+   * Common route data, shared by v4 and v6 routes.
+   */
+
+  grouping route-common {
+    description
+      "Common information about a route.";
+
+    leaf distance {
+      type uint8;
+      description
+        "Admin distance based on routing protocol.";
+    }
+
+    leaf metric {
+      type uint32;
+      description
+        "Route metric value.";
+    }
+
+    leaf tag {
+      type uint32 {
+        range "1..4294967295";
+      }
+      description
+        "Route tag value.";
+    }
+
+    leaf selected {
+      type empty;
+      description
+        "Route is the selected or preferred route for the prefix.";
+    }
+
+    leaf installed {
+      type empty;
+      description
+        "Route is installed in the FIB.";
+    }
+
+    leaf failed {
+      type empty;
+      description
+        "Route installation in FIB has failed.";
+    }
+
+    leaf queued {
+      type empty;
+      description
+        "Route has a pending FIB operation that has not completed.";
+    }
+
+    leaf internal-flags {
+      type int32;
+      description
+        "Internal flags for the route.";
+    }
+
+    leaf internal-status {
+      type int32;
+      description
+        "Internal status for the route.";
+    }
+
+    leaf uptime {
+      type yang:date-and-time;
+      description
+        "Uptime for the route.";
+    }
+
+    uses frr-nh:frr-nexthop-group-operational;
+  }
+
+  // End of route-common
+  /*
+   * IPv4 Route object.
+   */
+
+  grouping ip4-route {
+    description
+      "An IPv4 route.";
+    leaf prefix {
+      type inet:ipv4-prefix;
+      description
+        "IP address (in the form A.B.C.D) and prefix length,
+         separated by the slash (/) character. The range of
+         values for the prefix-length is 0 to 32.";
+    }
+
+    leaf protocol {
+      type frr-route-types:frr-route-types-v4;
+      description
+        "The protocol owning the route.";
+    }
+
+    uses route-common;
+  }
+
+  // End of ip4-route
+  /*
+   * IPv6 Route object.
+   */
+
+  grouping ip6-route {
+    description
+      "An IPv6 route.";
+    leaf prefix {
+      type inet:ipv6-prefix;
+      description
+        "The route's IPv6 prefix.";
+    }
+
+    leaf protocol {
+      type frr-route-types:frr-route-types-v6;
+      description
+        "The protocol owning the route.";
+    }
+
+    uses route-common;
+  }
+  // End of ip6-route
+
+  /*
+   * Information about EVPN VNIs
+   */
+
+  grouping vni-information {
+    choice type-choice {
+      case l2 {
+        leaf is-layer2 {
+          type empty;
+          description
+            "Information about an L2 VNI.";
+        }
+
+        leaf vtep-count {
+          type uint32;
+          description
+            "Number of VTEPs.";
+        }
+      }
+
+      case l3 {
+        leaf is-layer3 {
+          type empty;
+          description
+            "Information about an L3 VNI.";
+        }
+      }
+    }
+
+    leaf vni-id {
+      type vni-id-type;
+      description
+        "The VNI identifier.";
+    }
+
+    leaf vxlan-ifname {
+      type frr-interface:interface-ref;
+      description
+        "The VxLAN interface name.";
+    }
+
+    leaf mac-count {
+      type uint32;
+      description
+        "Number of valid MACs.";
+    }
+
+    leaf neighbor-count {
+      type uint32;
+      description
+        "Number of neighbors.";
+    }
+
+    leaf vrf {
+      type frr-vrf:vrf-ref;
+      description
+        "The tenant VRF.";
+    }
+
+    leaf local-vtep-addr {
+      type inet:ipv4-address;
+      description
+        "The local VTEP IP address.";
+    }
+  }
+
+  /*
+   * Detailed EVPN VNI information for L2.
+   */
+
+  grouping vni-l2-detail {
+    leaf if-index {
+      type uint32;
+      description
+        "The VxLAN ifindex.";
+    }
+
+    leaf advertise-gw {
+      type empty;
+      description
+        "The gateway MAC-IP is being advertised.";
+    }
+
+    leaf mcast-group {
+      type rt-types:ipv4-multicast-group-address;
+      description
+        "The VNI multicast group for BUM traffic.";
+    }
+
+    list remote-vtep-list {
+      leaf remote-vtep {
+        type inet:ipv4-address;
+        description
+          "The remote VTEP IP address.";
+      }
+
+      leaf vtep-flood {
+        type vni-vtep-flood-type;
+      }
+    }
+  }
+
+  /*
+   * Detailed EVPN VNI information for L3.
+   */
+
+  grouping vni-l3-detail {
+    leaf svi-interface {
+      type frr-interface:interface-ref;
+      description
+        "The SVI interface.";
+    }
+
+    leaf is-up {
+      type empty;
+      description
+        "The state is active.";
+    }
+
+    leaf prefix-only {
+      type empty;
+      description
+        "Prefix routes only";
+    }
+
+    leaf router-mac {
+      type yang:mac-address;
+      description
+        "The VNI Router MAC address.";
+    }
+
+    list vni-list {
+      description
+        "A list of the associated L2 VNIs.";
+      leaf vni-id {
+        type vni-id-type;
+        description
+          "An L2 VNI identifier.";
+      }
+    }
+  }
+
+  /*
+   * Debug options
+   */
+
+  grouping zebra-debugs {
+    leaf debug-events {
+      type boolean;
+      description
+        "Debug ZAPI events.";
+    }
+
+    leaf debug-zapi-send {
+      type boolean;
+      description
+        "Debug ZAPI messages sent.";
+    }
+
+    leaf debug-zapi-recv {
+      type boolean;
+      description
+        "Debug ZAPI messages received.";
+    }
+
+    leaf debug-zapi-detail {
+      type boolean;
+      description
+        "Debug ZAPI details.";
+    }
+
+    leaf debug-kernel {
+      type boolean;
+      description
+        "Debug kernel events.";
+    }
+
+    leaf debug-kernel-msg-send {
+      type boolean;
+      description
+        "Debug kernel messages sent.";
+    }
+
+    leaf debug-kernel-msg-recv {
+      type boolean;
+      description
+        "Debug kernel messages received.";
+    }
+
+    leaf debug-rib {
+      type boolean;
+      description
+        "Debug RIB processing.";
+    }
+
+    leaf debug-rib-detail {
+      type boolean;
+      description
+        "Debug RIB processing details.";
+    }
+
+    leaf debug-fpm {
+      type boolean;
+      description
+        "Debug the FIB Push Interface subsystem.";
+    }
+
+    leaf debug-nht {
+      type boolean;
+      description
+        "Debug Nexthop-tracking.";
+    }
+
+    leaf debug-nht-detail {
+      type boolean;
+      description
+        "Debug Nexthop-tracking details.";
+    }
+
+    leaf debug-mpls {
+      type boolean;
+      description
+        "Debug MPLS.";
+    }
+
+    leaf debug-vxlan {
+      type boolean;
+      description
+        "Debug VxLAN.";
+    }
+
+    leaf debug-pw {
+      type boolean;
+      description
+        "Debug pseudowires.";
+    }
+
+    leaf debug-dplane {
+      type boolean;
+      description
+        "Debug the dataplane subsystem.";
+    }
+
+    leaf debug-dplane-detail {
+      type boolean;
+      description
+        "Debug dataplane subsystem details.";
+    }
+
+    leaf debug-mlag {
+      type boolean;
+      description
+        "Debug MLAG.";
+    }
+  }
+
+  grouping ribs {
+    container ribs {
+      description
+        "RIBs supported by FRR.";
+      list rib {
+        key "afi-safi-name table-id";
+        leaf afi-safi-name {
+          type identityref {
+            base frr-rt:afi-safi-type;
+          }
+          description
+            "AFI, SAFI name.";
+        }
+
+        leaf table-id {
+          type uint32;
+          description
+            "Routing Table id (default id - 254).";
+        }
+
+        list route {
+          key "prefix";
+          config false;
+          leaf prefix {
+            type inet:ip-prefix;
+            description
+              "The route's prefix.";
+          }
+
+          list route-entry {
+            key "protocol";
+            leaf protocol {
+              type frr-route-types:frr-route-types;
+              description
+                "The protocol owning the route.";
+            }
+
+            leaf instance {
+              type uint16;
+              must "../protocol = \"ospf\"";
+              description
+                "Retrieve routes from a specific OSPF instance.";
+            }
+
+            uses route-common;
+          }
+        }
+      }
+    }
+  }
+
+  grouping vrf-vni-mapping {
+    description
+      "EVPN L3-VNI mapping corresponding to a VRF.";
+    leaf l3vni-id {
+      type vni-id-type;
+      description
+        "EVPN L3-VNI id to map to the VRF.";
+    }
+
+    leaf prefix-only {
+      type boolean;
+      default "false";
+      description
+        "EVPN asymmetric mode advertise prefix routes only.";
+    }
+  }
+
+  // End of zebra container
+  /*
+   * RPCs
+   */
+
+  rpc get-route-information {
+    description
+      "Retrieve IPv4 or IPv6 unicast routes.";
+    input {
+      choice ip-type {
+        case v4 {
+          leaf ipv4 {
+            type empty;
+            mandatory true;
+            description
+              "Retrieve IPv4 routes.";
+          }
+
+          leaf prefix-v4 {
+            type inet:ipv4-prefix;
+            description
+              "Retrieve routes matching a specific prefix.";
+          }
+
+          leaf supernets-only {
+            type empty;
+            description
+              "Skip routes that are subnets of classful prefix sizes.";
+          }
+        }
+
+        case v6 {
+          leaf ipv6 {
+            type empty;
+            mandatory true;
+            description
+              "Retrieve IPv6 routes.";
+          }
+
+          leaf prefix-v6 {
+            type inet:ipv6-prefix;
+            description
+              "Retrieve routes matching a specific prefix.";
+          }
+        }
+      }
+
+      choice vrf-choice {
+        case single {
+          leaf vrf {
+            type frr-vrf:vrf-ref;
+            description
+              "Retrieve routes in a non-default vrf.";
+          }
+        }
+
+        case all {
+          leaf all-vrfs {
+            type empty;
+            description
+              "Retrieve routes from all vrfs.";
+          }
+        }
+      }
+
+      leaf fib-routes {
+        type empty;
+        description
+          "Retrieve FIB routes rather than RIB routes.";
+      }
+
+      leaf table-id {
+        type uint32 {
+          range "1..4294967295";
+        }
+        description
+          "Routing table id to retrieve.";
+      }
+
+      leaf protocol {
+        type frr-route-types:frr-route-types-v4;
+        description
+          "Retrieve routes from a specific protocol daemon.";
+      }
+
+      leaf ospf-instance {
+        type uint32 {
+          range "1..65535";
+        }
+        must "../protocol = \"ospf\"";
+        description
+          "Retrieve routes from a specific OSPF instance.";
+      }
+
+      choice detail {
+        case det {
+          leaf include-detail {
+            type empty;
+            description
+              "Include detailed information.";
+          }
+        }
+
+        case summ {
+          leaf summary {
+            type empty;
+            description
+              "Include summary information only.";
+          }
+        }
+      }
+    }
+    // End of input
+    output {
+      choice route-list {
+        case v4 {
+          container routes-v4 {
+            description
+              "IPv4 route information.";
+            list route {
+              uses ip4-route;
+            }
+          }
+        }
+
+        case v6 {
+          container routes-v6 {
+            description
+              "IPv6 route information.";
+            list route {
+              uses ip6-route;
+            }
+          }
+        }
+      }
+    }
+    // End of output
+  }
+
+  // End get-route-information
+
+  rpc get-v6-mroute-info {
+    description
+      "Retrieve IPv6 multicast routes.";
+    input {
+      choice vrf-choice {
+        case single {
+          leaf vrf {
+            type frr-vrf:vrf-ref;
+            description
+              "Retrieve routes in a non-default vrf.";
+          }
+        }
+
+        case all {
+          leaf all-vrfs {
+            type empty;
+            description
+              "Retrieve routes from all vrfs.";
+          }
+        }
+      }
+    }
+
+    output {
+      container routes {
+        description
+          "IPv6 mcast route information.";
+        list route {
+          uses ip6-route;
+        }
+      }
+    }
+  }
+
+  // End get-v6-mroute-info
+
+  rpc get-vrf-info {
+    description
+      "Retrieve VRF information; the default VRF is elided.";
+    // Note: no input clause.
+    output {
+      list vrf-list {
+        leaf name {
+          type frr-vrf:vrf-ref;
+          description
+            "The VRF name";
+        }
+
+        leaf is-user-config {
+          type empty;
+          description
+            "The VRF was configured by an admin.";
+        }
+
+        leaf vrf-id {
+          type uint32;
+          description
+            "The VRF id.";
+        }
+
+        choice vrf-type {
+          case inactive {
+            leaf is-inactive {
+              type empty;
+              description
+                "The VRF is inactive.";
+            }
+          }
+
+          case netns {
+            leaf netns-name {
+              type string;
+              description
+                "The net namespace name associated with the VRF.";
+            }
+          }
+
+          case table {
+            leaf table-id {
+              type uint32;
+              description
+                "The table-id associated with the VRF.";
+            }
+          }
+        }
+      }
+    }
+  }
+
+  // End get-vrf-info
+
+  rpc get-vrf-vni-info {
+    description
+      "Retrieve mappings between EVPN VNI and VRF.";
+    // Note: no input clause.
+    output {
+      list vrf-vni-list {
+        leaf vrf-name {
+          type frr-vrf:vrf-ref;
+          description
+            "The VRF name.";
+        }
+
+        leaf vni-id {
+          type vni-id-type;
+          description
+            "The EVPN VNI.";
+        }
+
+        leaf vxlan-if-name {
+          type frr-interface:interface-ref;
+          description
+            "The VxLAN interface name.";
+        }
+
+        leaf svi-if-name {
+          type frr-interface:interface-ref;
+          description
+            "The SVI interface name.";
+        }
+
+        leaf router-mac-addr {
+          type yang:mac-address;
+          description
+            "Router MAC address.";
+        }
+
+        leaf is-up {
+          type empty;
+          description
+            "The state is active.";
+        }
+      }
+    }
+  }
+
+  // End get-vrf-vni-info
+
+  rpc get-evpn-info {
+    description
+      "Retrieve global information about EVPN.";
+    // Note: No input clause.
+    output {
+      leaf l2vni-count {
+        type uint32;
+        description
+          "Number of L2 VNIs.";
+      }
+
+      leaf l3vni-count {
+        type uint32;
+        description
+          "Number of L3 VNIs.";
+      }
+
+      leaf advertise-gateway {
+        type empty;
+        description
+          "Advertise the gateway MAC-IP.";
+      }
+
+      leaf advertise-svi {
+        type empty;
+        description
+          "Advertise SVI MAC-IP.";
+      }
+
+      leaf dup-detect {
+        type empty;
+        description
+          "Duplicate address detection is enabled.";
+      }
+
+      leaf dad-max-moves {
+        type uint32;
+        description
+          "Maximum moves allowed before address is considered duplicate.";
+      }
+
+      leaf dad-timeout {
+        type uint32;
+        units "seconds";
+        description
+          "Duplicate address detection timeout.";
+      }
+
+      leaf dad-freeze {
+        type empty;
+        description
+          "Duplicate address detection freeze enabled.";
+      }
+
+      choice dad-freeze-choice {
+        case freeze-permanent {
+          leaf dad-freeze-perm {
+            type empty;
+            description
+              "Duplicate address detection freeze is permanent.";
+          }
+        }
+
+        case freeze-time {
+          leaf dad-freeze-time {
+            type uint32;
+            units "seconds";
+            description
+              "Duplicate address detection freeze timer.";
+          }
+        }
+      }
+    }
+  }
+
+  // End get-evpn-info
+
+  rpc get-vni-info {
+    // If no vni is specified, retrieve global list.
+    input {
+      choice vni-choice {
+        default "all-vnis";
+        case all-vnis {
+          leaf all-vnis {
+            type empty;
+            description
+              "Retrieve information about all VNIs.";
+          }
+        }
+
+        case single-vni {
+          leaf vni-id {
+            type vni-id-type;
+            description
+              "Retrieve information about a specific EVPN VNI.";
+          }
+        }
+      }
+
+      leaf detailed-info {
+        type empty;
+        description
+          "Retrieve detailed information.";
+      }
+    }
+
+    output {
+      list vni-list {
+        description
+          "Information about EVPN VNI objects.";
+        uses vni-information;
+
+        choice detail-choice {
+          case l2 {
+            description
+              "Detailed L2 information.";
+            uses vni-l2-detail;
+          }
+
+          case l3 {
+            description
+              "Detailed L3 information.";
+            uses vni-l3-detail;
+          }
+        }
+      }
+    }
+  }
+
+  // End get-vni-info
+
+  rpc get-evpn-vni-rmac {
+    description
+      "Retrieve information about VxLAN VNI RMACs.";
+    input {
+      choice vni-choice {
+        default "all-vnis";
+        case all-vnis {
+          leaf all-vnis {
+            type empty;
+            description
+              "Retrieve information about all VNIs.";
+          }
+        }
+
+        case single-vni {
+          leaf vni-id {
+            type vni-id-type;
+            description
+              "Retrieve information about a specific EVPN VNI.";
+          }
+
+          leaf vni-rmac {
+            type yang:mac-address;
+            description
+              "A single RMAC address.";
+          }
+        }
+      }
+    }
+
+    output {
+      list rmac-info-list {
+        leaf rmac {
+          type yang:mac-address;
+          description
+            "The RMAC address.";
+        }
+
+        leaf remote-vtep {
+          type inet:ipv4-address;
+          description
+            "The remote VTEP IP address.";
+        }
+
+        leaf refcount {
+          type uint32;
+          description
+            "The refcount of the RMAC.";
+        }
+
+        list prefix-list {
+          leaf prefix-item {
+            type inet:ip-prefix;
+            description
+              "IP prefixes associated with the RMAC.";
+          }
+        }
+      }
+    }
+  }
+
+  // End get-evpn-vni-rmac
+
+  rpc get-evpn-vni-nexthops {
+    description
+      "Retrieve information about EVPN nexthops.";
+    input {
+      choice vni-choice {
+        default "all-vnis";
+        case all-vnis {
+          leaf all-vnis {
+            type empty;
+            description
+              "Retrieve information about all VNIs.";
+          }
+        }
+
+        case single-vni {
+          leaf vni-id {
+            type vni-id-type;
+            description
+              "Retrieve information about a specific EVPN VNI.";
+          }
+
+          leaf vni-ipaddr {
+            type inet:ip-address;
+            description
+              "A single host IP address (v4 or v6).";
+          }
+        }
+      }
+    }
+
+    output {
+      list nh-info-list {
+        leaf ip-addr {
+          type inet:ip-address;
+          description
+            "The nexthop IP address.";
+        }
+
+        leaf mac-addr {
+          type yang:mac-address;
+          description
+            "The nexthop MAC address.";
+        }
+
+        leaf refcount {
+          type uint32;
+          description
+            "The refcount of the RMAC.";
+        }
+
+        list prefix-list {
+          leaf prefix-item {
+            type inet:ip-prefix;
+            description
+              "IP prefixes associated with the RMAC.";
+          }
+        }
+      }
+    }
+  }
+
+  // End get-evpn-vni-vteps
+
+  rpc clear-evpn-dup-addr {
+    description
+      "Clear duplicate address detection state for one or all VNIs.";
+    input {
+      choice clear-dup-choice {
+        case all-case {
+          leaf all-vnis {
+            type empty;
+            description
+              "Clear all VNIs.";
+          }
+        }
+
+        case single-case {
+          leaf vni-id {
+            type vni-id-type;
+            description
+              "Clear state for a single EVPN VNI.";
+          }
+
+          choice ip-mac-choice {
+            description
+              "Clear state for a specific MAC or IP address.";
+            case ip-case {
+              leaf vni-ipaddr {
+                type inet:ip-address;
+                description
+                  "A specific IP address (v4 or v6).";
+              }
+            }
+
+            case mac-case {
+              leaf mac-addr {
+                type yang:mac-address;
+                description
+                  "A specific MAC address.";
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  // End clear-evpn-dup-addr
+
+  rpc get-evpn-macs {
+    description
+      "Retrieve information about EVPN MAC addresses.";
+    input {
+      choice all-choice {
+        default "all-vni";
+        case all-vni {
+          leaf all-vnis {
+            type empty;
+            description
+              "Retrieve information for all VNIs.";
+          }
+
+          choice all-choices {
+            case detail-case {
+              leaf all-detail {
+                type empty;
+                description
+                  "Include detailed results.";
+              }
+            }
+
+            case vtep-case {
+              leaf all-vtep-addr {
+                type inet:ipv4-address;
+                description
+                  "A single VTEP address.";
+              }
+            }
+
+            case dup-case {
+              leaf all-dup {
+                type empty;
+                description
+                  "Show duplicate addresses.";
+              }
+            }
+          }
+        }
+
+        case single-vni {
+          leaf vni-id {
+            type vni-id-type;
+            description
+              "Retrieve information for a single VNI.";
+          }
+
+          choice single-choices {
+            case detail-case {
+              leaf single-detail {
+                type empty;
+                description
+                  "Include detailed results.";
+              }
+            }
+
+            case mac-case {
+              leaf single-mac {
+                type yang:mac-address;
+                description
+                  "A specific MAC address.";
+              }
+            }
+
+            case vtep-case {
+              leaf single-vtep {
+                type inet:ipv4-address;
+                description
+                  "A single VTEP address.";
+              }
+            }
+
+            case dup-case {
+              leaf single-dup {
+                type empty;
+                description
+                  "Show duplicate addresses.";
+              }
+            }
+          }
+        }
+      }
+    }
+    // End of input section
+    output {
+      list mac-list {
+        leaf mac-addr {
+          type yang:mac-address;
+          description
+            "The MAC address.";
+        }
+
+        leaf vni {
+          type vni-id-type;
+          description
+            "The VNI value.";
+        }
+
+        leaf local-sequence {
+          type uint32;
+          description
+            "Local sequence number.";
+        }
+
+        leaf remote-sequence {
+          type uint32;
+          description
+            "Remote sequence number.";
+        }
+
+        leaf dad-count {
+          type uint32;
+          description
+            "Duplicate detection counter.";
+        }
+
+        leaf is-duplicate {
+          type empty;
+          description
+            "Duplicate MAC detected.";
+        }
+
+        leaf dup-detect-time {
+          type unix-timestamp;
+          description
+            "If a duplicate, the detection time.";
+        }
+
+        container dup-detect-started {
+          leaf dup-detect-start {
+            type unix-timestamp;
+            description
+              "Duplicate detection process start time.";
+          }
+
+          leaf dup-count {
+            type uint32;
+            description
+              "Duplicate detection count.";
+          }
+        }
+
+        leaf is-auto {
+          type empty;
+          description
+            "This is an Auto MAC.";
+        }
+
+        leaf is-sticky {
+          type empty;
+          description
+            "This is a sticky MAC.";
+        }
+
+        leaf is-default-gw {
+          type empty;
+          description
+            "This is a default-gateway MAC.";
+        }
+
+        leaf is-remote-gw {
+          type empty;
+          description
+            "This is a remote-gateway MAC.";
+        }
+
+        list neighbor-list {
+          leaf neighbor-addr {
+            type inet:ip-address;
+            description
+              "Neighbor address.";
+          }
+
+          leaf is-active {
+            type empty;
+            description
+              "Neighbor is active.";
+          }
+        }
+
+        leaf mac-count {
+          type uint32;
+          description
+            "Number of MACs (local and remote).";
+        }
+
+        choice local-rem-choice {
+          case local-case {
+            leaf intf {
+              type frr-interface:interface-ref;
+              description
+                "The local interface name.";
+            }
+
+            leaf vlan {
+              type uint32;
+              description
+                "A VLAN id.";
+            }
+          }
+
+          case remote-case {
+            leaf vtep-addr {
+              type inet:ipv4-address;
+              description
+                "The remote VTEP IP address.";
+            }
+          }
+        }
+      }
+    }
+  }
+
+  // End get-evpn-macs
+
+  rpc get-evpn-arp-cache {
+    description
+      "Retrieve information about EVPN neighbor cache entries.";
+    input {
+      choice all-choice {
+        default "all-vni";
+        case all-vni {
+          leaf all-vnis {
+            type empty;
+            description
+              "Retrieve information for all VNIs.";
+          }
+
+          choice all-choices {
+            case detail-case {
+              leaf all-detail {
+                type empty;
+                description
+                  "Include detailed results.";
+              }
+            }
+
+            case dup-case {
+              leaf all-dup {
+                type empty;
+                description
+                  "Show duplicates.";
+              }
+            }
+          }
+        }
+
+        case single-vni {
+          leaf vni-id {
+            type vni-id-type;
+            description
+              "Retrieve information for a single VNI.";
+          }
+
+          choice single-choices {
+            case vtep-case {
+              leaf single-vtep {
+                type inet:ipv4-address;
+                description
+                  "A single VTEP address.";
+              }
+            }
+
+            case neighbor-case {
+              leaf neighbor-addr {
+                type inet:ip-address;
+                description
+                  "A single neighbor address.";
+              }
+            }
+
+            case dup-case {
+              leaf single-dup {
+                type empty;
+                description
+                  "Show duplicates.";
+              }
+            }
+          }
+        }
+      }
+    }
+    // End input section
+    output {
+      list vni-list {
+        container vni-container {
+          description
+            "Information for one VNI.";
+          leaf vni-id {
+            type vni-id-type;
+            description
+              "The VNI id.";
+          }
+
+          list neigh-list {
+            description
+              "Information about a VNI's neighbor cache.";
+            leaf mac-addr {
+              type yang:mac-address;
+              description
+                "A neighbor MAC address.";
+            }
+
+            leaf ip-addr {
+              type inet:ip-address;
+              description
+                "A neighbor IP address.";
+            }
+
+            leaf state-active {
+              type empty;
+              description
+                "Indicates whether the entry is active.";
+            }
+
+            choice local-remote-choice {
+              case local-case {
+                leaf is-local {
+                  type empty;
+                  description
+                    "The entry is local.";
+                }
+              }
+
+              case remote-case {
+                leaf is-remote {
+                  type empty;
+                  description
+                    "The entry is remote.";
+                }
+              }
+            }
+
+            leaf is-dup {
+              type empty;
+              description
+                "The entry is a detected duplicate.";
+            }
+
+            leaf is-default-gw {
+              type empty;
+              description
+                "The entry is a default gateway.";
+            }
+
+            leaf is-router {
+              type empty;
+              description
+                "The entry is a router.";
+            }
+
+            leaf local-sequence {
+              type uint32;
+              description
+                "The local sequence number.";
+            }
+
+            leaf remote-sequence {
+              type uint32;
+              description
+                "The remote sequence number.";
+            }
+
+            leaf remote-vtep {
+              type inet:ipv4-address;
+              description
+                "The remote VTEP address.";
+            }
+          }
+        }
+      }
+    }
+  }
+
+  // End get-evpn-arp-cache
+
+  rpc get-pbr-ipset {
+    input {
+      leaf name {
+        type string {
+          length "1..32";
+        }
+        description
+          "An optional specific IPset name.";
+      }
+    }
+
+    output {
+      list ipset-list {
+        leaf name {
+          type string {
+            length "1..32";
+          }
+          description
+            "The IPset name.";
+        }
+
+        leaf ipset-type {
+          type enumeration {
+            enum "net-net" {
+              value 1;
+              description
+                "";
+            }
+            enum "net-port-net" {
+              value 2;
+              description
+                "";
+            }
+            enum "net-port" {
+              value 3;
+              description
+                "";
+            }
+            enum "net" {
+              value 4;
+              description
+                "";
+            }
+          }
+        }
+
+        leaf src-prefix {
+          type inet:ip-prefix;
+          description
+            "";
+        }
+
+        leaf dest-prefix {
+          type inet:ip-prefix;
+          description
+            "";
+        }
+
+        leaf src-port {
+          type inet:port-number;
+          description
+            "";
+        }
+
+        leaf dest-port {
+          type inet:port-number;
+          description
+            "";
+        }
+
+        choice proto-choice {
+          description
+            "Filter UDP/TCP only, or a specific protocol number.";
+          case udp-tcp-case {
+            leaf is-udp-tcp {
+              type empty;
+              description
+                "Filter TCP/UDP ports only.";
+            }
+          }
+
+          case proto-case {
+            leaf proto {
+              type uint32;
+              description
+                "Filter a specific protocol number.";
+            }
+          }
+        }
+
+        container icmp-info {
+          description
+            "Additional information for ICMP filters.";
+          leaf type-min {
+            type uint8;
+            description
+              "";
+          }
+
+          leaf type-max {
+            type uint8;
+            description
+              "";
+          }
+
+          leaf code-min {
+            type uint8;
+            description
+              "";
+          }
+
+          leaf code-max {
+            type uint8;
+            description
+              "";
+          }
+        }
+
+        container ipset-stats {
+          leaf is-unique {
+            type empty;
+            description
+              "";
+          }
+
+          leaf packet-counter {
+            type uint64;
+            description
+              "";
+          }
+
+          leaf bytes-counter {
+            type uint64;
+            description
+              "";
+          }
+        }
+      }
+    }
+  }
+
+  // End get-pbr-ipset
+
+  rpc get-pbr-iptable {
+    input {
+      leaf name {
+        type string {
+          length "1..32";
+        }
+        description
+          "An optional single IPtable name.";
+      }
+    }
+
+    output {
+      list iptable-list {
+        leaf name {
+          type string {
+            length "1..32";
+          }
+          description
+            "The IPtable name.";
+        }
+
+        leaf unique-val {
+          type uint32;
+          description
+            "";
+        }
+
+        choice action-choice {
+          description
+            "The table action.";
+          case drop-case {
+            leaf action-drop {
+              type empty;
+              description
+                "";
+            }
+          }
+
+          case redirect-case {
+            leaf action-redirect {
+              type empty;
+              description
+                "";
+            }
+          }
+        }
+
+        leaf min-packet {
+          type uint32;
+          description
+            "";
+        }
+
+        leaf max-packet {
+          type uint32;
+          description
+            "";
+        }
+
+        leaf lookup-src-port {
+          type empty;
+          description
+            "";
+        }
+
+        leaf lookup-dst-port {
+          type empty;
+          description
+            "";
+        }
+
+        leaf tcp-flags {
+          type uint16;
+          description
+            "";
+        }
+
+        leaf tcp-flags-mask {
+          type uint16;
+          description
+            "";
+        }
+
+        leaf protocol-val {
+          type uint32;
+          description
+            "An IP protocol number.";
+        }
+
+        container dscp-info {
+          leaf dscp-value {
+            type uint32;
+            description
+              "A DSCP value to match.";
+          }
+
+          leaf invert-match {
+            type empty;
+            description
+              "If set, exclude the specified value";
+          }
+        }
+
+        container fragment-info {
+          leaf fragment-val {
+            type uint32;
+            description
+              "An IP fragment value.";
+          }
+
+          leaf invert-match {
+            type empty;
+            description
+              "If set, exclude the specified value.";
+          }
+        }
+
+        container iptable-stats {
+          leaf packet-counter {
+            type uint64;
+            description
+              "";
+          }
+
+          leaf bytes-counter {
+            type uint64;
+            description
+              "";
+          }
+        }
+
+        container rule-info {
+          description
+            "Information about a rule, for redirect tables.";
+          leaf table-id {
+            type uint32;
+            description
+              "The rule table id.";
+          }
+
+          leaf table-fwmark {
+            type uint32;
+            description
+              "The firewall mark for the rule.";
+          }
+        }
+      }
+    }
+  }
+
+  // End get-pbr-iptable
+  /*
+   * Handy 'all-at-once' api to retrieve debugs
+   */
+
+  rpc get-debugs {
+    output {
+      uses zebra-debugs;
+    }
+  }
+
+  // End get-debugs
+
+  augment "/frr-interface:lib/frr-interface:interface" {
+    description
+      "Extends interface model with Zebra-related parameters.";
+    container zebra {
+      list ip-addrs {
+        key "address-family ip-prefix";
+        description
+          "IP prefixes for an interface.";
+        uses frr-rt:address-family {
+          description
+            "Address family of the RIB.";
+        }
+
+        leaf ip-prefix {
+          type inet:ip-prefix;
+          description
+            "IP address prefix.";
+        }
+
+        leaf label {
+          type string;
+          description
+            "Optional string label for the address.";
+        }
+
+        leaf ip4-peer {
+          when "derived-from-or-self(../address-family, 'ipv4')";
+          type inet:ipv4-prefix;
+          description
+            "Peer prefix, for peer-to-peer interfaces.";
+        }
+      }
+
+      leaf multicast {
+        type boolean;
+        description
+          "Multicast flag for the interface.";
+      }
+
+      leaf link-detect {
+        type boolean;
+        description
+          "Link-detection for the interface.";
+      }
+
+      leaf shutdown {
+        type boolean;
+        description
+          "Interface admin status.";
+      }
+
+      leaf bandwidth {
+        type uint32 {
+          range "1..100000";
+        }
+        description
+          "Link bandwidth informational parameter, in megabits.";
+      }
+      // TODO -- link-params for (experimental/partial TE use in IGP extensions)
+      container state {
+        config false;
+        description
+          "Operational data.";
+        leaf up-count {
+          type uint16;
+          description
+            "Interface Up count.";
+        }
+
+        leaf down-count {
+          type uint16;
+          description
+            "Interface Down count.";
+        }
+
+        leaf zif-type {
+          type identityref {
+            base zebra-interface-type;
+          }
+          description
+            "zebra interface type.";
+        }
+
+        leaf ptm-status {
+          type string;
+          default "disabled";
+          description
+            "Interface PTM status.";
+        }
+
+        leaf vlan-id {
+          type uint16 {
+            range "1..4094";
+          }
+          description
+            "A VLAN id.";
+        }
+
+        leaf vni-id {
+          type vni-id-type;
+        }
+
+        leaf remote-vtep {
+          type inet:ipv4-address;
+          description
+            "The remote VTEP IP address.";
+        }
+
+        leaf mcast-group {
+          type rt-types:ipv4-multicast-group-address;
+          description
+            "The VNI multicast group for BUM traffic.";
+        }
+      }
+    }
+  }
+
+  augment "/frr-vrf:lib/frr-vrf:vrf" {
+    description
+      "Extends VRF model with Zebra-related parameters.";
+    container zebra {
+      description
+        "Zebra's vrf specific configuration and operational model.";
+      uses ribs;
+
+      uses vrf-vni-mapping;
+    }
+  }
+
+  augment "/frr-vrf:lib/frr-vrf:vrf/frr-zebra:zebra/ribs/rib/route/route-entry/nexthop-group/nexthop" {
+    uses frr-nh:frr-nexthop-operational;
+  }
+
+  /*
+   * Main zebra container
+   */
+
+  container zebra {
+    description
+      "Data model for the Zebra daemon.";
+    leaf mcast-rpf-lookup {
+      type frr-zebra:mcast-rpf-lookup-mode;
+      default "mrib-then-urib";
+      description
+        "Multicast RPF lookup behavior.";
+    }
+    leaf ip-forwarding {
+      type boolean;
+      description
+        "IP forwarding status.";
+    }
+    leaf ipv6-forwarding {
+      type enumeration {
+        enum unknown {
+          value -1;
+          description
+            "Unknown state.";
+        }
+        enum off {
+          value 0;
+          description
+            "IPv6 forwarding disabled.";
+        }
+        enum on {
+          value 1;
+          description
+            "IPv6 forwarding enabled.";
+        }
+      }
+      description
+        "IPv6 forwarding status.";
+    }
+    leaf workqueue-hold-timer {
+      type uint32 {
+        range "0..10000";
+      }
+      units "milliseconds";
+      default "10";
+      description
+        "Work-queue processing hold timer, in milliseconds.";
+    }
+    leaf zapi-packets {
+      type uint32 {
+        range "1..10000";
+      }
+      default "1000";
+      description
+        "Number of ZAPI packets to process before relinquishing
+         the main thread.";
+    }
+    container import-kernel-table {
+      description
+        "Parameters to use when importing IPv4 routes from a non-main kernel
+         routing table.";
+      leaf table-id {
+        type uint32 {
+          range "1..252";
+        }
+        description
+          "The kernel table id.";
+      }
+      leaf distance {
+        type uint32 {
+          range "1..255";
+        }
+        default "15";
+        description
+          "The admin distance to use for imported routes.";
+      }
+      leaf route-map {
+        type string;
+        description
+          "A route-map to filter imported routes.";
+      }
+    }
+    leaf allow-external-route-update {
+      type empty;
+      description
+        "Allow FRR-controlled routes to be overwritten by external processes";
+    }
+    leaf dplane-queue-limit {
+      type uint32 {
+        range "0..10000";
+      }
+      default "200";
+      description
+        "Limit on the number of updates queued to the dataplane subsystem.";
+    }
+    /*
+     * Debug options
+     */
+    container debugs {
+      uses zebra-debugs;
+    }
+    /* End of debugs */
+    /*
+     * End of configuration attributes
+     */
+    /*
+     * Operational data.
+     */
+    container state {
+      config false;
+      description
+        "Operational data.";
+    }
+    // End of operational / state container
+  }
+
+  // End interface model augmentation
+
+  augment "/frr-route-map:lib"
+    + "/frr-route-map:route-map"
+    + "/frr-route-map:entry"
+    + "/frr-route-map:match-condition"
+    + "/frr-route-map:condition-value" {
+    case ipv4-prefix-length {
+      when "./condition = 'ipv4-prefix-length' or
+            ./condition = 'ipv4-next-hop-prefix-length'";
+      leaf ipv4-prefix-length {
+        type uint8 {
+          range "0..32";
+        }
+      }
+    }
+    case ipv6-prefix-length {
+      when "./condition = 'ipv6-prefix-length'";
+      leaf ipv6-prefix-length {
+        type uint8 {
+          range "0..128";
+        }
+      }
+    }
+    case source-protocol {
+      when "./condition = 'source-protocol'";
+      leaf source-protocol {
+        type frr-route-types:frr-route-types;
+      }
+    }
+    case source-instance {
+      when "./condition = 'source-instance'";
+      leaf source-instance {
+        type uint8 {
+          range "0..255";
+        }
+      }
+    }
+  }
+
+  augment "/frr-route-map:lib"
+          + "/frr-route-map:route-map"
+          + "/frr-route-map:entry"
+          + "/frr-route-map:set-action"
+          + "/frr-route-map:action-value" {
+    case source-v4 {
+      when "./action = 'source'";
+      leaf source-v4 {
+        description "IPv4 address";
+        type inet:ipv4-address;
+      }
+    }
+    case source-v6 {
+      when "./action = 'source'";
+      leaf source-v6 {
+        description "IPv6 address";
+        type inet:ipv6-address;
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/ietf-interfaces.yang frr/usr/share/yang/ietf-interfaces.yang
--- frr-frr-8.1/usr/share/yang/ietf-interfaces.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/ietf-interfaces.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,1123 @@
+module ietf-interfaces {
+  yang-version 1.1;
+  namespace "urn:ietf:params:xml:ns:yang:ietf-interfaces";
+  prefix if;
+
+  import ietf-yang-types {
+    prefix yang;
+  }
+
+  organization
+    "IETF NETMOD (Network Modeling) Working Group";
+
+  contact
+    "WG Web:   <https://datatracker.ietf.org/wg/netmod/>
+     WG List:  <mailto:netmod@ietf.org>
+
+     Editor:   Martin Bjorklund
+               <mailto:mbj@tail-f.com>";
+
+  description
+    "This module contains a collection of YANG definitions for
+     managing network interfaces.
+
+     Copyright (c) 2018 IETF Trust and the persons identified as
+     authors of the code.  All rights reserved.
+
+     Redistribution and use in source and binary forms, with or
+     without modification, is permitted pursuant to, and subject
+     to the license terms contained in, the Simplified BSD License
+     set forth in Section 4.c of the IETF Trust's Legal Provisions
+     Relating to IETF Documents
+     (https://trustee.ietf.org/license-info).
+
+     This version of this YANG module is part of RFC 8343; see
+     the RFC itself for full legal notices.";
+
+  revision 2018-02-20 {
+    description
+      "Updated to support NMDA.";
+    reference
+      "RFC 8343: A YANG Data Model for Interface Management";
+  }
+
+  revision 2014-05-08 {
+    description
+      "Initial revision.";
+    reference
+      "RFC 7223: A YANG Data Model for Interface Management";
+  }
+
+  /*
+   * Typedefs
+   */
+
+  typedef interface-ref {
+    type leafref {
+      path "/if:interfaces/if:interface/if:name";
+    }
+    description
+      "This type is used by data models that need to reference
+       interfaces.";
+  }
+
+  /*
+   * Identities
+   */
+
+  identity interface-type {
+    description
+      "Base identity from which specific interface types are
+       derived.";
+  }
+
+  /*
+   * Features
+   */
+
+  feature arbitrary-names {
+    description
+      "This feature indicates that the device allows user-controlled
+       interfaces to be named arbitrarily.";
+  }
+  feature pre-provisioning {
+    description
+      "This feature indicates that the device supports
+       pre-provisioning of interface configuration, i.e., it is
+       possible to configure an interface whose physical interface
+       hardware is not present on the device.";
+  }
+  feature if-mib {
+    description
+      "This feature indicates that the device implements
+       the IF-MIB.";
+    reference
+      "RFC 2863: The Interfaces Group MIB";
+  }
+
+  /*
+   * Data nodes
+   */
+
+  container interfaces {
+    description
+      "Interface parameters.";
+
+    list interface {
+      key "name";
+
+      description
+        "The list of interfaces on the device.
+
+         The status of an interface is available in this list in the
+         operational state.  If the configuration of a
+         system-controlled interface cannot be used by the system
+         (e.g., the interface hardware present does not match the
+         interface type), then the configuration is not applied to
+         the system-controlled interface shown in the operational
+         state.  If the configuration of a user-controlled interface
+         cannot be used by the system, the configured interface is
+         not instantiated in the operational state.
+
+         System-controlled interfaces created by the system are
+         always present in this list in the operational state,
+         whether or not they are configured.";
+
+     leaf name {
+        type string;
+        description
+          "The name of the interface.
+
+           A device MAY restrict the allowed values for this leaf,
+           possibly depending on the type of the interface.
+           For system-controlled interfaces, this leaf is the
+           device-specific name of the interface.
+
+           If a client tries to create configuration for a
+           system-controlled interface that is not present in the
+           operational state, the server MAY reject the request if
+           the implementation does not support pre-provisioning of
+           interfaces or if the name refers to an interface that can
+           never exist in the system.  A Network Configuration
+           Protocol (NETCONF) server MUST reply with an rpc-error
+           with the error-tag 'invalid-value' in this case.
+
+           If the device supports pre-provisioning of interface
+           configuration, the 'pre-provisioning' feature is
+           advertised.
+
+           If the device allows arbitrarily named user-controlled
+           interfaces, the 'arbitrary-names' feature is advertised.
+
+           When a configured user-controlled interface is created by
+           the system, it is instantiated with the same name in the
+           operational state.
+
+           A server implementation MAY map this leaf to the ifName
+           MIB object.  Such an implementation needs to use some
+           mechanism to handle the differences in size and characters
+           allowed between this leaf and ifName.  The definition of
+           such a mechanism is outside the scope of this document.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifName";
+      }
+
+      leaf description {
+        type string;
+        description
+          "A textual description of the interface.
+
+           A server implementation MAY map this leaf to the ifAlias
+           MIB object.  Such an implementation needs to use some
+           mechanism to handle the differences in size and characters
+           allowed between this leaf and ifAlias.  The definition of
+           such a mechanism is outside the scope of this document.
+
+           Since ifAlias is defined to be stored in non-volatile
+           storage, the MIB implementation MUST map ifAlias to the
+           value of 'description' in the persistently stored
+           configuration.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifAlias";
+      }
+
+      leaf type {
+        type identityref {
+          base interface-type;
+        }
+        mandatory true;
+        description
+          "The type of the interface.
+
+           When an interface entry is created, a server MAY
+           initialize the type leaf with a valid value, e.g., if it
+           is possible to derive the type from the name of the
+           interface.
+
+           If a client tries to set the type of an interface to a
+           value that can never be used by the system, e.g., if the
+           type is not supported or if the type does not match the
+           name of the interface, the server MUST reject the request.
+           A NETCONF server MUST reply with an rpc-error with the
+           error-tag 'invalid-value' in this case.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifType";
+      }
+
+      leaf enabled {
+        type boolean;
+        default "true";
+        description
+          "This leaf contains the configured, desired state of the
+           interface.
+
+           Systems that implement the IF-MIB use the value of this
+           leaf in the intended configuration to set
+           IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry
+           has been initialized, as described in RFC 2863.
+
+           Changes in this leaf in the intended configuration are
+           reflected in ifAdminStatus.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
+      }
+
+      leaf link-up-down-trap-enable {
+        if-feature if-mib;
+        type enumeration {
+          enum enabled {
+            value 1;
+            description
+              "The device will generate linkUp/linkDown SNMP
+               notifications for this interface.";
+          }
+          enum disabled {
+            value 2;
+            description
+              "The device will not generate linkUp/linkDown SNMP
+               notifications for this interface.";
+          }
+        }
+        description
+          "Controls whether linkUp/linkDown SNMP notifications
+           should be generated for this interface.
+
+           If this node is not configured, the value 'enabled' is
+           operationally used by the server for interfaces that do
+           not operate on top of any other interface (i.e., there are
+           no 'lower-layer-if' entries), and 'disabled' otherwise.";
+        reference
+          "RFC 2863: The Interfaces Group MIB -
+                     ifLinkUpDownTrapEnable";
+      }
+
+      leaf admin-status {
+        if-feature if-mib;
+        type enumeration {
+          enum up {
+            value 1;
+            description
+              "Ready to pass packets.";
+          }
+          enum down {
+            value 2;
+            description
+              "Not ready to pass packets and not in some test mode.";
+          }
+          enum testing {
+            value 3;
+            description
+              "In some test mode.";
+          }
+        }
+        config false;
+        mandatory true;
+        description
+          "The desired state of the interface.
+
+           This leaf has the same read semantics as ifAdminStatus.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
+      }
+
+      leaf oper-status {
+        type enumeration {
+          enum up {
+            value 1;
+            description
+              "Ready to pass packets.";
+          }
+          enum down {
+            value 2;
+
+            description
+              "The interface does not pass any packets.";
+          }
+          enum testing {
+            value 3;
+            description
+              "In some test mode.  No operational packets can
+               be passed.";
+          }
+          enum unknown {
+            value 4;
+            description
+              "Status cannot be determined for some reason.";
+          }
+          enum dormant {
+            value 5;
+            description
+              "Waiting for some external event.";
+          }
+          enum not-present {
+            value 6;
+            description
+              "Some component (typically hardware) is missing.";
+          }
+          enum lower-layer-down {
+            value 7;
+            description
+              "Down due to state of lower-layer interface(s).";
+          }
+        }
+        config false;
+        mandatory true;
+        description
+          "The current operational state of the interface.
+
+           This leaf has the same semantics as ifOperStatus.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifOperStatus";
+      }
+
+      leaf last-change {
+        type yang:date-and-time;
+        config false;
+        description
+          "The time the interface entered its current operational
+           state.  If the current state was entered prior to the
+           last re-initialization of the local network management
+           subsystem, then this node is not present.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifLastChange";
+      }
+
+      leaf if-index {
+        if-feature if-mib;
+        type int32 {
+          range "1..2147483647";
+        }
+        config false;
+        mandatory true;
+        description
+          "The ifIndex value for the ifEntry represented by this
+           interface.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifIndex";
+      }
+
+      leaf phys-address {
+        type yang:phys-address;
+        config false;
+        description
+          "The interface's address at its protocol sub-layer.  For
+           example, for an 802.x interface, this object normally
+           contains a Media Access Control (MAC) address.  The
+           interface's media-specific modules must define the bit
+           and byte ordering and the format of the value of this
+           object.  For interfaces that do not have such an address
+           (e.g., a serial line), this node is not present.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifPhysAddress";
+      }
+
+      leaf-list higher-layer-if {
+        type interface-ref;
+        config false;
+        description
+          "A list of references to interfaces layered on top of this
+           interface.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifStackTable";
+      }
+
+      leaf-list lower-layer-if {
+        type interface-ref;
+        config false;
+
+        description
+          "A list of references to interfaces layered underneath this
+           interface.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifStackTable";
+      }
+
+      leaf speed {
+        type yang:gauge64;
+        units "bits/second";
+        config false;
+        description
+            "An estimate of the interface's current bandwidth in bits
+             per second.  For interfaces that do not vary in
+             bandwidth or for those where no accurate estimation can
+             be made, this node should contain the nominal bandwidth.
+             For interfaces that have no concept of bandwidth, this
+             node is not present.";
+        reference
+          "RFC 2863: The Interfaces Group MIB -
+                     ifSpeed, ifHighSpeed";
+      }
+
+      container statistics {
+        config false;
+        description
+          "A collection of interface-related statistics objects.";
+
+        leaf discontinuity-time {
+          type yang:date-and-time;
+          mandatory true;
+          description
+            "The time on the most recent occasion at which any one or
+             more of this interface's counters suffered a
+             discontinuity.  If no such discontinuities have occurred
+             since the last re-initialization of the local management
+             subsystem, then this node contains the time the local
+             management subsystem re-initialized itself.";
+        }
+
+        leaf in-octets {
+          type yang:counter64;
+          description
+            "The total number of octets received on the interface,
+             including framing characters.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifHCInOctets";
+        }
+
+        leaf in-unicast-pkts {
+          type yang:counter64;
+          description
+            "The number of packets, delivered by this sub-layer to a
+             higher (sub-)layer, that were not addressed to a
+             multicast or broadcast address at this sub-layer.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifHCInUcastPkts";
+        }
+
+        leaf in-broadcast-pkts {
+          type yang:counter64;
+          description
+            "The number of packets, delivered by this sub-layer to a
+             higher (sub-)layer, that were addressed to a broadcast
+             address at this sub-layer.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB -
+                       ifHCInBroadcastPkts";
+        }
+
+        leaf in-multicast-pkts {
+          type yang:counter64;
+          description
+            "The number of packets, delivered by this sub-layer to a
+             higher (sub-)layer, that were addressed to a multicast
+             address at this sub-layer.  For a MAC-layer protocol,
+             this includes both Group and Functional addresses.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB -
+                       ifHCInMulticastPkts";
+        }
+
+        leaf in-discards {
+          type yang:counter32;
+          description
+            "The number of inbound packets that were chosen to be
+             discarded even though no errors had been detected to
+             prevent their being deliverable to a higher-layer
+             protocol.  One possible reason for discarding such a
+             packet could be to free up buffer space.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifInDiscards";
+        }
+
+        leaf in-errors {
+          type yang:counter32;
+          description
+            "For packet-oriented interfaces, the number of inbound
+             packets that contained errors preventing them from being
+             deliverable to a higher-layer protocol.  For character-
+             oriented or fixed-length interfaces, the number of
+             inbound transmission units that contained errors
+             preventing them from being deliverable to a higher-layer
+             protocol.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifInErrors";
+        }
+
+        leaf in-unknown-protos {
+          type yang:counter32;
+
+          description
+            "For packet-oriented interfaces, the number of packets
+             received via the interface that were discarded because
+             of an unknown or unsupported protocol.  For
+             character-oriented or fixed-length interfaces that
+             support protocol multiplexing, the number of
+             transmission units received via the interface that were
+             discarded because of an unknown or unsupported protocol.
+             For any interface that does not support protocol
+             multiplexing, this counter is not present.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifInUnknownProtos";
+        }
+
+        leaf out-octets {
+          type yang:counter64;
+          description
+            "The total number of octets transmitted out of the
+             interface, including framing characters.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifHCOutOctets";
+        }
+
+        leaf out-unicast-pkts {
+          type yang:counter64;
+          description
+            "The total number of packets that higher-level protocols
+             requested be transmitted and that were not addressed
+             to a multicast or broadcast address at this sub-layer,
+             including those that were discarded or not sent.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifHCOutUcastPkts";
+        }
+
+        leaf out-broadcast-pkts {
+          type yang:counter64;
+          description
+            "The total number of packets that higher-level protocols
+             requested be transmitted and that were addressed to a
+             broadcast address at this sub-layer, including those
+             that were discarded or not sent.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB -
+                       ifHCOutBroadcastPkts";
+        }
+
+        leaf out-multicast-pkts {
+          type yang:counter64;
+          description
+            "The total number of packets that higher-level protocols
+             requested be transmitted and that were addressed to a
+             multicast address at this sub-layer, including those
+             that were discarded or not sent.  For a MAC-layer
+             protocol, this includes both Group and Functional
+             addresses.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB -
+                       ifHCOutMulticastPkts";
+        }
+
+        leaf out-discards {
+          type yang:counter32;
+          description
+            "The number of outbound packets that were chosen to be
+             discarded even though no errors had been detected to
+             prevent their being transmitted.  One possible reason
+             for discarding such a packet could be to free up buffer
+             space.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifOutDiscards";
+        }
+
+        leaf out-errors {
+          type yang:counter32;
+          description
+            "For packet-oriented interfaces, the number of outbound
+             packets that could not be transmitted because of errors.
+             For character-oriented or fixed-length interfaces, the
+             number of outbound transmission units that could not be
+             transmitted because of errors.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifOutErrors";
+        }
+      }
+
+    }
+  }
+
+  /*
+   * Legacy typedefs
+   */
+
+  typedef interface-state-ref {
+    type leafref {
+      path "/if:interfaces-state/if:interface/if:name";
+    }
+    status deprecated;
+    description
+      "This type is used by data models that need to reference
+       the operationally present interfaces.";
+  }
+
+  /*
+   * Legacy operational state data nodes
+   */
+
+  container interfaces-state {
+    config false;
+    status deprecated;
+    description
+      "Data nodes for the operational state of interfaces.";
+
+    list interface {
+      key "name";
+      status deprecated;
+
+      description
+        "The list of interfaces on the device.
+
+         System-controlled interfaces created by the system are
+         always present in this list, whether or not they are
+         configured.";
+
+      leaf name {
+        type string;
+        status deprecated;
+        description
+          "The name of the interface.
+
+           A server implementation MAY map this leaf to the ifName
+           MIB object.  Such an implementation needs to use some
+           mechanism to handle the differences in size and characters
+           allowed between this leaf and ifName.  The definition of
+           such a mechanism is outside the scope of this document.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifName";
+      }
+
+      leaf type {
+        type identityref {
+          base interface-type;
+        }
+        mandatory true;
+        status deprecated;
+        description
+          "The type of the interface.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifType";
+      }
+
+      leaf admin-status {
+        if-feature if-mib;
+        type enumeration {
+          enum up {
+            value 1;
+            description
+              "Ready to pass packets.";
+          }
+          enum down {
+            value 2;
+            description
+              "Not ready to pass packets and not in some test mode.";
+          }
+          enum testing {
+            value 3;
+            description
+              "In some test mode.";
+          }
+        }
+        mandatory true;
+        status deprecated;
+        description
+          "The desired state of the interface.
+
+           This leaf has the same read semantics as ifAdminStatus.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifAdminStatus";
+      }
+
+      leaf oper-status {
+        type enumeration {
+          enum up {
+            value 1;
+            description
+              "Ready to pass packets.";
+          }
+          enum down {
+            value 2;
+            description
+              "The interface does not pass any packets.";
+          }
+          enum testing {
+            value 3;
+            description
+              "In some test mode.  No operational packets can
+               be passed.";
+          }
+          enum unknown {
+            value 4;
+            description
+              "Status cannot be determined for some reason.";
+          }
+          enum dormant {
+            value 5;
+            description
+              "Waiting for some external event.";
+          }
+          enum not-present {
+            value 6;
+            description
+              "Some component (typically hardware) is missing.";
+          }
+          enum lower-layer-down {
+            value 7;
+            description
+              "Down due to state of lower-layer interface(s).";
+          }
+        }
+        mandatory true;
+        status deprecated;
+        description
+          "The current operational state of the interface.
+
+           This leaf has the same semantics as ifOperStatus.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifOperStatus";
+      }
+
+      leaf last-change {
+        type yang:date-and-time;
+        status deprecated;
+        description
+          "The time the interface entered its current operational
+           state.  If the current state was entered prior to the
+           last re-initialization of the local network management
+           subsystem, then this node is not present.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifLastChange";
+      }
+
+      leaf if-index {
+        if-feature if-mib;
+        type int32 {
+          range "1..2147483647";
+        }
+        mandatory true;
+        status deprecated;
+        description
+          "The ifIndex value for the ifEntry represented by this
+           interface.";
+
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifIndex";
+      }
+
+      leaf phys-address {
+        type yang:phys-address;
+        status deprecated;
+        description
+          "The interface's address at its protocol sub-layer.  For
+           example, for an 802.x interface, this object normally
+           contains a Media Access Control (MAC) address.  The
+           interface's media-specific modules must define the bit
+           and byte ordering and the format of the value of this
+           object.  For interfaces that do not have such an address
+           (e.g., a serial line), this node is not present.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifPhysAddress";
+      }
+
+      leaf-list higher-layer-if {
+        type interface-state-ref;
+        status deprecated;
+        description
+          "A list of references to interfaces layered on top of this
+           interface.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifStackTable";
+      }
+
+      leaf-list lower-layer-if {
+        type interface-state-ref;
+        status deprecated;
+        description
+          "A list of references to interfaces layered underneath this
+           interface.";
+        reference
+          "RFC 2863: The Interfaces Group MIB - ifStackTable";
+      }
+
+      leaf speed {
+        type yang:gauge64;
+        units "bits/second";
+        status deprecated;
+        description
+            "An estimate of the interface's current bandwidth in bits
+             per second.  For interfaces that do not vary in
+             bandwidth or for those where no accurate estimation can
+
+             be made, this node should contain the nominal bandwidth.
+             For interfaces that have no concept of bandwidth, this
+             node is not present.";
+        reference
+          "RFC 2863: The Interfaces Group MIB -
+                     ifSpeed, ifHighSpeed";
+      }
+
+      container statistics {
+        status deprecated;
+        description
+          "A collection of interface-related statistics objects.";
+
+        leaf discontinuity-time {
+          type yang:date-and-time;
+          mandatory true;
+          status deprecated;
+          description
+            "The time on the most recent occasion at which any one or
+             more of this interface's counters suffered a
+             discontinuity.  If no such discontinuities have occurred
+             since the last re-initialization of the local management
+             subsystem, then this node contains the time the local
+             management subsystem re-initialized itself.";
+        }
+
+        leaf in-octets {
+          type yang:counter64;
+          status deprecated;
+          description
+            "The total number of octets received on the interface,
+             including framing characters.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifHCInOctets";
+        }
+
+        leaf in-unicast-pkts {
+          type yang:counter64;
+          status deprecated;
+          description
+            "The number of packets, delivered by this sub-layer to a
+             higher (sub-)layer, that were not addressed to a
+             multicast or broadcast address at this sub-layer.
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifHCInUcastPkts";
+        }
+
+        leaf in-broadcast-pkts {
+          type yang:counter64;
+          status deprecated;
+          description
+            "The number of packets, delivered by this sub-layer to a
+             higher (sub-)layer, that were addressed to a broadcast
+             address at this sub-layer.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB -
+                       ifHCInBroadcastPkts";
+        }
+
+        leaf in-multicast-pkts {
+          type yang:counter64;
+          status deprecated;
+          description
+            "The number of packets, delivered by this sub-layer to a
+             higher (sub-)layer, that were addressed to a multicast
+             address at this sub-layer.  For a MAC-layer protocol,
+             this includes both Group and Functional addresses.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB -
+                       ifHCInMulticastPkts";
+        }
+
+        leaf in-discards {
+          type yang:counter32;
+          status deprecated;
+
+          description
+            "The number of inbound packets that were chosen to be
+             discarded even though no errors had been detected to
+             prevent their being deliverable to a higher-layer
+             protocol.  One possible reason for discarding such a
+             packet could be to free up buffer space.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifInDiscards";
+        }
+
+        leaf in-errors {
+          type yang:counter32;
+          status deprecated;
+          description
+            "For packet-oriented interfaces, the number of inbound
+             packets that contained errors preventing them from being
+             deliverable to a higher-layer protocol.  For character-
+             oriented or fixed-length interfaces, the number of
+             inbound transmission units that contained errors
+             preventing them from being deliverable to a higher-layer
+             protocol.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifInErrors";
+        }
+
+        leaf in-unknown-protos {
+          type yang:counter32;
+          status deprecated;
+          description
+            "For packet-oriented interfaces, the number of packets
+             received via the interface that were discarded because
+             of an unknown or unsupported protocol.  For
+             character-oriented or fixed-length interfaces that
+             support protocol multiplexing, the number of
+             transmission units received via the interface that were
+             discarded because of an unknown or unsupported protocol.
+             For any interface that does not support protocol
+             multiplexing, this counter is not present.
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifInUnknownProtos";
+        }
+
+        leaf out-octets {
+          type yang:counter64;
+          status deprecated;
+          description
+            "The total number of octets transmitted out of the
+             interface, including framing characters.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifHCOutOctets";
+        }
+
+        leaf out-unicast-pkts {
+          type yang:counter64;
+          status deprecated;
+          description
+            "The total number of packets that higher-level protocols
+             requested be transmitted and that were not addressed
+             to a multicast or broadcast address at this sub-layer,
+             including those that were discarded or not sent.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifHCOutUcastPkts";
+        }
+
+        leaf out-broadcast-pkts {
+          type yang:counter64;
+          status deprecated;
+
+          description
+            "The total number of packets that higher-level protocols
+             requested be transmitted and that were addressed to a
+             broadcast address at this sub-layer, including those
+             that were discarded or not sent.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB -
+                       ifHCOutBroadcastPkts";
+        }
+
+        leaf out-multicast-pkts {
+          type yang:counter64;
+          status deprecated;
+          description
+            "The total number of packets that higher-level protocols
+             requested be transmitted and that were addressed to a
+             multicast address at this sub-layer, including those
+             that were discarded or not sent.  For a MAC-layer
+             protocol, this includes both Group and Functional
+             addresses.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB -
+                       ifHCOutMulticastPkts";
+        }
+
+        leaf out-discards {
+          type yang:counter32;
+          status deprecated;
+          description
+            "The number of outbound packets that were chosen to be
+             discarded even though no errors had been detected to
+             prevent their being transmitted.  One possible reason
+             for discarding such a packet could be to free up buffer
+             space.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifOutDiscards";
+        }
+
+        leaf out-errors {
+          type yang:counter32;
+          status deprecated;
+          description
+            "For packet-oriented interfaces, the number of outbound
+             packets that could not be transmitted because of errors.
+             For character-oriented or fixed-length interfaces, the
+             number of outbound transmission units that could not be
+             transmitted because of errors.
+
+             Discontinuities in the value of this counter can occur
+             at re-initialization of the management system and at
+             other times as indicated by the value of
+             'discontinuity-time'.";
+          reference
+            "RFC 2863: The Interfaces Group MIB - ifOutErrors";
+        }
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/usr/share/yang/ietf-routing-types.yang frr/usr/share/yang/ietf-routing-types.yang
--- frr-frr-8.1/usr/share/yang/ietf-routing-types.yang	1970-01-01 07:00:00.000000000 +0700
+++ frr/usr/share/yang/ietf-routing-types.yang	2021-08-31 15:25:52.006888488 +0700
@@ -0,0 +1,751 @@
+module ietf-routing-types {
+  namespace "urn:ietf:params:xml:ns:yang:ietf-routing-types";
+  prefix rt-types;
+
+  import ietf-yang-types {
+    prefix yang;
+  }
+  import ietf-inet-types {
+    prefix inet;
+  }
+
+  organization
+    "IETF RTGWG - Routing Area Working Group";
+  contact
+    "WG Web:   <https://datatracker.ietf.org/wg/rtgwg/>
+     WG List:  <mailto:rtgwg@ietf.org>
+     Editors:  Xufeng Liu
+               <mailto:Xufeng_Liu@jabail.com>
+               Yingzhen Qu
+               <mailto:yingzhen.qu@huawei.com>
+               Acee Lindem
+               <mailto:acee@cisco.com>
+               Christian Hopps
+               <mailto:chopps@chopps.org>
+               Lou Berger
+               <mailto:lberger@labn.com>";
+
+  description
+    "This module contains a collection of YANG data types
+     considered generally useful for routing protocols.
+     Copyright (c) 2017 IETF Trust and the persons
+     identified as authors of the code.  All rights reserved.
+     Redistribution and use in source and binary forms, with or
+     without modification, is permitted pursuant to, and subject
+     to the license terms contained in, the Simplified BSD License
+     set forth in Section 4.c of the IETF Trust's Legal Provisions
+     Relating to IETF Documents
+     (https://trustee.ietf.org/license-info).
+     This version of this YANG module is part of RFC 8294; see
+     the RFC itself for full legal notices.";
+   revision 2017-12-04 {
+     description "Initial revision.";
+     reference
+       "RFC 8294: Common YANG Data Types for the Routing Area.
+        Section 3.";
+  }
+
+  /*** Identities related to MPLS/GMPLS ***/
+
+  identity mpls-label-special-purpose-value {
+    description
+      "Base identity for deriving identities describing
+       special-purpose Multiprotocol Label Switching (MPLS) label
+       values.";
+    reference
+      "RFC 7274: Allocating and Retiring Special-Purpose MPLS
+       Labels.";
+  }
+
+  identity ipv4-explicit-null-label {
+    base mpls-label-special-purpose-value;
+    description
+      "This identity represents the IPv4 Explicit NULL Label.";
+    reference
+      "RFC 3032: MPLS Label Stack Encoding.  Section 2.1.";
+  }
+
+  identity router-alert-label {
+    base mpls-label-special-purpose-value;
+    description
+      "This identity represents the Router Alert Label.";
+    reference
+      "RFC 3032: MPLS Label Stack Encoding.  Section 2.1.";
+  }
+
+  identity ipv6-explicit-null-label {
+    base mpls-label-special-purpose-value;
+    description
+      "This identity represents the IPv6 Explicit NULL Label.";
+    reference
+      "RFC 3032: MPLS Label Stack Encoding.  Section 2.1.";
+  }
+
+  identity implicit-null-label {
+    base mpls-label-special-purpose-value;
+    description
+      "This identity represents the Implicit NULL Label.";
+    reference
+      "RFC 3032: MPLS Label Stack Encoding.  Section 2.1.";
+  }
+
+  identity entropy-label-indicator {
+    base mpls-label-special-purpose-value;
+    description
+      "This identity represents the Entropy Label Indicator.";
+    reference
+      "RFC 6790: The Use of Entropy Labels in MPLS Forwarding.
+       Sections 3 and 10.1.";
+  }
+
+  identity gal-label {
+    base mpls-label-special-purpose-value;
+    description
+      "This identity represents the Generic Associated Channel
+       (G-ACh) Label (GAL).";
+    reference
+      "RFC 5586: MPLS Generic Associated Channel.
+       Sections 4 and 10.";
+  }
+
+  identity oam-alert-label {
+    base mpls-label-special-purpose-value;
+    description
+      "This identity represents the OAM Alert Label.";
+    reference
+      "RFC 3429: Assignment of the 'OAM Alert Label' for
+       Multiprotocol Label Switching Architecture (MPLS)
+       Operation and Maintenance (OAM) Functions.
+       Sections 3 and 6.";
+  }
+
+  identity extension-label {
+    base mpls-label-special-purpose-value;
+    description
+      "This identity represents the Extension Label.";
+    reference
+      "RFC 7274: Allocating and Retiring Special-Purpose MPLS
+       Labels.  Sections 3.1 and 5.";
+  }
+
+  /*** Collection of types related to routing ***/
+
+  typedef router-id {
+    type yang:dotted-quad;
+    description
+      "A 32-bit number in the dotted-quad format assigned to each
+       router.  This number uniquely identifies the router within
+       an Autonomous System.";
+  }
+
+  /*** Collection of types related to VPNs ***/
+
+  typedef route-target {
+    type string {
+      pattern
+        '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+      +     '6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|'
+      +     '42949672[0-8][0-9]|'
+      +     '4294967[01][0-9]{2}|429496[0-6][0-9]{3}|'
+      +     '42949[0-5][0-9]{4}|'
+      +     '4294[0-8][0-9]{5}|429[0-3][0-9]{6}|'
+      +     '42[0-8][0-9]{7}|4[01][0-9]{8}|'
+      +     '[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|'
+      + '(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|'
+      +     '25[0-5])\.){3}([0-9]|[1-9][0-9]|'
+      +     '1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|'
+      +     '655[0-2][0-9]|'
+      +     '65[0-4][0-9]{2}|6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|'
+      + '(2:(429496729[0-5]|42949672[0-8][0-9]|'
+      +     '4294967[01][0-9]{2}|'
+      +     '429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|'
+      +     '4294[0-8][0-9]{5}|'
+      +     '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|'
+      +     '[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):'
+      +     '(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+      +     '6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|'
+      + '(6(:[a-fA-F0-9]{2}){6})|'
+      + '(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):'
+      +     '[0-9a-fA-F]{1,12})';
+    }
+
+    description
+      "A Route Target is an 8-octet BGP extended community
+       initially identifying a set of sites in a BGP VPN
+       (RFC 4364).  However, it has since taken on a more general
+       role in BGP route filtering.  A Route Target consists of two
+       or three fields: a 2-octet Type field, an administrator
+       field, and, optionally, an assigned number field.
+       According to the data formats for types 0, 1, 2, and 6 as
+       defined in RFC 4360, RFC 5668, and RFC 7432, the encoding
+       pattern is defined as:
+       0:2-octet-asn:4-octet-number
+       1:4-octet-ipv4addr:2-octet-number
+       2:4-octet-asn:2-octet-number
+       6:6-octet-mac-address
+       Additionally, a generic pattern is defined for future
+       Route Target types:
+       2-octet-other-hex-number:6-octet-hex-number
+       Some valid examples are 0:100:100, 1:1.1.1.1:100,
+       2:1234567890:203, and 6:26:00:08:92:78:00.";
+    reference
+      "RFC 4360: BGP Extended Communities Attribute.
+       RFC 4364: BGP/MPLS IP Virtual Private Networks (VPNs).
+       RFC 5668: 4-Octet AS Specific BGP Extended Community.
+       RFC 7432: BGP MPLS-Based Ethernet VPN.";
+  }
+
+  typedef ipv6-route-target {
+    type string {
+      pattern
+          '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
+          + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
+          + '(((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}'
+          + '(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])))'
+          + ':'
+          + '(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+          + '6[0-4][0-9]{3}|'
+          + '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0)';
+      pattern '((([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
+          + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))'
+          + ':'
+          + '(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+          + '6[0-4][0-9]{3}|'
+          + '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0)';
+    }
+    description
+      "An IPv6 Route Target is a 20-octet BGP IPv6 Address
+       Specific Extended Community serving the same function
+       as a standard 8-octet Route Target, except that it only
+       allows an IPv6 address as the global administrator.
+       The format is <ipv6-address:2-octet-number>.
+       Two valid examples are 2001:db8::1:6544 and
+       2001:db8::5eb1:791:6b37:17958.";
+    reference
+      "RFC 5701: IPv6 Address Specific BGP Extended Community
+       Attribute.";
+  }
+
+  typedef route-target-type {
+    type enumeration {
+      enum import {
+        value 0;
+        description
+          "The Route Target applies to route import.";
+      }
+      enum export {
+        value 1;
+        description
+          "The Route Target applies to route export.";
+      }
+
+      enum both {
+        value 2;
+        description
+          "The Route Target applies to both route import and
+           route export.";
+      }
+    }
+    description
+      "Indicates the role a Route Target takes in route filtering.";
+    reference
+      "RFC 4364: BGP/MPLS IP Virtual Private Networks (VPNs).";
+  }
+
+  typedef route-distinguisher {
+    type string {
+      pattern
+        '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+      +     '6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|'
+      +     '42949672[0-8][0-9]|'
+      +     '4294967[01][0-9]{2}|429496[0-6][0-9]{3}|'
+      +     '42949[0-5][0-9]{4}|'
+      +     '4294[0-8][0-9]{5}|429[0-3][0-9]{6}|'
+      +     '42[0-8][0-9]{7}|4[01][0-9]{8}|'
+      +     '[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|'
+      + '(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|'
+      +     '25[0-5])\.){3}([0-9]|[1-9][0-9]|'
+      +     '1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|'
+      +     '655[0-2][0-9]|'
+      +     '65[0-4][0-9]{2}|6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|'
+      + '(2:(429496729[0-5]|42949672[0-8][0-9]|'
+      +     '4294967[01][0-9]{2}|'
+      +     '429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|'
+      +     '4294[0-8][0-9]{5}|'
+      +     '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|'
+      +     '[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):'
+      +     '(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+      +     '6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|'
+      + '(6(:[a-fA-F0-9]{2}){6})|'
+      + '(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):'
+      +     '[0-9a-fA-F]{1,12})';
+    }
+
+    description
+      "A Route Distinguisher is an 8-octet value used to
+       distinguish routes from different BGP VPNs (RFC 4364).
+       A Route Distinguisher will have the same format as a
+       Route Target as per RFC 4360 and will consist of
+       two or three fields: a 2-octet Type field, an administrator
+       field, and, optionally, an assigned number field.
+       According to the data formats for types 0, 1, 2, and 6 as
+       defined in RFC 4360, RFC 5668, and RFC 7432, the encoding
+       pattern is defined as:
+       0:2-octet-asn:4-octet-number
+       1:4-octet-ipv4addr:2-octet-number
+       2:4-octet-asn:2-octet-number
+       6:6-octet-mac-address
+       Additionally, a generic pattern is defined for future
+       route discriminator types:
+       2-octet-other-hex-number:6-octet-hex-number
+       Some valid examples are 0:100:100, 1:1.1.1.1:100,
+       2:1234567890:203, and 6:26:00:08:92:78:00.";
+    reference
+      "RFC 4360: BGP Extended Communities Attribute.
+       RFC 4364: BGP/MPLS IP Virtual Private Networks (VPNs).
+       RFC 5668: 4-Octet AS Specific BGP Extended Community.
+       RFC 7432: BGP MPLS-Based Ethernet VPN.";
+  }
+
+  typedef route-origin {
+    type string {
+      pattern
+        '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+      +     '6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|'
+      +     '42949672[0-8][0-9]|'
+      +     '4294967[01][0-9]{2}|429496[0-6][0-9]{3}|'
+      +     '42949[0-5][0-9]{4}|'
+      +     '4294[0-8][0-9]{5}|429[0-3][0-9]{6}|'
+      +     '42[0-8][0-9]{7}|4[01][0-9]{8}|'
+      +     '[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|'
+      + '(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|'
+      +     '25[0-5])\.){3}([0-9]|[1-9][0-9]|'
+      +     '1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|'
+      +     '655[0-2][0-9]|'
+      +     '65[0-4][0-9]{2}|6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|'
+      + '(2:(429496729[0-5]|42949672[0-8][0-9]|'
+      +     '4294967[01][0-9]{2}|'
+      +     '429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|'
+      +     '4294[0-8][0-9]{5}|'
+      +     '429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|'
+      +     '[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):'
+      +     '(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+      +     '6[0-4][0-9]{3}|'
+      +     '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|'
+      + '(6(:[a-fA-F0-9]{2}){6})|'
+      + '(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):'
+      +    '[0-9a-fA-F]{1,12})';
+    }
+    description
+      "A Route Origin is an 8-octet BGP extended community
+       identifying the set of sites where the BGP route
+       originated (RFC 4364).  A Route Origin will have the same
+       format as a Route Target as per RFC 4360 and will consist
+       of two or three fields: a 2-octet Type field, an
+       administrator field, and, optionally, an assigned number
+       field.
+       According to the data formats for types 0, 1, 2, and 6 as
+       defined in RFC 4360, RFC 5668, and RFC 7432, the encoding
+       pattern is defined as:
+       0:2-octet-asn:4-octet-number
+       1:4-octet-ipv4addr:2-octet-number
+       2:4-octet-asn:2-octet-number
+       6:6-octet-mac-address
+       Additionally, a generic pattern is defined for future
+       Route Origin types:
+       2-octet-other-hex-number:6-octet-hex-number
+       Some valid examples are 0:100:100, 1:1.1.1.1:100,
+       2:1234567890:203, and 6:26:00:08:92:78:00.";
+    reference
+      "RFC 4360: BGP Extended Communities Attribute.
+       RFC 4364: BGP/MPLS IP Virtual Private Networks (VPNs).
+       RFC 5668: 4-Octet AS Specific BGP Extended Community.
+       RFC 7432: BGP MPLS-Based Ethernet VPN.";
+  }
+
+  typedef ipv6-route-origin {
+    type string {
+      pattern
+          '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
+          + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
+          + '(((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}'
+          + '(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])))'
+          + ':'
+          + '(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+          + '6[0-4][0-9]{3}|'
+          + '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0)';
+      pattern '((([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
+          + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))'
+          + ':'
+          + '(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|'
+          + '6[0-4][0-9]{3}|'
+          + '[1-5][0-9]{4}|[1-9][0-9]{0,3}|0)';
+    }
+    description
+      "An IPv6 Route Origin is a 20-octet BGP IPv6 Address
+       Specific Extended Community serving the same function
+       as a standard 8-octet route, except that it only allows
+       an IPv6 address as the global administrator.  The format
+       is <ipv6-address:2-octet-number>.
+       Two valid examples are 2001:db8::1:6544 and
+       2001:db8::5eb1:791:6b37:17958.";
+    reference
+      "RFC 5701: IPv6 Address Specific BGP Extended Community
+       Attribute.";
+  }
+
+  /*** Collection of types common to multicast ***/
+
+  typedef ipv4-multicast-group-address {
+    type inet:ipv4-address {
+      pattern '(2((2[4-9])|(3[0-9]))\.).*';
+    }
+    description
+      "This type represents an IPv4 multicast group address,
+       which is in the range of 224.0.0.0 to 239.255.255.255.";
+    reference
+      "RFC 1112: Host Extensions for IP Multicasting.";
+  }
+
+  typedef ipv6-multicast-group-address {
+    type inet:ipv6-address {
+      pattern '(([fF]{2}[0-9a-fA-F]{2}):).*';
+    }
+    description
+      "This type represents an IPv6 multicast group address,
+       which is in the range of ff00::/8.";
+    reference
+      "RFC 4291: IP Version 6 Addressing Architecture.  Section 2.7.
+       RFC 7346: IPv6 Multicast Address Scopes.";
+  }
+
+  typedef ip-multicast-group-address {
+    type union {
+      type ipv4-multicast-group-address;
+      type ipv6-multicast-group-address;
+    }
+    description
+      "This type represents a version-neutral IP multicast group
+       address.  The format of the textual representation implies
+       the IP version.";
+  }
+
+  typedef ipv4-multicast-source-address {
+    type union {
+      type enumeration {
+        enum * {
+          description
+            "Any source address.";
+        }
+      }
+      type inet:ipv4-address;
+    }
+    description
+      "Multicast source IPv4 address type.";
+  }
+
+  typedef ipv6-multicast-source-address {
+    type union {
+      type enumeration {
+        enum * {
+          description
+            "Any source address.";
+        }
+      }
+      type inet:ipv6-address;
+    }
+    description
+      "Multicast source IPv6 address type.";
+  }
+
+  /*** Collection of types common to protocols ***/
+
+  typedef bandwidth-ieee-float32 {
+    type string {
+      pattern
+        '0[xX](0((\.0?)?[pP](\+)?0?|(\.0?))|'
+      + '1(\.([0-9a-fA-F]{0,5}[02468aAcCeE]?)?)?[pP](\+)?(12[0-7]|'
+      + '1[01][0-9]|0?[0-9]?[0-9])?)';
+    }
+    description
+      "Bandwidth in IEEE 754 floating-point 32-bit binary format:
+       (-1)**(S) * 2**(Exponent-127) * (1 + Fraction),
+       where Exponent uses 8 bits and Fraction uses 23 bits.
+       The units are octets per second.
+       The encoding format is the external hexadecimal-significant
+       character sequences specified in IEEE 754 and ISO/IEC C99.
+       The format is restricted to be normalized, non-negative, and
+       non-fraction: 0x1.hhhhhhp{+}d, 0X1.HHHHHHP{+}D, or 0x0p0,
+       where 'h' and 'H' are hexadecimal digits and 'd' and 'D' are
+       integers in the range of [0..127].
+       When six hexadecimal digits are used for 'hhhhhh' or
+       'HHHHHH', the least significant digit must be an even
+       number.  'x' and 'X' indicate hexadecimal; 'p' and 'P'
+       indicate a power of two.  Some examples are 0x0p0, 0x1p10,
+       and 0x1.abcde2p+20.";
+    reference
+      "IEEE Std 754-2008: IEEE Standard for Floating-Point
+       Arithmetic.
+       ISO/IEC C99: Information technology - Programming
+       Languages - C.";
+  }
+
+  typedef link-access-type {
+    type enumeration {
+      enum broadcast {
+        description
+          "Specify broadcast multi-access network.";
+      }
+      enum non-broadcast-multiaccess {
+        description
+          "Specify Non-Broadcast Multi-Access (NBMA) network.";
+      }
+      enum point-to-multipoint {
+        description
+          "Specify point-to-multipoint network.";
+      }
+      enum point-to-point {
+        description
+          "Specify point-to-point network.";
+      }
+    }
+    description
+      "Link access type.";
+  }
+
+  typedef timer-multiplier {
+    type uint8;
+    description
+      "The number of timer value intervals that should be
+       interpreted as a failure.";
+  }
+
+  typedef timer-value-seconds16 {
+    type union {
+      type uint16 {
+        range "1..65535";
+      }
+      type enumeration {
+        enum infinity {
+          description
+            "The timer is set to infinity.";
+        }
+        enum not-set {
+          description
+            "The timer is not set.";
+        }
+      }
+    }
+    units "seconds";
+    description
+      "Timer value type, in seconds (16-bit range).";
+  }
+
+  typedef timer-value-seconds32 {
+    type union {
+      type uint32 {
+        range "1..4294967295";
+      }
+      type enumeration {
+        enum infinity {
+          description
+            "The timer is set to infinity.";
+        }
+        enum not-set {
+          description
+            "The timer is not set.";
+        }
+      }
+    }
+    units "seconds";
+    description
+      "Timer value type, in seconds (32-bit range).";
+  }
+
+  typedef timer-value-milliseconds {
+    type union {
+      type uint32 {
+        range "1..4294967295";
+      }
+      type enumeration {
+        enum infinity {
+          description
+            "The timer is set to infinity.";
+        }
+        enum not-set {
+          description
+            "The timer is not set.";
+        }
+      }
+    }
+    units "milliseconds";
+    description
+      "Timer value type, in milliseconds.";
+  }
+
+  typedef percentage {
+    type uint8 {
+      range "0..100";
+    }
+    description
+      "Integer indicating a percentage value.";
+  }
+
+  typedef timeticks64 {
+    type uint64;
+    description
+      "This type is based on the timeticks type defined in
+       RFC 6991, but with 64-bit width.  It represents the time,
+       modulo 2^64, in hundredths of a second between two epochs.";
+    reference
+      "RFC 6991: Common YANG Data Types.";
+  }
+
+  typedef uint24 {
+    type uint32 {
+      range "0..16777215";
+    }
+    description
+      "24-bit unsigned integer.";
+  }
+
+  /*** Collection of types related to MPLS/GMPLS ***/
+
+  typedef generalized-label {
+    type binary;
+    description
+      "Generalized Label.  Nodes sending and receiving the
+       Generalized Label are aware of the link-specific
+       label context and type.";
+    reference
+      "RFC 3471: Generalized Multi-Protocol Label Switching (GMPLS)
+       Signaling Functional Description.  Section 3.2.";
+  }
+
+  typedef mpls-label-special-purpose {
+    type identityref {
+      base mpls-label-special-purpose-value;
+    }
+    description
+      "This type represents the special-purpose MPLS label values.";
+    reference
+      "RFC 3032: MPLS Label Stack Encoding.
+       RFC 7274: Allocating and Retiring Special-Purpose MPLS
+       Labels.";
+  }
+
+  typedef mpls-label-general-use {
+    type uint32 {
+      range "16..1048575";
+    }
+    description
+      "The 20-bit label value in an MPLS label stack as specified
+       in RFC 3032.  This label value does not include the
+       encodings of Traffic Class and TTL (Time to Live).
+       The label range specified by this type is for general use,
+       with special-purpose MPLS label values excluded.";
+    reference
+      "RFC 3032: MPLS Label Stack Encoding.";
+  }
+
+  typedef mpls-label {
+    type union {
+      type mpls-label-special-purpose;
+      type mpls-label-general-use;
+    }
+    description
+      "The 20-bit label value in an MPLS label stack as specified
+       in RFC 3032.  This label value does not include the
+       encodings of Traffic Class and TTL.";
+    reference
+      "RFC 3032: MPLS Label Stack Encoding.";
+  }
+
+  /*** Groupings **/
+
+  grouping mpls-label-stack {
+    description
+      "This grouping specifies an MPLS label stack.  The label
+       stack is encoded as a list of label stack entries.  The
+       list key is an identifier that indicates the relative
+       ordering of each entry, with the lowest-value identifier
+       corresponding to the top of the label stack.";
+    container mpls-label-stack {
+      description
+        "Container for a list of MPLS label stack entries.";
+      list entry {
+        key "id";
+        description
+          "List of MPLS label stack entries.";
+        leaf id {
+          type uint8;
+          description
+            "Identifies the entry in a sequence of MPLS label
+             stack entries.  An entry with a smaller identifier
+             value precedes an entry with a larger identifier
+             value in the label stack.  The value of this ID has
+             no semantic meaning other than relative ordering
+             and referencing the entry.";
+        }
+        leaf label {
+          type rt-types:mpls-label;
+          description
+            "Label value.";
+        }
+
+        leaf ttl {
+          type uint8;
+          description
+            "Time to Live (TTL).";
+          reference
+            "RFC 3032: MPLS Label Stack Encoding.";
+        }
+        leaf traffic-class {
+          type uint8 {
+            range "0..7";
+          }
+          description
+            "Traffic Class (TC).";
+          reference
+            "RFC 5462: Multiprotocol Label Switching (MPLS) Label
+             Stack Entry: 'EXP' Field Renamed to 'Traffic Class'
+             Field.";
+        }
+      }
+    }
+  }
+
+  grouping vpn-route-targets {
+    description
+      "A grouping that specifies Route Target import-export rules
+       used in BGP-enabled VPNs.";
+    reference
+      "RFC 4364: BGP/MPLS IP Virtual Private Networks (VPNs).
+       RFC 4664: Framework for Layer 2 Virtual Private Networks
+       (L2VPNs).";
+    list vpn-target {
+      key "route-target";
+      description
+        "List of Route Targets.";
+      leaf route-target {
+        type rt-types:route-target;
+        description
+          "Route Target value.";
+      }
+      leaf route-target-type {
+        type rt-types:route-target-type;
+        mandatory true;
+        description
+          "Import/export type of the Route Target.";
+      }
+    }
+  }
+}
diff -urpN frr-frr-8.1/vtysh/vtysh.c frr/vtysh/vtysh.c
--- frr-frr-8.1/vtysh/vtysh.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/vtysh/vtysh.c	2022-02-15 18:58:52.092958375 +0700
@@ -4237,6 +4237,7 @@ void vtysh_init_vty(void)
 #endif /* HAVE_BFDD */
 
 	install_node(&segment_routing_node);
+	install_element(CONFIG_NODE, &segment_routing_cmd);
 	install_element(SEGMENT_ROUTING_NODE, &vtysh_exit_sr_cmd);
 	install_element(SEGMENT_ROUTING_NODE, &vtysh_quit_sr_cmd);
 	install_element(SEGMENT_ROUTING_NODE, &vtysh_end_all_cmd);
@@ -4262,7 +4263,6 @@ void vtysh_init_vty(void)
 	install_element(SR_POLICY_NODE, &vtysh_end_all_cmd);
 	install_element(SR_CANDIDATE_DYN_NODE, &vtysh_end_all_cmd);
 
-	install_element(CONFIG_NODE, &segment_routing_cmd);
 	install_element(SEGMENT_ROUTING_NODE, &sr_traffic_eng_cmd);
 	install_element(SR_TRAFFIC_ENG_NODE, &srte_segment_list_cmd);
 	install_element(SR_TRAFFIC_ENG_NODE, &srte_policy_cmd);
diff -urpN frr-frr-8.1/vtysh/vtysh_config.c frr/vtysh/vtysh_config.c
--- frr-frr-8.1/vtysh/vtysh_config.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/vtysh/vtysh_config.c	2022-02-15 18:58:52.092958375 +0700
@@ -433,6 +433,8 @@ void vtysh_config_parse_line(void *arg,
 			config = config_get(SEGMENT_ROUTING_NODE, line);
 		else if (strncmp(line, "bfd", strlen("bfd")) == 0)
 			config = config_get(BFD_NODE, line);
+		else if (strncmp(line, "rpki", strlen("rpki")) == 0)
+			config = config_get(RPKI_NODE, line);
 		else {
 			if (strncmp(line, "log", strlen("log")) == 0
 			    || strncmp(line, "hostname", strlen("hostname")) == 0
diff -urpN frr-frr-8.1/zebra/zebra_evpn_mac.c frr/zebra/zebra_evpn_mac.c
--- frr-frr-8.1/zebra/zebra_evpn_mac.c	2021-11-08 10:44:24.000000000 +0700
+++ frr/zebra/zebra_evpn_mac.c	2022-02-15 18:58:52.099625060 +0700
@@ -106,19 +106,6 @@ static void zebra_evpn_mac_ifp_new(struc
 	listset_app_node_mem(zif->mac_list);
 }
 
-/* Free up the mac_list if any as a part of the interface del/cleanup */
-void zebra_evpn_mac_ifp_del(struct interface *ifp)
-{
-	struct zebra_if *zif = ifp->info;
-
-	if (zif->mac_list) {
-		if (IS_ZEBRA_DEBUG_EVPN_MH_MAC)
-			zlog_debug("MAC list deleted for ifp %s (%u)",
-				   zif->ifp->name, zif->ifp->ifindex);
-		list_delete(&zif->mac_list);
-	}
-}
-
 /* Unlink local mac from a destination access port */
 static void zebra_evpn_mac_ifp_unlink(struct zebra_mac *zmac)
 {
@@ -139,6 +126,25 @@ static void zebra_evpn_mac_ifp_unlink(st
 	zmac->ifp = NULL;
 }
 
+/* Free up the mac_list if any as a part of the interface del/cleanup */
+void zebra_evpn_mac_ifp_del(struct interface *ifp)
+{
+	struct zebra_if *zif = ifp->info;
+	struct listnode *node;
+	struct zebra_mac *zmac;
+
+	if (zif->mac_list) {
+		if (IS_ZEBRA_DEBUG_EVPN_MH_MAC)
+			zlog_debug("MAC list deleted for ifp %s (%u)",
+				   zif->ifp->name, zif->ifp->ifindex);
+
+		for (ALL_LIST_ELEMENTS_RO(zif->mac_list, node, zmac)) {
+			zebra_evpn_mac_ifp_unlink(zmac);
+		}
+		list_delete(&zif->mac_list);
+	}
+}
+
 /* Link local mac to destination access port. This is done only if the
  * local mac is associated with a zero ESI i.e. single attach or lacp-bypass
  * bridge port member
