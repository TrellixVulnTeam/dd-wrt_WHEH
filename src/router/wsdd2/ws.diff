diff -urpN wsdd2.old/.git/FETCH_HEAD wsdd2/.git/FETCH_HEAD
diff -urpN wsdd2.old/.git/ORIG_HEAD wsdd2/.git/ORIG_HEAD
Binary files wsdd2.old/.git/index and wsdd2/.git/index differ
diff -urpN wsdd2.old/.git/logs/HEAD wsdd2/.git/logs/HEAD
diff -urpN wsdd2.old/.git/logs/refs/heads/master wsdd2/.git/logs/refs/heads/master
diff -urpN wsdd2.old/.git/logs/refs/remotes/origin/master wsdd2/.git/logs/refs/remotes/origin/master
Binary files wsdd2.old/.git/objects/pack/pack-dc2d6c76ca19ebe4fb4fb9c110e0694b3a22ffc6.idx and wsdd2/.git/objects/pack/pack-dc2d6c76ca19ebe4fb4fb9c110e0694b3a22ffc6.idx differ
Binary files wsdd2.old/.git/objects/pack/pack-dc2d6c76ca19ebe4fb4fb9c110e0694b3a22ffc6.pack and wsdd2/.git/objects/pack/pack-dc2d6c76ca19ebe4fb4fb9c110e0694b3a22ffc6.pack differ
diff -urpN wsdd2.old/.git/refs/heads/master wsdd2/.git/refs/heads/master
diff -urpN wsdd2.old/.git/refs/remotes/origin/master wsdd2/.git/refs/remotes/origin/master
diff -urpN wsdd2.old/.git/refs/tags/1.8.5 wsdd2/.git/refs/tags/1.8.5
diff -urpN wsdd2.old/.git/refs/tags/1.8.6 wsdd2/.git/refs/tags/1.8.6
diff -urpN wsdd2.old/.gitignore wsdd2/.gitignore
--- wsdd2.old/.gitignore	2021-02-18 14:59:20.992472515 +0700
+++ wsdd2/.gitignore	2021-11-29 14:22:49.857126999 +0700
@@ -1,6 +1,11 @@
 # Ignore compilation files
 *.o
 wsdd2
+nl_debug
 
 # Ignore archlinux build files
 archlinux/*.pkg.tar.*
+
+# ignore Code::Blocks IDE artifacts
+wsdd2.cbp
+wsdd2.depend
diff -urpN wsdd2.old/Makefile wsdd2/Makefile
--- wsdd2.old/Makefile	2021-02-18 14:59:20.992472515 +0700
+++ wsdd2/Makefile	2021-11-29 14:22:49.857126999 +0700
@@ -5,31 +5,31 @@
 #	Copyright (c) 2016 Hiro Sugawara
 #
 
-OBJFILES	= wsdd2.o wsd.o llmnr.o
-HEADERS		= wsdd.h wsd.h
-
-INSTALLPREFIX ?= $(PREFIX)/usr
-SBINDIR       ?= sbin
-MANDIR        ?= share/man
-LIBDIR        ?= lib
-
-SBININSTALLDIR = $(INSTALLPREFIX)/$(SBINDIR)
-MANINSTALLDIR = $(INSTALLPREFIX)/$(MANDIR)
-LIBINSTALLDIR = $(LIBDIR)
+CFLAGS        ?= -Wall -Wextra -g -O0
+LDFLAGS       ?= -g
+OBJFILES      = wsdd2.o wsd.o llmnr.o
+HEADERS       = wsdd.h wsd.h
+
+PREFIX  ?= /usr
+SBINDIR ?= $(PREFIX)/sbin
+MANDIR  ?= $(PREFIX)/share/man
+LIBDIR  ?= $(PREFIX)/lib
 
 all: wsdd2
 
-wsdd2: $(OBJFILES)
+nl_debug: CPPFLAGS+=-DMAIN
+nl_debug: nl_debug.c; $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@
 
-$(OBJFILES) : $(HEADERS) Makefile
+wsdd2: $(OBJFILES)
+$(OBJFILES): $(HEADERS) Makefile
 
 install: wsdd2
-	install -d $(DESTDIR)/$(SBININSTALLDIR)
-	install wsdd2 $(DESTDIR)/$(SBININSTALLDIR)
-	install -d $(DESTDIR)/$(MANINSTALLDIR)/man8
-	install wsdd2.8 $(DESTDIR)/$(MANINSTALLDIR)/man8/wsdd2.8
-	install -d $(DESTDIR)/$(LIBINSTALLDIR)/systemd/system
-	install -m 0644 wsdd2.service $(DESTDIR)/$(LIBINSTALLDIR)/systemd/system
+	install -d $(DESTDIR)$(SBINDIR)
+	install wsdd2 $(DESTDIR)$(SBINDIR)
+	install -d $(DESTDIR)$(MANDIR)/man8
+	install -m 0644 wsdd2.8 $(DESTDIR)$(MANDIR)/man8
+	install -d $(DESTDIR)$(LIBDIR)/systemd/system
+	install -m 0644 wsdd2.service $(DESTDIR)$(LIBDIR)/systemd/system
 
 clean:
-	rm -f wsdd2 $(OBJFILES)
+	rm -f wsdd2 nl_debug $(OBJFILES)
diff -urpN wsdd2.old/README.md wsdd2/README.md
--- wsdd2.old/README.md	2020-01-31 19:31:29.516885489 +0700
+++ wsdd2/README.md	2021-11-29 14:22:49.857126999 +0700
@@ -1,11 +1,30 @@
-# wsdd2 (1.8)
+# wsdd2 (1.8.x)
 WSD/LLMNR Discovery/Name Service Daemon
 
-NOTE: Consumed by this openwrt package:
+With Microsoft turning off SMB1 feature completely on Windows 10, any Samba shares on the
+local network become invisible to Windows 10 computers. That's due to the fact that SMB1 is
+required for Computer Browser service to function.
 
-https://github.com/openwrt/packages/tree/master/net/wsdd2
+Newer Windows systems can use WSD (Web Services for Devices) to discover shares hosted on
+other Windows computers while Linux systems normally utilize mNDS/DNS-SD for service discovery.
+Microsoft is moving to support mDNS/DNS-SD, but not yet there.
+
+The primary purpose of this project is to enable WSD on Samba servers so that network shares
+hosted on a Unix box can appear in Windows File Explorer / Network.
+
+NOTE: Make sure there is no firewall rule blocking WSD multicast address
+239.255.255.250 and ff02::c, protocol UDP port 3702. Unicast SOAP HTTP
+WS-Discovery responder listens on TCP port 3702.
 
-https://github.com/Andy2244/openwrt-extra/tree/master/wsdd2
+LLMNR responder listens on multicast 224.0.0.252 / ff02::1:3 UDP port 5355
+and unicast TCP port 5355.
 
+The original source code was taken from Netgear ReadyNAS OS v6.9.3 published at
+https://kb.netgear.com/2649/NETGEAR-Open-Source-Code-for-Programmers-GPL
+https://www.downloads.netgear.com/files/GPL/ReadyNASOS_V6.9.3_WW_src.zip
+
+Consumed by this openwrt package:
+https://github.com/openwrt/packages/tree/master/net/wsdd2
 
-Taken from ReadyNAS OS 6, https://kb.netgear.com/2649/NETGEAR-Open-Source-Code-for-Programmers-GPL :  https://www.downloads.netgear.com/files/GPL/ReadyNASOS_V6.9.3_WW_src.zip
+Consumed by this archlinux user repository package:
+https://aur.archlinux.org/packages/wsdd2/
diff -urpN wsdd2.old/archlinux/PKGBUILD wsdd2/archlinux/PKGBUILD
--- wsdd2.old/archlinux/PKGBUILD	2021-02-18 14:59:20.992472515 +0700
+++ wsdd2/archlinux/PKGBUILD	1970-01-01 07:00:00.000000000 +0700
@@ -1,22 +0,0 @@
-pkgname=wsdd2
-pkgver=1.8.1
-pkgrel=2
-url="https://github.com/Andy2244/wsdd2"
-pkgdesc="WSD/LLMNR Discovery/Name Service Daemon"
-arch=('x86_64' 'armv7h')
-license=('GPL3')
-
-build() {
-    cd ../..
-    make
-}
-
-package() {
-    cd ../..
-    make SBINDIR=bin \
-         LIBDIR=usr/lib \
-         DESTDIR="$pkgdir" install
-
-    # Patch systemd file since samba service is called smb on archlinux
-    patch -i $pkgdir/../../wsdd2.service.patch "$pkgdir/usr/lib/systemd/system/wsdd2.service"
-}
diff -urpN wsdd2.old/archlinux/wsdd2.service.patch wsdd2/archlinux/wsdd2.service.patch
--- wsdd2.old/archlinux/wsdd2.service.patch	2021-02-18 14:59:20.992472515 +0700
+++ wsdd2/archlinux/wsdd2.service.patch	1970-01-01 07:00:00.000000000 +0700
@@ -1,10 +0,0 @@
---- a/wsdd2.service
-+++ b/wsdd2.service
-@@ -1,6 +1,6 @@
- [Unit]
- Description=WSD/LLMNR Discovery/Name Service Daemon
--BindsTo=smbd.service
-+BindsTo=smb.service
- 
- [Service]
- ExecStart=/usr/sbin/wsdd2
diff -urpN wsdd2.old/llmnr.c wsdd2/llmnr.c
--- wsdd2.old/llmnr.c	2020-01-31 19:31:29.516885489 +0700
+++ wsdd2/llmnr.c	2021-11-29 14:22:49.857126999 +0700
@@ -1,11 +1,11 @@
 /*
    WSDD - Web Service Dynamic Discovery protocol server
-  
+
    LLMNR responder
 
-  	Copyright (c) 2016 NETGEAR
-  	Copyright (c) 2016 Hiro Sugawara
-  
+	Copyright (c) 2016 NETGEAR
+	Copyright (c) 2016 Hiro Sugawara
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
@@ -47,58 +47,49 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
-#include <arpa/inet.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
 
 #include "wsdd.h"
 
-/* set new debug class */
-#undef  DBGC_CLASS
-#define DBGC_CLASS wsdd_debug_level
+#include <stdio.h> // FILE, fopen(), fscanf(), snprintf()
+#include <stdlib.h> // realloc(), free()
+#include <unistd.h> // gethostname()
+#include <string.h> // memcpy(), strcat(), strdup()
+#include <errno.h> // errno, EINVAL
+#include <arpa/inet.h> // inet_ntop()
 
+#define DNS_TYPE_ANY	0x00FF
 #define DNS_TYPE_A	0x0001	/* rfc 1035 */
 #define DNS_TYPE_AAAA	0x001C	/* rfc 3596 */
 #define DNS_CLASS_IN	0x0001	/* rfc 1035 */
 
+#ifdef NL_DEBUG
 static void dumphex(const char *label, const void *p, size_t len)
 {
-	if (debug_L >= 3) {
-		FILE *pp = popen("od -t x1c", "w");
-		printf("%s", label);
-		if (pp) {
-			fwrite(p, len, 1, pp);
-			pclose(pp);
-		}
-	}
+	if (debug_L >= 5)
+		dump(p, len, 0, label);
 }
+#endif
 
-static int llmnr_send_response(struct endpoint *ep,
-				_saddr_t *sa,
-				const uint8_t *in, size_t inlen,
-				const char *myname)
+static int llmnr_send_response(struct endpoint *ep, _saddr_t *sa,
+				const uint8_t *in, size_t inlen)
 {
 	uint16_t qdcount, ancount, nscount;
 	uint16_t qtype, qclass;
-	char *in_name = NULL, in_label[64];
+	char *in_name, *out = NULL;
 	const uint8_t *in_name_p = NULL;
-	size_t in_name_len = 0, out_name_len = 0;
-	char *out = NULL;
+	size_t in_name_len, out_name_len = 0;
 	size_t answer_len = 0;
 	int ret;
 	_saddr_t ci;
-	socklen_t slen = (sa->ss.ss_family == AF_INET)
-				? sizeof sa->in
-				: sizeof sa->in6;
-
-	dumphex("LLMNR INPUT:\n", in, inlen);
-
+	socklen_t slen = (sa->ss.ss_family == AF_INET) ? sizeof sa->in : sizeof sa->in6;
+#ifdef NL_DEBUG
+	dumphex("LLMNR INPUT: ", in, inlen);
+#endif
 	if (connected_if(sa, &ci)) {
 		char buf[_ADDRSTRLEN];
-
-		DEBUG(1, L, "llmnr: connected_if: %s",
-			inet_ntop(sa->ss.ss_family, _SIN_ADDR(sa),
-					buf, sizeof buf));
+		DEBUG(1, L, "llmnr: connected_if: %s: %s",
+			inet_ntop(sa->ss.ss_family, _SIN_ADDR(sa), buf, sizeof buf),
+			strerror(errno));
 		return -1;
 	}
 
@@ -121,6 +112,7 @@ static int llmnr_send_response(struct en
 	 * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 	 */
 	errno = EINVAL;
+
 	/*
 	 * LLMNR packet format has a header of 12 bytes
 	 * plus at least 1 byte of question section
@@ -158,10 +150,9 @@ static int llmnr_send_response(struct en
 	 * check number of entries in question section (QDCOUNT)
 	 * it must be just one
 	 */
-	qdcount = (in[4]*256) + in[5];
+	qdcount = in[4] * 256 + in[5];
 	if (qdcount != 1) {
-		DEBUG(1, L, "llmnr: only a question entry allowed, found %u",
-			qdcount);
+		DEBUG(1, L, "llmnr: only one question entry allowed, found %u", qdcount);
 		return -1;
 	}
 
@@ -169,8 +160,8 @@ static int llmnr_send_response(struct en
 	 * check number of entries in answer and nameserver sections
 	 * must be zero in the request
 	 */
-	ancount = (in[6]*256) + in[7];
-	nscount = (in[8]*256) + in[9];
+	ancount = in[6] * 256 + in[7];
+	nscount = in[8] * 256 + in[9];
 	if (ancount > 0 || nscount > 0) {
 		DEBUG(1, L, "llmnr: number of answer and/or nameserver entries "
 			  "in query is invalid (ancount: %u, nscount: %u)",
@@ -179,6 +170,8 @@ static int llmnr_send_response(struct en
 	}
 
 	/* process all labels in question section */
+	in_name = strdup("");
+	in_name_len = 0;
 	in_name_p = &in[12];
 	while (*in_name_p > 0) {
 		/*
@@ -186,66 +179,85 @@ static int llmnr_send_response(struct en
 		 * see section 4.1.4 of RFC 1035
 		 */
 		if (*in_name_p >= 0xC0) {
-			DEBUG(1, L, "llmnr: message compression not "
-				  "supported");
+			DEBUG(1, L, "llmnr: message compression not supported");
 			free(in_name);
 			return -1;
 		}
 
-		/* process current label in question section */
-		memcpy(in_label, in_name_p+1, *in_name_p);
-		in_label[*in_name_p] = '\0';
-
 		/* append to the whole name */
-		in_name_len += *in_name_p + 1;
-		if (in_name) {
-			in_name = realloc(in_name,
-					strlen(in_name) + strlen(in_label) + 2);
-			strcat(in_name, ".");
-			strcat(in_name, in_label);
-		} else {
-			in_name = strdup(in_label);
+		in_name_len += *in_name_p + (*in_name ? 1 : 0); // '.' if not first
+
+		in_name = (char *) realloc(in_name, in_name_len + 1);
+		if (in_name == NULL) {
+			DEBUG(1, L, "llmnr: realloc() failed");
+			return -1;
 		}
+		if (*in_name) strcat(in_name, ".");
+		strncat(in_name, (const char *) in_name_p + 1, *in_name_p);
 
 		/* next label */
-		in_name_p += (*in_name_p + 1);
-		//memset(in_label, 0, sizeof(in_label));
+		in_name_p += *in_name_p + 1;
 	}
 
-	DEBUG(2, L, "llmnr: name in query %s (length: %zu)", in_name,
-		   in_name_len);
+	/* verify in_name_len */
+	if (in_name_len != strlen(in_name)) {
+		DEBUG(1, L, "llmnr: bad name length %ld != %ld", in_name_len, strlen(in_name));
+		free(in_name);
+		return -1;
+	}
+
+	char abuf[_ADDRSTRLEN];
+	DEBUG(2, L, "llmnr: name in query %s (length: %zu) from %s", in_name, in_name_len,
+		inet_ntop(sa->ss.ss_family, _SIN_ADDR(sa), abuf, sizeof(abuf)));
 
 	/*
 	 * this implementation only supports questions of type A
 	 * or AAAA
 	 */
-	qtype = in_name_p[1]*256 + in_name_p[2];
-	if (qtype != DNS_TYPE_A && qtype != DNS_TYPE_AAAA) {
-		DEBUG(1, L, "llmnr: record in question not of type A or AAAA");
+	qtype = in_name_p[1] * 256 + in_name_p[2];
+	if (qtype != DNS_TYPE_ANY && qtype != DNS_TYPE_A && qtype != DNS_TYPE_AAAA) {
+		DEBUG(1, L, "llmnr: record in question not of type ANY or A or AAAA: %#x", qtype);
 		free(in_name);
 		return -1;
 	}
 
 	/* this implementation only supports questions of class IN */
-	qclass = in_name_p[3]*256 + in_name_p[4];
+	qclass = in_name_p[3] * 256 + in_name_p[4];
 	if (qclass != DNS_CLASS_IN) {
 		DEBUG(1, L, "llmnr: record is not of class IN");
 		free(in_name);
 		return -1;
 	}
 
-	if (!in_name) {
-		DEBUG(1, L, "llmnr: could not get name");
-		return -1;
+	/* check whether we are authorized to resolve this query */
+
+	int found = 0;
+	if (!found && strlen(netbiosname) == in_name_len &&
+	    strncasecmp(netbiosname, in_name, in_name_len) == 0)
+		found = 1;
+
+	if (!found && hostname && strlen(hostname) == in_name_len &&
+	    strncasecmp(hostname, in_name, in_name_len) == 0)
+		found = 1;
+
+	for (const char **pp = &hostaliases; !found && pp != &netbiosaliases; pp = &netbiosaliases) {
+	        for (const char *pname = *pp; pname && *pname;) {
+			const char *pend = strchr(pname, ' ');
+			size_t plen = pend ? (size_t) (pend - pname) : strlen(pname);
+			if (plen == in_name_len &&
+                            strncasecmp(pname, in_name, in_name_len) == 0) {
+				found = 1;
+				break;
+			}
+			pname += plen;
+			while (*pname == ' ') pname++;
+		}
 	}
 
-	/* check whether we are authorize for resolving this query */
-	in_name_len = strlen(in_name);
-	if (strlen(myname) != in_name_len ||
-	    strncasecmp(myname, in_name, in_name_len)) {
-		DEBUG(2, L, "llmnr: not authoritative for name %s", in_name);
-		free(in_name);
-		return -1;
+	if (!found) {
+	    DEBUG(2, L, "llmnr: not authoritative for name %s", in_name);
+	    free(in_name);
+	    return -1;
 	}
 
 	free(in_name);
@@ -267,7 +279,6 @@ static int llmnr_send_response(struct en
 	if ((qtype == DNS_TYPE_A && sa->ss.ss_family == AF_INET6) ||
 	    (qtype == DNS_TYPE_AAAA && sa->ss.ss_family == AF_INET)) {
 		answer_len = 0;
-	} else
 	/*
 	 * according to RFC 1035, answer section size will be:
 	 * - 2 bytes for pointer a name in query section (we are using a
@@ -278,13 +289,12 @@ static int llmnr_send_response(struct en
 	 * - 2 bytes RDLENGTH ... up to here 12 bytes
 	 * - 4 bytes (AF_INET) or 16 bytes (AF_INET6) RDATA
 	 */
-	if (sa->ss.ss_family == AF_INET) {
+	} else if (sa->ss.ss_family == AF_INET) {
 		answer_len = 12 + sizeof(ci.in.sin_addr);
 	} else if (sa->ss.ss_family == AF_INET6) {
 		answer_len = 12 + sizeof(ci.in6.sin6_addr);
 	} else {
-		DEBUG(1, L, "llmnr: %s: %d", strerror(EAFNOSUPPORT),
-			sa->ss.ss_family);
+		DEBUG(1, L, "llmnr: %s: %d", strerror(EAFNOSUPPORT), sa->ss.ss_family);
 		return -1;
 	}
 
@@ -292,7 +302,7 @@ static int llmnr_send_response(struct en
 	 * allocate output buffer
 	 * size will be same one as incoming query plus the answer section
 	 */
-	out = calloc(inlen + answer_len, 1);
+	out = (char *) calloc(inlen + answer_len, 1);
 	if (out == NULL) {
 		DEBUG(0, L, "llmnr: no memory for output buffer");
 		return -1;
@@ -345,60 +355,55 @@ static int llmnr_send_response(struct en
 	out[out_name_len++] = 0x00;
 	out[out_name_len++] = 0x01;
 
-	/* TTL */
-	out[out_name_len++] = 0x00;
-	out[out_name_len++] = 0x00;
-	out[out_name_len++] = 0x00;
-	out[out_name_len++] = 0x00;
+	/* default TTL = 30: RFC 4795 2.8. RR TTL */
+	out[out_name_len++] = 0;
+	out[out_name_len++] = 0;
+	out[out_name_len++] = 0;
+	out[out_name_len++] = 30;
 
 	/* RDLENGTH and RDATA in answer section */
 	out[out_name_len++] = 0x00;
 
 	if (sa->ss.ss_family == AF_INET) {
 		size_t len = out[out_name_len++] = sizeof(ci.in.sin_addr);
-
 		memcpy(out + out_name_len, &ci.in.sin_addr, len);
 	} else {
 		size_t len = out[out_name_len++] = sizeof(ci.in6.sin6_addr);
-
 		memcpy(out + out_name_len, &ci.in6.sin6_addr, len);
 	}
 send:
-	dumphex("LLMNR OUTPUT:\n", out, inlen + answer_len);
-	ret = sendto(ep->sock, out, inlen + answer_len, 0,
-			(struct sockaddr *)sa, slen);
+#ifdef NL_DEBUG
+	dumphex("LLMNR OUTPUT: ", out, inlen + answer_len);
+#endif
+	ret = sendto(ep->sock, out, inlen + answer_len, 0, (struct sockaddr *)sa, slen);
+
 	free(out);
 	return ret;
 }
 
 int llmnr_init(struct endpoint *ep)
 {
+	(void) ep; // silent "unused" warning
 	return 0;
 }
 
 int llmnr_recv(struct endpoint *ep)
 {
-	uint8_t buf[10000];
+	uint8_t buf[9216+1]; // RFC 4795, Ethernet jumbo frame size
 	_saddr_t sa;
+
 	socklen_t slen = sizeof sa;
-	ssize_t len = recvfrom(ep->sock, buf, sizeof(buf)-1, 0,
-				(struct sockaddr *)&sa, &slen);
-	char name[HOST_NAME_MAX + 1];
+	ssize_t len = recvfrom(ep->sock, buf, sizeof(buf)-1, 0, (struct sockaddr *)&sa, &slen);
 
-	if (len > 0 && !gethostname(name, sizeof(name)-1)) {
+	if (len > 0) {
 		buf[len] = '\0';
-		llmnr_send_response(ep, &sa, buf, len, name);
+		llmnr_send_response(ep, &sa, buf, len);
 	}
 
 	return len;
 }
 
-int llmnr_timer(struct endpoint *ep)
-{
-	return 0;
-}
-
 void llmnr_exit(struct endpoint *ep)
 {
+	(void) ep; // silent "unused" warning
 }
-
diff -urpN wsdd2.old/nl_debug.c wsdd2/nl_debug.c
--- wsdd2.old/nl_debug.c	1970-01-01 07:00:00.000000000 +0700
+++ wsdd2/nl_debug.c	2021-11-29 14:22:49.857126999 +0700
@@ -0,0 +1,1342 @@
+// gcc -Wall -Wextra -g -O0 -DMAIN -o nl_debug nl_debug.c && ./nl_debug
+
+/*
+   Netlink debug functions
+
+   Copyright (C) Volodymyr Prodan 2021
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+//#define _GNU_SOURCE // avoid conflict of <net/if.h> with <linux/if.h>
+//#define _POSIX_C_SOURCE 200809
+
+#include "nl_debug.h" // WLAN_EID_SSID
+
+#include <stdio.h> // stdout, printf()
+#include <stdarg.h> // va_start(), ...
+#include <unistd.h> // getpid(), close()
+#include <string.h> // memset(), memcmp()
+#include <fcntl.h> // F_GETFL
+#include <ctype.h> // isprint()
+#include <errno.h> // errno
+#include <sys/socket.h> // struct sockaddr, PF_NETLINK
+#include <netinet/in.h> // struct sockaddr_in{,6}, in{,6}_addr, INET{,6}_ADDRSTRLEN
+#include <arpa/inet.h> // inet_ntop()
+#include <netdb.h> // getnameinfo()
+#include <net/if.h> // avoid conflict with <linux/if.h> included from <linux/wireless.h>
+#include <linux/if.h> // IFF_UP, ...
+#include <linux/wireless.h> // struct iw_event, SIOCGIWSCAN, ...
+#include <linux/netlink.h> // NETLINK_ROUTE
+#include <linux/rtnetlink.h> // RTM_GETADDR, IFA_ADDRESS, /usr/include/linux/if_addr.h
+
+#ifdef MAIN
+#define debugf(...) do { printf(__VA_ARGS__); putchar('\n'); } while (0)
+#else
+#include "wsdd.h" // LOG()
+#define debugf(...) LOG(LOG_DEBUG, "nl_debug: " __VA_ARGS__)
+#endif
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+#endif
+
+static char outbuf[4096];
+static int outlen = 0;
+
+static void outf(const char *fmt, ... ) __attribute__((format(printf, 1, 2)));
+
+void outf(const char *fmt, ...)
+{
+    char mbuf[1024], *lf;
+    int mbuflen;
+    va_list list;
+
+    va_start(list, fmt);
+    mbuflen = vsnprintf(mbuf, sizeof(mbuf), fmt, list);
+    va_end(list);
+
+    strncat(outbuf + outlen, mbuf, mbuflen);
+    lf = strchr(outbuf + outlen, '\n');
+    outlen += mbuflen;
+
+    while (lf != NULL) {
+        *lf = '\0';
+        debugf("%s", outbuf);
+        strcpy(outbuf, lf + 1);
+        outlen -= lf - outbuf + 1;
+        lf = strchr(outbuf, '\n');
+    }
+}
+
+void dump(const void *p, size_t len, unsigned long start, const char *prefix)
+{
+    const unsigned char *s = p;
+    for (size_t i = 0; i < len; i += 16) {
+        size_t j, blen = len - i > 16 ? 16 : len - i;
+        outf("%s[%08lx]", prefix, start + i);
+        for (j = 0; j < blen; j++) outf(" %02x", s[i+j]);
+        for (; j < 16; j++) outf("   ");
+        outf(" |");
+        for (j = 0; j < blen; j++) outf("%c", isprint(s[i+j]) ? s[i+j] : '.');
+        for (; j < 16; j++) outf(" ");
+        outf("|\n");
+    }
+}
+
+void dump_str(const void *p, size_t len)
+{
+    const unsigned char *s = p;
+    outf("\"");
+    for (size_t i = 0; i < len; i++) {
+        if (isprint(s[i]) && s[i] != '"') outf("%c", s[i]);
+        else outf("\\x%02x", s[i]);
+    }
+    outf("\"");
+}
+
+void dump_hex(const void *p, size_t len)
+{
+    const unsigned char *s = p;
+    for (size_t i = 0; i < len; i++) outf("%02x", s[i]);
+}
+
+static const char nlmsg_type_str[][16] = {
+    [NLMSG_NOOP]              = "NOOP",   /* Nothing       */
+    [NLMSG_ERROR]             = "ERROR",  /* Error         */
+    [NLMSG_DONE]              = "DONE",   /* End of a dump */
+    [NLMSG_OVERRUN]           = "OVERRUN",/* Data lost     */
+    [RTM_NEWLINK]             = "NEWLINK",
+    [RTM_DELLINK]             = "DELLINK",
+    [RTM_GETLINK]             = "GETLINK",
+    [RTM_SETLINK]             = "SETLINK",
+    [RTM_NEWADDR]             = "NEWADDR",
+    [RTM_DELADDR]             = "DELADDR",
+    [RTM_GETADDR]             = "GETADDR",
+    [RTM_NEWROUTE]            = "NEWROUTE",
+    [RTM_DELROUTE]            = "DELROUTE",
+    [RTM_GETROUTE]            = "GETROUTE",
+    [RTM_NEWNEIGH]            = "NEWNEIGH",
+    [RTM_DELNEIGH]            = "DELNEIGH",
+    [RTM_GETNEIGH]            = "GETNEIGH",
+    [RTM_NEWRULE]             = "NEWRULE",
+    [RTM_DELRULE]             = "DELRULE",
+    [RTM_GETRULE]             = "GETRULE",
+    [RTM_NEWQDISC]            = "NEWQDISC",
+    [RTM_DELQDISC]            = "DELQDISC",
+    [RTM_GETQDISC]            = "GETQDISC",
+    [RTM_NEWTCLASS]           = "NEWTCLASS",
+    [RTM_DELTCLASS]           = "DELTCLASS",
+    [RTM_GETTCLASS]           = "GETTCLASS",
+    [RTM_NEWTFILTER]          = "NEWTFILTER",
+    [RTM_DELTFILTER]          = "DELTFILTER",
+    [RTM_GETTFILTER]          = "GETTFILTER",
+    [RTM_NEWACTION]           = "NEWACTION",
+    [RTM_DELACTION]           = "DELACTION",
+    [RTM_GETACTION]           = "GETACTION",
+    [RTM_NEWPREFIX]           = "NEWPREFIX",
+    [RTM_GETMULTICAST]        = "GETMULTICAST",
+    [RTM_GETANYCAST]          = "GETANYCAST",
+    [RTM_NEWNEIGHTBL]         = "NEWNEIGHTBL",
+    [RTM_GETNEIGHTBL]         = "GETNEIGHTBL",
+    [RTM_SETNEIGHTBL]         = "SETNEIGHTBL",
+    [RTM_NEWNDUSEROPT]        = "NEWNDUSEROPT",
+    [RTM_NEWADDRLABEL]        = "NEWADDRLABEL",
+    [RTM_DELADDRLABEL]        = "DELADDRLABEL",
+    [RTM_GETADDRLABEL]        = "GETADDRLABEL",
+    [RTM_GETDCB]              = "GETDCB",
+    [RTM_SETDCB]              = "SETDCB",
+    [RTM_NEWNETCONF]          = "NEWNETCONF",
+    [RTM_DELNETCONF]          = "DELNETCONF",
+    [RTM_GETNETCONF]          = "GETNETCONF",
+    [RTM_NEWMDB]              = "NEWMDB",
+    [RTM_DELMDB]              = "DELMDB",
+    [RTM_GETMDB]              = "GETMDB",
+    [RTM_NEWNSID]             = "NEWNSID",
+    [RTM_DELNSID]             = "DELNSID",
+    [RTM_GETNSID]             = "GETNSID",
+    [RTM_NEWSTATS]            = "NEWSTATS",
+    [RTM_GETSTATS]            = "GETSTATS",
+    [RTM_NEWCACHEREPORT]      = "NEWCACHEREPORT",
+    [RTM_NEWCHAIN]            = "NEWCHAIN",
+    [RTM_DELCHAIN]            = "DELCHAIN",
+    [RTM_GETCHAIN]            = "GETCHAIN",
+    [RTM_NEWNEXTHOP]          = "NEWNEXTHOP",
+    [RTM_DELNEXTHOP]          = "DELNEXTHOP",
+    [RTM_GETNEXTHOP]          = "GETNEXTHOP",
+    [RTM_NEWLINKPROP]         = "NEWLINKPROP",
+    [RTM_DELLINKPROP]         = "DELLINKPROP",
+    [RTM_GETLINKPROP]         = "GETLINKPROP",
+    [RTM_NEWNVLAN]            = "NEWVLAN",
+    [RTM_DELVLAN]             = "DELVLAN",
+    [RTM_GETVLAN]             = "GETVLAN",
+};
+
+static const char ifla_rta_type_str[][32] = {
+    [IFLA_UNSPEC]            = "UNSPEC",
+    [IFLA_ADDRESS]           = "ADDRESS",
+    [IFLA_BROADCAST]         = "BROADCAST",
+    [IFLA_IFNAME]            = "IFNAME",
+    [IFLA_MTU]               = "MTU",
+    [IFLA_LINK]              = "LINK",
+    [IFLA_QDISC]             = "QDISC",
+    [IFLA_STATS]             = "STATS",
+    [IFLA_COST]              = "COST",
+    [IFLA_PRIORITY]          = "PRIORITY",
+    [IFLA_MASTER]            = "MASTER",
+    [IFLA_WIRELESS]          = "WIRELESS",              /* Wireless Extension event - see wireless.h */
+    [IFLA_PROTINFO]          = "PROTINFO",              /* Protocol specific information for a link */
+    [IFLA_TXQLEN]            = "TXQLEN",
+    [IFLA_MAP]               = "MAP",
+    [IFLA_WEIGHT]            = "WEIGHT",
+    [IFLA_OPERSTATE]         = "OPERSTATE",
+    [IFLA_LINKMODE]          = "LINKMODE",
+    [IFLA_LINKINFO]          = "LINKINFO",
+    [IFLA_NET_NS_PID]        = "NET_NS_PID",
+    [IFLA_IFALIAS]           = "IFALIAS",
+    [IFLA_NUM_VF]            = "NUM_VF",                /* Number of VFs if device is SR-IOV PF */
+    [IFLA_VFINFO_LIST]       = "VFINFO_LIST",
+    [IFLA_STATS64]           = "STATS64",
+    [IFLA_VF_PORTS]          = "VF_PORTS",
+    [IFLA_PORT_SELF]         = "PORT_SELF",
+    [IFLA_AF_SPEC]           = "AF_SPEC",
+    [IFLA_GROUP]             = "GROUP",         /* Group the device belongs to */
+    [IFLA_NET_NS_FD]         = "NET_NS_FD",
+    [IFLA_EXT_MASK]          = "EXT_MASK",              /* Extended info mask, VFs, etc */
+    [IFLA_PROMISCUITY]       = "PROMISCUITY",   /* Promiscuity count: > 0 means acts PROMISC */
+    [IFLA_NUM_TX_QUEUES]     = "NUM_TX_QUEUES",
+    [IFLA_NUM_RX_QUEUES]     = "NUM_RX_QUEUES",
+    [IFLA_CARRIER]           = "CARRIER",
+    [IFLA_PHYS_PORT_ID]      = "PHYS_PORT_ID",
+    [IFLA_CARRIER_CHANGES]   = "CARRIER_CHANGES",
+    [IFLA_PHYS_SWITCH_ID]    = "PHYS_SWITCH_ID",
+    [IFLA_LINK_NETNSID]      = "LINK_NETNSID",
+    [IFLA_PHYS_PORT_NAME]    = "PHYS_PORT_NAME",
+    [IFLA_PROTO_DOWN]        = "PROTO_DOWN",
+    [IFLA_GSO_MAX_SEGS]      = "GSO_MAX_SEGS",
+    [IFLA_GSO_MAX_SIZE]      = "GSO_MAX_SIZE",
+    [IFLA_PAD]               = "PAD",
+    [IFLA_XDP]               = "XDP",
+    [IFLA_EVENT]             = "EVENT",
+    [IFLA_NEW_NETNSID]       = "NEW_NETNSID",
+    [IFLA_TARGET_NETNSID]    = "TARGET_NETNSID",
+    [IFLA_CARRIER_UP_COUNT]  = "CARRIER_UP_COUNT",
+    [IFLA_CARRIER_DOWN_COUNT]= "CARRIER_DOWN_COUNT",
+    [IFLA_NEW_IFINDEX]       = "NEW_IFINDEX",
+    [IFLA_MIN_MTU]           = "MIN_MTU",
+    [IFLA_MAX_MTU]           = "MAX_MTU",
+    [IFLA_PROP_LIST]         = "PROP_LIST",
+    [IFLA_ALT_IFNAME]        = "ALT_IFNAME", /* Alternative ifname */
+    [IFLA_PERM_ADDRESS]      = "PERM_ADDRESS",
+    [IFLA_PROTO_DOWN_REASON] = "PROTO_DOWN_REASON",
+};
+
+static const char ifa_rta_type_str[][16] = {
+    [IFA_UNSPEC]             = "UNSPEC",
+    [IFA_ADDRESS]            = "ADDRESS",
+    [IFA_LOCAL]              = "LOCAL",
+    [IFA_LABEL]              = "LABEL",
+    [IFA_BROADCAST]          = "BROADCAST",
+    [IFA_ANYCAST]            = "ANYCAST",
+    [IFA_CACHEINFO]          = "CACHEINFO",
+    [IFA_MULTICAST]          = "MULTICAST",
+    [IFA_FLAGS]              = "FLAGS",
+    [IFA_RT_PRIORITY]        = "RT_PRIORITY",  /* u32, priority/metric for prefix route */
+    [IFA_TARGET_NETNSID]     = "TARGET_NETNSID",
+};
+
+static const char rtmsg_type_str[][16] = {
+    [RTN_UNSPEC]             = "UNSPEC",
+    [RTN_UNICAST]            = "UNICAST",       /* Gateway or direct route      */
+    [RTN_LOCAL]              = "LOCAL",         /* Accept locally               */
+    [RTN_BROADCAST]          = "BROADCAST",     /* Accept locally as broadcast, send as broadcast */
+    [RTN_ANYCAST]            = "ANYCAST",       /* Accept locally as broadcast, but send as unicast */
+    [RTN_MULTICAST]          = "MULTICAST",     /* Multicast route              */
+    [RTN_BLACKHOLE]          = "BLACKHOLE",     /* Drop                         */
+    [RTN_UNREACHABLE]        = "UNREACHABLE",   /* Destination is unreachable   */
+    [RTN_PROHIBIT]           = "PROHIBIT",      /* Administratively prohibited  */
+    [RTN_THROW]              = "THROW",         /* Not in this table            */
+    [RTN_NAT]                = "NAT",           /* Translate this address       */
+    [RTN_XRESOLVE]           = "XRESOLVE",      /* Use external resolver        */
+};
+
+static const char rtattr_type_str[][16] = {
+    [RTA_UNSPEC]             = "UNSPEC",
+    [RTA_DST]                = "DST",
+    [RTA_SRC]                = "SRC",
+    [RTA_IIF]                = "IIF",
+    [RTA_OIF]                = "OIF",
+    [RTA_GATEWAY]            = "GATEWAY",
+    [RTA_PRIORITY]           = "PRIORITY",
+    [RTA_PREFSRC]            = "PREFSRC",
+    [RTA_METRICS]            = "METRICS",
+    [RTA_MULTIPATH]          = "MULTIPATH",
+    [RTA_PROTOINFO]          = "PROTOINFO", /* no longer used */
+    [RTA_FLOW]               = "FLOW",
+    [RTA_CACHEINFO]          = "CACHEINFO",
+    [RTA_SESSION]            = "SESSION", /* no longer used */
+    [RTA_MP_ALGO]            = "MP_ALGO", /* no longer used */
+    [RTA_TABLE]              = "TABLE",
+    [RTA_MARK]               = "MARK",
+    [RTA_MFC_STATS]          = "MFC_STATS",
+    [RTA_VIA]                = "VIA",
+    [RTA_NEWDST]             = "NEWDST",
+    [RTA_PREF]               = "PREF",
+    [RTA_ENCAP_TYPE]         = "ENCAP_TYPE",
+    [RTA_ENCAP]              = "ENCAP",
+    [RTA_EXPIRES]            = "EXPIRES",
+    [RTA_PAD]                = "PAD",
+    [RTA_UID]                = "UID",
+    [RTA_TTL_PROPAGATE]      = "TTL_PROPAGATE",
+    [RTA_IP_PROTO]           = "IP_PROTO",
+    [RTA_SPORT]              = "SPORT",
+    [RTA_DPORT]              = "DPORT",
+    [RTA_NH_ID]              = "NH_ID",
+};
+
+static struct {
+    int flag;
+    const char *name;
+} ifa_flags_descr[] = {
+    { IFA_F_SECONDARY,       "SECONDARY" },
+    { IFA_F_NODAD,           "NODAD" },
+    { IFA_F_OPTIMISTIC,      "OPTIMISTIC" },
+    { IFA_F_DADFAILED,       "DADFAILED" },
+    { IFA_F_HOMEADDRESS,     "HOMEADDRESS" },
+    { IFA_F_DEPRECATED,      "DEPRECATED" },
+    { IFA_F_TENTATIVE,       "TENTATIVE" },
+    { IFA_F_PERMANENT,       "PERMANENT" },
+    { IFA_F_MANAGETEMPADDR,  "MANAGETEMPADDR" },
+    { IFA_F_NOPREFIXROUTE,   "NOPREFIXROUTE" },
+    { IFA_F_MCAUTOJOIN,      "MCAUTOJOIN" },
+    { IFA_F_STABLE_PRIVACY,  "STABLE_PRIVACY" },
+    { 0, "" },
+};
+
+static const char iw_event_cmd_str[][40] = {
+    [SIOCSIWCOMMIT-SIOCIWFIRST]	= "SIOCSIWCOMMIT",		/* Commit pending changes to driver */
+    [SIOCGIWNAME-SIOCIWFIRST]	= "SIOCGIWNAME",		/* get name == wireless protocol */
+        /* SIOCGIWNAME is used to verify the presence of Wireless Extensions.
+         * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
+         * Don't put the name of your driver there, it's useless. */
+    /* Basic operations */
+    [SIOCSIWNWID-SIOCIWFIRST]	= "SIOCSIWNWID",		/* set network id (pre-802.11) */
+    [SIOCGIWNWID-SIOCIWFIRST]	= "SIOCGIWNWID",		/* get network id (the cell) */
+    [SIOCSIWFREQ-SIOCIWFIRST]	= "SIOCSIWFREQ",		/* set channel/frequency (Hz) */
+    [SIOCGIWFREQ-SIOCIWFIRST]	= "SIOCGIWFREQ",		/* get channel/frequency (Hz) */
+    [SIOCSIWMODE-SIOCIWFIRST]	= "SIOCSIWMODE",		/* set operation mode */
+    [SIOCGIWMODE-SIOCIWFIRST]	= "SIOCGIWMODE",		/* get operation mode */
+    [SIOCSIWSENS-SIOCIWFIRST]	= "SIOCSIWSENS",		/* set sensitivity (dBm) */
+    [SIOCGIWSENS-SIOCIWFIRST]	= "SIOCGIWSENS",		/* get sensitivity (dBm) */
+    /* Informative stuff */
+    [SIOCSIWRANGE-SIOCIWFIRST]	= "SIOCSIWRANGE",		/* Unused */
+    [SIOCGIWRANGE-SIOCIWFIRST]	= "SIOCGIWRANGE",		/* Get range of parameters */
+    [SIOCSIWPRIV-SIOCIWFIRST]	= "SIOCSIWPRIV",		/* Unused */
+    [SIOCGIWPRIV-SIOCIWFIRST]	= "SIOCGIWPRIV",		/* get private ioctl interface info */
+    [SIOCSIWSTATS-SIOCIWFIRST]	= "SIOCSIWSTATS",		/* Unused */
+    [SIOCGIWSTATS-SIOCIWFIRST]	= "SIOCGIWSTATS",		/* Get /proc/net/wireless stats */
+        /* SIOCGIWSTATS is strictly used between user space and the kernel, and
+         * is never passed to the driver (i.e. the driver will never see it). */
+    /* Spy support (statistics per MAC address - used for Mobile IP support) */
+    [SIOCSIWSPY-SIOCIWFIRST]	= "SIOCSIWSPY",			/* set spy addresses */
+    [SIOCGIWSPY-SIOCIWFIRST]	= "SIOCGIWSPY",			/* get spy info (quality of link) */
+    [SIOCSIWTHRSPY-SIOCIWFIRST]	= "SIOCSIWTHRSPY",		/* set spy threshold (spy event) */
+    [SIOCGIWTHRSPY-SIOCIWFIRST]	= "SIOCGIWTHRSPY",		/* get spy threshold */
+    /* Access Point manipulation */
+    [SIOCSIWAP-SIOCIWFIRST]	= "SIOCSIWAP",			/* set access point MAC addresses */
+    [SIOCGIWAP-SIOCIWFIRST]	= "SIOCGIWAP",			/* get access point MAC addresses */
+    [SIOCGIWAPLIST-SIOCIWFIRST]	= "SIOCGIWAPLIST",		/* Deprecated in favor of scanning */
+    [SIOCSIWSCAN-SIOCIWFIRST]	= "SIOCSIWSCAN",		/* trigger scanning (list cells) */
+    [SIOCGIWSCAN-SIOCIWFIRST]	= "SIOCGIWSCAN",		/* get scanning results */
+    /* 802.11 specific support */
+    [SIOCSIWESSID-SIOCIWFIRST]	= "SIOCSIWESSID",		/* set ESSID (network name) */
+    [SIOCGIWESSID-SIOCIWFIRST]	= "SIOCGIWESSID",		/* get ESSID */
+    [SIOCSIWNICKN-SIOCIWFIRST]	= "SIOCSIWNICKN",		/* set node name/nickname */
+    [SIOCGIWNICKN-SIOCIWFIRST]	= "SIOCGIWNICKN",		/* get node name/nickname */
+        /* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit
+         * within the 'iwreq' structure, so we need to use the 'data' member to
+         * point to a string in user space, like it is done for RANGE... */
+    /* Other parameters useful in 802.11 and some other devices */
+    [SIOCSIWRATE-SIOCIWFIRST]	= "SIOCSIWRATE",		/* set default bit rate (bps) */
+    [SIOCGIWRATE-SIOCIWFIRST]	= "SIOCGIWRATE",		/* get default bit rate (bps) */
+    [SIOCSIWRTS-SIOCIWFIRST]	= "SIOCSIWRTS",		/* set RTS/CTS threshold (bytes) */
+    [SIOCGIWRTS-SIOCIWFIRST]	= "SIOCGIWRTS",		/* get RTS/CTS threshold (bytes) */
+    [SIOCSIWFRAG-SIOCIWFIRST]	= "SIOCSIWFRAG",		/* set fragmentation thr (bytes) */
+    [SIOCGIWFRAG-SIOCIWFIRST]	= "SIOCGIWFRAG",		/* get fragmentation thr (bytes) */
+    [SIOCSIWTXPOW-SIOCIWFIRST]	= "SIOCSIWTXPOW",		/* set transmit power (dBm) */
+    [SIOCGIWTXPOW-SIOCIWFIRST]	= "SIOCGIWTXPOW",		/* get transmit power (dBm) */
+    [SIOCSIWRETRY-SIOCIWFIRST]	= "SIOCSIWRETRY",		/* set retry limits and lifetime */
+    [SIOCGIWRETRY-SIOCIWFIRST]	= "SIOCGIWRETRY",		/* get retry limits and lifetime */
+    /* Encoding stuff (scrambling, hardware security, WEP...) */
+    [SIOCSIWENCODE-SIOCIWFIRST]	= "SIOCSIWENCODE",		/* set encoding token & mode */
+    [SIOCGIWENCODE-SIOCIWFIRST]	= "SIOCGIWENCODE",		/* get encoding token & mode */
+    /* Power saving stuff (power management, unicast and multicast) */
+    [SIOCSIWPOWER-SIOCIWFIRST]	= "SIOCSIWPOWER",		/* set Power Management settings */
+    [SIOCGIWPOWER-SIOCIWFIRST]	= "SIOCGIWPOWER",		/* get Power Management settings */
+    /* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).
+     * This ioctl uses struct iw_point and data buffer that includes IE id and len
+     * fields. More than one IE may be included in the request. Setting the generic
+     * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers
+     * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers
+     * are required to report the used IE as a wireless event, e.g., when
+     * associating with an AP. */
+    [SIOCSIWGENIE-SIOCIWFIRST]	= "SIOCSIWGENIE",		/* set generic IE */
+    [SIOCGIWGENIE-SIOCIWFIRST]	= "SIOCGIWGENIE",		/* get generic IE */
+    /* WPA : IEEE 802.11 MLME requests */
+    [SIOCSIWMLME-SIOCIWFIRST]	= "SIOCSIWMLME",		/* request MLME operation; uses struct iw_mlme */
+    /* WPA : Authentication mode parameters */
+    [SIOCSIWAUTH-SIOCIWFIRST]	= "SIOCSIWAUTH",		/* set authentication mode params */
+    [SIOCGIWAUTH-SIOCIWFIRST]	= "SIOCGIWAUTH",		/* get authentication mode params */
+    /* WPA : Extended version of encoding configuration */
+    [SIOCSIWENCODEEXT-SIOCIWFIRST] = "SIOCSIWENCODEEXT",		/* set encoding token & mode */
+    [SIOCGIWENCODEEXT-SIOCIWFIRST] = "SIOCGIWENCODEEXT",		/* get encoding token & mode */
+    /* WPA2 : PMKSA cache management */
+    [SIOCSIWPMKSA-SIOCIWFIRST]	= "SIOCSIWPMKSA",		/* PMKSA cache operation */
+
+    /* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
+
+    /* These 32 ioctl are wireless device private, for 16 commands.
+     * Each driver is free to use them for whatever purpose it chooses,
+     * however the driver *must* export the description of those ioctls
+     * with SIOCGIWPRIV and *must* use arguments as defined below.
+     * If you don't follow those rules, DaveM is going to hate you (reason :
+     * it make mixed 32/64bit operation impossible).
+     */
+    [SIOCIWFIRSTPRIV-SIOCIWFIRST]	= "SIOCIWFIRSTPRIV",
+    [SIOCIWLASTPRIV-SIOCIWFIRST]	= "SIOCIWLASTPRIV",
+    /* Previously, we were using SIOCDEVPRIVATE, but we now have our
+     * separate range because of collisions with other tools such as
+     * 'mii-tool'.
+     * We now have 32 commands, so a bit more space ;-).
+     * Also, all 'even' commands are only usable by root and don't return the
+     * content of ifr/iwr to user (but you are not obliged to use the set/get
+     * convention, just use every other two command). More details in iwpriv.c.
+     * And I repeat : you are not forced to use them with iwpriv, but you
+     * must be compliant with it.
+     */
+
+    /* ----------------------- WIRELESS EVENTS ----------------------- */
+    /* Those are *NOT* ioctls, do not issue request on them !!! */
+    /* Most events use the same identifier as ioctl requests */
+
+    [IWEVTXDROP-SIOCIWFIRST]	= "IWEVTXDROP",		/* Packet dropped to excessive retry */
+    [IWEVQUAL-SIOCIWFIRST]	= "IWEVQUAL",		/* Quality part of statistics (scan) */
+    [IWEVCUSTOM-SIOCIWFIRST]	= "IWEVCUSTOM",		/* Driver specific ascii string */
+    [IWEVREGISTERED-SIOCIWFIRST]= "IWEVREGISTERED",	/* Discovered a new node (AP mode) */
+    [IWEVEXPIRED-SIOCIWFIRST]	= "IWEVEXPIRED",	/* Expired a node (AP mode) */
+    [IWEVGENIE-SIOCIWFIRST]	= "IWEVGENIE",		/* Generic IE (WPA, RSN, WMM, ..) (scan results); This includes id and
+                                                 * length fields. One IWEVGENIE may contain more than one IE. Scan
+                                                 * results may contain one or more IWEVGENIE events. */
+    [IWEVMICHAELMICFAILURE-SIOCIWFIRST] = "IWEVMICHAELMICFAILURE",	/* Michael MIC failure (struct iw_michaelmicfailure) */
+    [IWEVASSOCREQIE-SIOCIWFIRST]	= "IWEVASSOCREQIE",		/* IEs used in (Re)Association Request.
+                                             * The data includes id and length
+                                             * fields and may contain more than one
+                                             * IE. This event is required in
+                                             * Managed mode if the driver
+                                             * generates its own WPA/RSN IE. This
+                                             * should be sent just before
+                                             * IWEVREGISTERED event for the
+                                             * association. */
+    [IWEVASSOCRESPIE-SIOCIWFIRST]	= "IWEVASSOCRESPIE",		/* IEs used in (Re)Association
+                                             * Response. The data includes id and
+                                             * length fields and may contain more
+                                             * than one IE. This may be sent
+                                             * between IWEVASSOCREQIE and
+                                             * IWEVREGISTERED events for the
+                                             * association. */
+    [IWEVPMKIDCAND-SIOCIWFIRST]		= "IWEVPMKIDCAND",		/* PMKID candidate for RSN
+                                             * pre-authentication
+                                             * (struct iw_pmkid_cand) */
+};
+
+/* WLAN IE: Information Elements */
+
+struct wlan_ie {
+    u8 id;
+    u8 len;
+    u8 data[];
+} STRUCT_PACKED;
+
+struct wlan_ies { // struct iw_point without void *pointer;
+    u16 len; /* number of fields or size in bytes */
+    u16 flags; /* Optional params */
+    struct wlan_ie ies[];
+};
+
+/* Information Element IDs (IEEE Std 802.11-2016, 9.4.2.1, Table 9-77) */
+/* see aircrack-ng/third-party/ieee80211.h and hostap-git/src/common/ieee802_11_defs.h */
+
+static const char wlan_eid_str[][40] = { // max len(EID_VHT_OPERATING_MODE_NOTIFICATION) = 36
+    [WLAN_EID_SSID] = "EID_SSID",
+    [WLAN_EID_SUPP_RATES] = "EID_SUPP_RATES",
+    [WLAN_EID_DS_PARAMS] = "EID_DS_PARAMS",
+    [WLAN_EID_CF_PARAMS] = "EID_CF_PARAMS",
+    [WLAN_EID_TIM] = "EID_TIM",
+    [WLAN_EID_IBSS_PARAMS] = "EID_IBSS_PARAMS",
+    [WLAN_EID_COUNTRY] = "EID_COUNTRY",
+    [WLAN_EID_REQUEST] = "EID_REQUEST",
+    [WLAN_EID_BSS_LOAD] = "EID_BSS_LOAD",
+    [WLAN_EID_EDCA_PARAM_SET] = "EID_EDCA_PARAM_SET",
+    [WLAN_EID_TSPEC] = "EID_TSPEC",
+    [WLAN_EID_TCLAS] = "EID_TCLAS",
+    [WLAN_EID_SCHEDULE] = "EID_SCHEDULE",
+    [WLAN_EID_CHALLENGE] = "EID_CHALLENGE",
+    [WLAN_EID_CHALLENGE+1] = "EID_CHALLENGE17", /* 17-31 reserved for challenge text extension */
+    [WLAN_EID_CHALLENGE+2] = "EID_CHALLENGE18",
+    [WLAN_EID_CHALLENGE+3] = "EID_CHALLENGE19",
+    [WLAN_EID_CHALLENGE+4] = "EID_CHALLENGE20",
+    [WLAN_EID_CHALLENGE+5] = "EID_CHALLENGE21",
+    [WLAN_EID_CHALLENGE+6] = "EID_CHALLENGE22",
+    [WLAN_EID_CHALLENGE+7] = "EID_CHALLENGE23",
+    [WLAN_EID_CHALLENGE+8] = "EID_CHALLENGE24",
+    [WLAN_EID_CHALLENGE+9] = "EID_CHALLENGE25",
+    [WLAN_EID_CHALLENGE+10] = "EID_CHALLENGE26",
+    [WLAN_EID_CHALLENGE+11] = "EID_CHALLENGE27",
+    [WLAN_EID_CHALLENGE+12] = "EID_CHALLENGE28",
+    [WLAN_EID_CHALLENGE+13] = "EID_CHALLENGE29",
+    [WLAN_EID_CHALLENGE+14] = "EID_CHALLENGE30",
+    [WLAN_EID_CHALLENGE+15] = "EID_CHALLENGE31",
+    [WLAN_EID_PWR_CONSTRAINT] = "EID_PWR_CONSTRAINT",
+    [WLAN_EID_PWR_CAPABILITY] = "EID_PWR_CAPABILITY",
+    [WLAN_EID_TPC_REQUEST] = "EID_TPC_REQUEST",
+    [WLAN_EID_TPC_REPORT] = "EID_TPC_REPORT",
+    [WLAN_EID_SUPPORTED_CHANNELS] = "EID_SUPPORTED_CHANNELS",
+    [WLAN_EID_CHANNEL_SWITCH] = "EID_CHANNEL_SWITCH",
+    [WLAN_EID_MEASURE_REQUEST] = "EID_MEASURE_REQUEST",
+    [WLAN_EID_MEASURE_REPORT] = "EID_MEASURE_REPORT",
+    [WLAN_EID_QUIET] = "EID_QUIET",
+    [WLAN_EID_IBSS_DFS] = "EID_IBSS_DFS",
+    [WLAN_EID_ERP_INFO] = "EID_ERP_INFO",
+    [WLAN_EID_TS_DELAY] = "EID_TS_DELAY",
+    [WLAN_EID_TCLAS_PROCESSING] = "EID_TCLAS_PROCESSING",
+    [WLAN_EID_HT_CAP] = "EID_HT_CAP",
+    [WLAN_EID_QOS] = "EID_QOS",
+    [WLAN_EID_RSN] = "EID_RSN",
+    [WLAN_EID_EXT_SUPP_RATES] = "EID_EXT_SUPP_RATES",
+    [WLAN_EID_AP_CHANNEL_REPORT] = "EID_AP_CHANNEL_REPORT",
+    [WLAN_EID_NEIGHBOR_REPORT] = "EID_NEIGHBOR_REPORT",
+    [WLAN_EID_RCPI] = "EID_RCPI",
+    [WLAN_EID_MOBILITY_DOMAIN] = "EID_MOBILITY_DOMAIN",
+    [WLAN_EID_FAST_BSS_TRANSITION] = "EID_FAST_BSS_TRANSITION",
+    [WLAN_EID_TIMEOUT_INTERVAL] = "EID_TIMEOUT_INTERVAL",
+    [WLAN_EID_RIC_DATA] = "EID_RIC_DATA",
+    [WLAN_EID_DSE_REGISTERED_LOCATION] = "EID_DSE_REGISTERED_LOCATION",
+    [WLAN_EID_SUPPORTED_OPERATING_CLASSES] = "EID_SUPPORTED_OPERATING_CLASSES",
+    [WLAN_EID_EXT_CHANSWITCH_ANN] = "EID_EXT_CHANSWITCH_ANN",
+    [WLAN_EID_HT_OPERATION] = "EID_HT_OPERATION",
+    [WLAN_EID_SECONDARY_CHANNEL_OFFSET] = "EID_SECONDARY_CHANNEL_OFFSET",
+    [WLAN_EID_BSS_AVERAGE_ACCESS_DELAY] = "EID_BSS_AVERAGE_ACCESS_DELAY",
+    [WLAN_EID_ANTENNA] = "EID_ANTENNA",
+    [WLAN_EID_RSNI] = "EID_RSNI",
+    [WLAN_EID_MEASUREMENT_PILOT_TRANSMISSION] = "EID_MEASUREMENT_PILOT_TRANSMISSION",
+    [WLAN_EID_BSS_AVAILABLE_ADM_CAPA] = "EID_BSS_AVAILABLE_ADM_CAPA",
+    [WLAN_EID_BSS_AC_ACCESS_DELAY] = "EID_BSS_AC_ACCESS_DELAY", /* note: also used by WAPI */
+    [WLAN_EID_TIME_ADVERTISEMENT] = "EID_TIME_ADVERTISEMENT",
+    [WLAN_EID_RRM_ENABLED_CAPABILITIES] = "EID_RRM_ENABLED_CAPABILITIES",
+    [WLAN_EID_MULTIPLE_BSSID] = "EID_MULTIPLE_BSSID",
+    [WLAN_EID_20_40_BSS_COEXISTENCE] = "EID_20_40_BSS_COEXISTENCE",
+    [WLAN_EID_20_40_BSS_INTOLERANT] = "EID_20_40_BSS_INTOLERANT",
+    [WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS] = "EID_OVERLAPPING_BSS_SCAN_PARAMS",
+    [WLAN_EID_RIC_DESCRIPTOR] = "EID_RIC_DESCRIPTOR",
+    [WLAN_EID_MMIE] = "EID_MMIE",
+    [WLAN_EID_EVENT_REQUEST] = "EID_EVENT_REQUEST",
+    [WLAN_EID_EVENT_REPORT] = "EID_EVENT_REPORT",
+    [WLAN_EID_DIAGNOSTIC_REQUEST] = "EID_DIAGNOSTIC_REQUEST",
+    [WLAN_EID_DIAGNOSTIC_REPORT] = "EID_DIAGNOSTIC_REPORT",
+    [WLAN_EID_LOCATION_PARAMETERS] = "EID_LOCATION_PARAMETERS",
+    [WLAN_EID_NONTRANSMITTED_BSSID_CAPA] = "EID_NONTRANSMITTED_BSSID_CAPA",
+    [WLAN_EID_SSID_LIST] = "EID_SSID_LIST",
+    [WLAN_EID_MULTIPLE_BSSID_INDEX] = "EID_MULTIPLE_BSSID_INDEX",
+    [WLAN_EID_FMS_DESCRIPTOR] = "EID_FMS_DESCRIPTOR",
+    [WLAN_EID_FMS_REQUEST] = "EID_FMS_REQUEST",
+    [WLAN_EID_FMS_RESPONSE] = "EID_FMS_RESPONSE",
+    [WLAN_EID_QOS_TRAFFIC_CAPABILITY] = "EID_QOS_TRAFFIC_CAPABILITY",
+    [WLAN_EID_BSS_MAX_IDLE_PERIOD] = "EID_BSS_MAX_IDLE_PERIOD",
+    [WLAN_EID_TFS_REQ] = "EID_TFS_REQ",
+    [WLAN_EID_TFS_RESP] = "EID_TFS_RESP",
+    [WLAN_EID_WNMSLEEP] = "EID_WNMSLEEP",
+    [WLAN_EID_TIM_BROADCAST_REQUEST] = "EID_TIM_BROADCAST_REQUEST",
+    [WLAN_EID_TIM_BROADCAST_RESPONSE] = "EID_TIM_BROADCAST_RESPONSE",
+    [WLAN_EID_COLLOCATED_INTERFERENCE_REPORT] = "EID_COLLOCATED_INTERFERENCE_REPORT",
+    [WLAN_EID_CHANNEL_USAGE] = "EID_CHANNEL_USAGE",
+    [WLAN_EID_TIME_ZONE] = "EID_TIME_ZONE",
+    [WLAN_EID_DMS_REQUEST] = "EID_DMS_REQUEST",
+    [WLAN_EID_DMS_RESPONSE] = "EID_DMS_RESPONSE",
+    [WLAN_EID_LINK_ID] = "EID_LINK_ID",
+    [WLAN_EID_WAKEUP_SCHEDULE] = "EID_WAKEUP_SCHEDULE",
+    [WLAN_EID_CHANNEL_SWITCH_TIMING] = "EID_CHANNEL_SWITCH_TIMING",
+    [WLAN_EID_PTI_CONTROL] = "EID_PTI_CONTROL",
+    [WLAN_EID_TPU_BUFFER_STATUS] = "EID_TPU_BUFFER_STATUS",
+    [WLAN_EID_INTERWORKING] = "EID_INTERWORKING",
+    [WLAN_EID_ADV_PROTO] = "EID_ADV_PROTO",
+    [WLAN_EID_EXPEDITED_BANDWIDTH_REQ] = "EID_EXPEDITED_BANDWIDTH_REQ",
+    [WLAN_EID_QOS_MAP_SET] = "EID_QOS_MAP_SET",
+    [WLAN_EID_ROAMING_CONSORTIUM] = "EID_ROAMING_CONSORTIUM",
+    [WLAN_EID_EMERGENCY_ALERT_ID] = "EID_EMERGENCY_ALERT_ID",
+    [WLAN_EID_MESH_CONFIG] = "EID_MESH_CONFIG",
+    [WLAN_EID_MESH_ID] = "EID_MESH_ID",
+    [WLAN_EID_MESH_LINK_METRIC_REPORT] = "EID_MESH_LINK_METRIC_REPORT",
+    [WLAN_EID_CONGESTION_NOTIFICATION] = "EID_CONGESTION_NOTIFICATION",
+    [WLAN_EID_PEER_MGMT] = "EID_PEER_MGMT",
+    [WLAN_EID_MESH_CHANNEL_SWITCH_PARAMETERS] = "EID_MESH_CHANNEL_SWITCH_PARAMETERS",
+    [WLAN_EID_MESH_AWAKE_WINDOW] = "EID_MESH_AWAKE_WINDOW",
+    [WLAN_EID_BEACON_TIMING] = "EID_BEACON_TIMING",
+    [WLAN_EID_MCCAOP_SETUP_REQUEST] = "EID_MCCAOP_SETUP_REQUEST",
+    [WLAN_EID_MCCAOP_SETUP_REPLY] = "EID_MCCAOP_SETUP_REPLY",
+    [WLAN_EID_MCCAOP_ADVERTISEMENT] = "EID_MCCAOP_ADVERTISEMENT",
+    [WLAN_EID_MCCAOP_TEARDOWN] = "EID_MCCAOP_TEARDOWN",
+    [WLAN_EID_GANN] = "EID_GANN",
+    [WLAN_EID_RANN] = "EID_RANN",
+    [WLAN_EID_EXT_CAPAB] = "EID_EXT_CAPAB",
+    [WLAN_EID_PREQ] = "EID_PREQ",
+    [WLAN_EID_PREP] = "EID_PREP",
+    [WLAN_EID_PERR] = "EID_PERR",
+    [WLAN_EID_PXU] = "EID_PXU",
+    [WLAN_EID_PXUC] = "EID_PXUC",
+    [WLAN_EID_AMPE] = "EID_AMPE",
+    [WLAN_EID_MIC] = "EID_MIC",
+    [WLAN_EID_DESTINATION_URI] = "EID_DESTINATION_URI",
+    [WLAN_EID_U_APSD_COEX] = "EID_U_APSD_COEX",
+    [WLAN_EID_DMG_WAKEUP_SCHEDULE] = "EID_DMG_WAKEUP_SCHEDULE",
+    [WLAN_EID_EXTENDED_SCHEDULE] = "EID_EXTENDED_SCHEDULE",
+    [WLAN_EID_STA_AVAILABILITY] = "EID_STA_AVAILABILITY",
+    [WLAN_EID_DMG_TSPEC] = "EID_DMG_TSPEC",
+    [WLAN_EID_NEXT_DMG_ATI] = "EID_NEXT_DMG_ATI",
+    [WLAN_EID_DMG_CAPABILITIES] = "EID_DMG_CAPABILITIES",
+    [WLAN_EID_DMG_OPERATION] = "EID_DMG_OPERATION",
+    [WLAN_EID_DMG_BSS_PARAMETER_CHANGE] = "EID_DMG_BSS_PARAMETER_CHANGE",
+    [WLAN_EID_DMG_BEAM_REFINEMENT] = "EID_DMG_BEAM_REFINEMENT",
+    [WLAN_EID_CHANNEL_MEASUREMENT_FEEDBACK] = "EID_CHANNEL_MEASUREMENT_FEEDBACK",
+    [WLAN_EID_CCKM] = "EID_CCKM",
+    [WLAN_EID_AWAKE_WINDOW] = "EID_AWAKE_WINDOW",
+    [WLAN_EID_MULTI_BAND] = "EID_MULTI_BAND",
+    [WLAN_EID_ADDBA_EXTENSION] = "EID_ADDBA_EXTENSION",
+    [WLAN_EID_NEXTPCP_LIST] = "EID_NEXTPCP_LIST",
+    [WLAN_EID_PCP_HANDOVER] = "EID_PCP_HANDOVER",
+    [WLAN_EID_DMG_LINK_MARGIN] = "EID_DMG_LINK_MARGIN",
+    [WLAN_EID_SWITCHING_STREAM] = "EID_SWITCHING_STREAM",
+    [WLAN_EID_SESSION_TRANSITION] = "EID_SESSION_TRANSITION",
+    [WLAN_EID_DYNAMIC_TONE_PAIRING_REPORT] = "EID_DYNAMIC_TONE_PAIRING_REPORT",
+    [WLAN_EID_CLUSTER_REPORT] = "EID_CLUSTER_REPORT",
+    [WLAN_EID_REPLAY_CAPABILITIES] = "EID_REPLAY_CAPABILITIES",
+    [WLAN_EID_RELAY_TRANSFER_PARAM_SET] = "EID_RELAY_TRANSFER_PARAM_SET",
+    [WLAN_EID_BEAMLINK_MAINTENANCE] = "EID_BEAMLINK_MAINTENANCE",
+    [WLAN_EID_MULTIPLE_MAC_SUBLAYERS] = "EID_MULTIPLE_MAC_SUBLAYERS",
+    [WLAN_EID_U_PID] = "EID_U_PID",
+    [WLAN_EID_DMG_LINK_ADAPTATION_ACK] = "EID_DMG_LINK_ADAPTATION_ACK",
+    [WLAN_EID_MCCAOP_ADVERTISEMENT_OVERVIEW] = "EID_MCCAOP_ADVERTISEMENT_OVERVIEW",
+    [WLAN_EID_QUIET_PERIOD_REQUEST] = "EID_QUIET_PERIOD_REQUEST",
+    [WLAN_EID_QUIET_PERIOD_RESPONSE] = "EID_QUIET_PERIOD_RESPONSE",
+    [WLAN_EID_QMF_POLICY] = "EID_QMF_POLICY",
+    [WLAN_EID_ECAPC_POLICY] = "EID_ECAPC_POLICY",
+    [WLAN_EID_CLUSTER_TIME_OFFSET] = "EID_CLUSTER_TIME_OFFSET",
+    [WLAN_EID_INTRA_ACCESS_CATEGORY_PRIORITY] = "EID_INTRA_ACCESS_CATEGORY_PRIORITY",
+    [WLAN_EID_SCS_DESCRIPTOR] = "EID_SCS_DESCRIPTOR",
+    [WLAN_EID_QLOAD_REPORT] = "EID_QLOAD_REPORT",
+    [WLAN_EID_HCCA_TXOP_UPDATE_COUNT] = "EID_HCCA_TXOP_UPDATE_COUNT",
+    [WLAN_EID_HIGHER_LAYER_STREAM_ID] = "EID_HIGHER_LAYER_STREAM_ID",
+    [WLAN_EID_GCR_GROUP_ADDRESS] = "EID_GCR_GROUP_ADDRESS",
+    [WLAN_EID_ANTENNA_SECTOR_ID_PATTERN] = "EID_ANTENNA_SECTOR_ID_PATTERN",
+    [WLAN_EID_VHT_CAP] = "EID_VHT_CAP",
+    [WLAN_EID_VHT_OPERATION] = "EID_VHT_OPERATION",
+    [WLAN_EID_VHT_EXTENDED_BSS_LOAD] = "EID_VHT_EXTENDED_BSS_LOAD",
+    [WLAN_EID_VHT_WIDE_BW_CHSWITCH] = "EID_VHT_WIDE_BW_CHSWITCH",
+    [WLAN_EID_VHT_TRANSMIT_POWER_ENVELOPE] = "EID_VHT_TRANSMIT_POWER_ENVELOPE",
+    [WLAN_EID_VHT_CHANNEL_SWITCH_WRAPPER] = "EID_VHT_CHANNEL_SWITCH_WRAPPER",
+    [WLAN_EID_VHT_AID] = "EID_VHT_AID",
+    [WLAN_EID_VHT_QUIET_CHANNEL] = "EID_VHT_QUIET_CHANNEL",
+    [WLAN_EID_VHT_OPERATING_MODE_NOTIFICATION] = "EID_VHT_OPERATING_MODE_NOTIFICATION",
+    [WLAN_EID_UPSIM] = "EID_UPSIM",
+    [WLAN_EID_REDUCED_NEIGHBOR_REPORT] = "EID_REDUCED_NEIGHBOR_REPORT",
+    [WLAN_EID_TVHT_OPERATION] = "EID_TVHT_OPERATION",
+    [WLAN_EID_DEVICE_LOCATION] = "EID_DEVICE_LOCATION",
+    [WLAN_EID_WHITE_SPACE_MAP] = "EID_WHITE_SPACE_MAP",
+    [WLAN_EID_FTM_PARAMETERS] = "EID_FTM_PARAMETERS",
+    [WLAN_EID_VENDOR_SPECIFIC] = "EID_VENDOR_SPECIFIC",
+    [WLAN_EID_CAG_NUMBER] = "EID_CAG_NUMBER",
+    [WLAN_EID_AP_CSN] = "EID_AP_CSN",
+    [WLAN_EID_FILS_INDICATION] = "EID_FILS_INDICATION",
+    [WLAN_EID_DILS] = "EID_DILS",
+    [WLAN_EID_FRAGMENT] = "EID_FRAGMENT",
+    [WLAN_EID_RSNX] = "EID_RSNX",
+    [WLAN_EID_EXTENSION] = "EID_EXTENSION",
+};
+
+static const char wlan_eid_ext_str[][40] = { // max len(EID_VHT_OPERATING_MODE_NOTIFICATION) = 36
+    /* Element ID Extension (EID 255) values */
+    [WLAN_EID_EXT_ASSOC_DELAY_INFO] = "EID_EXT_ASSOC_DELAY_INFO",
+    [WLAN_EID_EXT_FILS_REQ_PARAMS] = "EID_EXT_FILS_REQ_PARAMS",
+    [WLAN_EID_EXT_FILS_KEY_CONFIRM] = "EID_EXT_FILS_KEY_CONFIRM",
+    [WLAN_EID_EXT_FILS_SESSION] = "EID_EXT_FILS_SESSION",
+    [WLAN_EID_EXT_FILS_HLP_CONTAINER] = "EID_EXT_FILS_HLP_CONTAINER",
+    [WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN] = "EID_EXT_FILS_IP_ADDR_ASSIGN",
+    [WLAN_EID_EXT_KEY_DELIVERY] = "EID_EXT_KEY_DELIVERY",
+    [WLAN_EID_EXT_WRAPPED_DATA] = "EID_EXT_WRAPPED_DATA",
+    [WLAN_EID_EXT_FTM_SYNC_INFO] = "EID_EXT_FTM_SYNC_INFO",
+    [WLAN_EID_EXT_EXTENDED_REQUEST] = "EID_EXT_EXTENDED_REQUEST",
+    [WLAN_EID_EXT_ESTIMATED_SERVICE_PARAMS] = "EID_EXT_ESTIMATED_SERVICE_PARAMS",
+    [WLAN_EID_EXT_FILS_PUBLIC_KEY] = "EID_EXT_FILS_PUBLIC_KEY",
+    [WLAN_EID_EXT_FILS_NONCE] = "EID_EXT_FILS_NONCE",
+    [WLAN_EID_EXT_FUTURE_CHANNEL_GUIDANCE] = "EID_EXT_FUTURE_CHANNEL_GUIDANCE",
+    [WLAN_EID_EXT_OWE_DH_PARAM] = "EID_EXT_OWE_DH_PARAM",
+    [WLAN_EID_EXT_PASSWORD_IDENTIFIER] = "EID_EXT_PASSWORD_IDENTIFIER",
+    [WLAN_EID_EXT_HE_CAPABILITIES] = "EID_EXT_HE_CAPABILITIES",
+    [WLAN_EID_EXT_HE_OPERATION] = "EID_EXT_HE_OPERATION",
+    [WLAN_EID_EXT_HE_MU_EDCA_PARAMS] = "EID_EXT_HE_MU_EDCA_PARAMS",
+    [WLAN_EID_EXT_SPATIAL_REUSE] = "EID_EXT_SPATIAL_REUSE",
+    [WLAN_EID_EXT_OCV_OCI] = "EID_EXT_OCV_OCI",
+    [WLAN_EID_EXT_SHORT_SSID_LIST] = "EID_EXT_SHORT_SSID_LIST",
+    [WLAN_EID_EXT_HE_6GHZ_BAND_CAP] = "EID_EXT_HE_6GHZ_BAND_CAP",
+    [WLAN_EID_EXT_EDMG_CAPABILITIES] = "EID_EXT_EDMG_CAPABILITIES",
+    [WLAN_EID_EXT_EDMG_OPERATION] = "EID_EXT_EDMG_OPERATION",
+    [WLAN_EID_EXT_MSCS_DESCRIPTOR] = "EID_EXT_MSCS_DESCRIPTOR",
+    [WLAN_EID_EXT_TCLAS_MASK] = "EID_EXT_TCLAS_MASK",
+    [WLAN_EID_EXT_REJECTED_GROUPS] = "EID_EXT_REJECTED_GROUPS",
+    [WLAN_EID_EXT_ANTI_CLOGGING_TOKEN] = "EID_EXT_ANTI_CLOGGING_TOKEN",
+};
+
+static void print_rta_addr(int family, const struct rtattr *rta)
+{
+    if (!family && RTA_PAYLOAD(rta) == 6)
+        family = AF_PACKET;
+
+    switch (family) {
+    case AF_PACKET: {
+        unsigned char *x = RTA_DATA(rta);
+        outf(" %02x:%02x:%02x:%02x:%02x:%02x", x[0], x[1], x[2], x[3], x[4], x[5]);
+        break;
+    }
+    case AF_INET:
+    case AF_INET6: {
+        char host[INET6_ADDRSTRLEN];
+        outf(" %s", inet_ntop(family, RTA_DATA(rta), host, sizeof(host)));
+        break;
+    }
+    default:
+        outf(" AF_unexpected_family_%d\n", family);
+        dump(RTA_DATA(rta), RTA_PAYLOAD(rta), 0, "\t");
+        break;
+    }
+}
+
+static void print_iff(int flags)
+{
+    outf(" ");
+    if (!flags) {
+        outf("-");
+        return;
+    }
+    int first = 1;
+    for (int i = 0; ifa_flags_descr[i].flag; i++) {
+        if (flags & ifa_flags_descr[i].flag) {
+            outf("%s%s", first ? "" : "|", ifa_flags_descr[i].name);
+            first = 0;
+        }
+        flags &= ~ifa_flags_descr[i].flag;
+    }
+    if (flags) outf("|%#x", flags);
+}
+
+/*
+ * Compare two ethernet addresses
+ */
+
+static int iw_ether_cmp(const struct ether_addr* eth1, const struct ether_addr* eth2)
+{
+    return memcmp(eth1, eth2, sizeof(*eth1));
+}
+
+/*
+ * Display an Wireless Access Point Socket Address in readable format.
+ * Note : 0x44 is an accident of history, that's what the Orinoco/PrismII
+ * chipset report, and the driver doesn't filter it.
+ */
+
+static void print_ap_addr(const struct sockaddr *sap)
+{
+    const struct ether_addr ether_zero = {{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }};
+    const struct ether_addr ether_bcast = {{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }};
+    const struct ether_addr ether_hack = {{ 0x44, 0x44, 0x44, 0x44, 0x44, 0x44 }};
+    const struct ether_addr *ap = (const struct ether_addr *) sap->sa_data;
+
+    if (!iw_ether_cmp(ap, &ether_zero))
+        outf("Not-Associated");
+    else if (!iw_ether_cmp(ap, &ether_bcast))
+        outf("Invalid");
+    else if (!iw_ether_cmp(ap, &ether_hack))
+        outf("None");
+    else
+        outf("%02x:%02x:%02x:%02x:%02x:%02x",
+            ap->ether_addr_octet[0], ap->ether_addr_octet[1],
+            ap->ether_addr_octet[2], ap->ether_addr_octet[3],
+            ap->ether_addr_octet[4], ap->ether_addr_octet[5]);
+}
+
+int nl_debug(void *buf, int len)
+{
+    if (len < 0) {
+        outf("netlink_read: len=%d - %s\n", len, strerror(errno));
+        return len;
+    }
+    if (len == 0) {
+        outf("netlink_read: EOF\n");
+        return -1;
+    }
+    if (len < NLMSG_HDRLEN) {
+        outf("netlink_read: short read (%d)\n", len);
+        return 0;
+    }
+
+    //dump(&buf, len, 0, "\t");
+
+    for (struct nlmsghdr *nh = buf; NLMSG_OK(nh, len); nh = NLMSG_NEXT(nh, len)) {
+        if (0) {
+            outf("--- Netlink message %d bytes, flags %#x %s\n", nh->nlmsg_len, nh->nlmsg_flags & ~NLM_F_MULTI,
+                (nh->nlmsg_flags & NLM_F_MULTI) ? "[multi]" : "");
+        }
+
+        if (nh->nlmsg_type == NLMSG_DONE) {
+            //done = 1;
+            break;
+
+        } else if (nh->nlmsg_type == NLMSG_ERROR) {
+            // struct nlmsgerr {
+            //     int error;        /* Negative errno or 0 for acknowledgements */
+            //     struct nlmsghdr msg;  /* Message header that caused the error */
+            // };
+            struct nlmsgerr *err = (struct nlmsgerr *) NLMSG_DATA(nh);
+            if (err->error == 0) {
+                outf("(ACK)\n");
+            } else {
+                errno = -err->error;
+                outf("netlink_read: %s, caused by nlmsghdr { type %s, len %u, flags %#x, seq %u, pid %u }\n",
+                    strerror(errno),
+                    nlmsg_type_str[err->msg.nlmsg_type], /* Type of message content */
+                    err->msg.nlmsg_len, /* Length of message including header */
+                    err->msg.nlmsg_flags, /* Additional flags */
+                    err->msg.nlmsg_seq, /* Sequence number */
+                    err->msg.nlmsg_pid /* Sender port ID */
+                );
+            }
+
+        } else if (nh->nlmsg_type == RTM_NEWLINK || nh->nlmsg_type == RTM_DELLINK) {
+            // struct ifinfomsg {
+            //     unsigned char  ifi_family; /* AF_UNSPEC */
+            //     unsigned short ifi_type;   /* Device type */
+            //     int            ifi_index;  /* Interface index */
+            //     unsigned int   ifi_flags;  /* Device flags  */
+            //     unsigned int   ifi_change; /* change mask */
+            // };
+            struct ifinfomsg *ifm = (struct ifinfomsg *) NLMSG_DATA(nh);
+            size_t rta_len = IFLA_PAYLOAD(nh); //NLMSG_PAYLOAD(nh, sizeof(*ifm));
+
+            outf("%s interface ifindex %u, type %hu, family %d, flags %#x, change %#x,",
+                nh->nlmsg_type == RTM_NEWLINK ? "+" : "-", ifm->ifi_index, ifm->ifi_type,
+                ifm->ifi_family, ifm->ifi_flags, ifm->ifi_change);
+
+            for (struct rtattr *rta = IFLA_RTA(ifm); RTA_OK(rta, rta_len); rta = RTA_NEXT(rta, rta_len)) {
+                outf(" %s", ifla_rta_type_str[rta->rta_type]);
+                switch (rta->rta_type) {
+                // not implemented
+                case IFLA_UNSPEC:
+                case IFLA_AF_SPEC:
+                case IFLA_STATS64:
+                case IFLA_STATS:
+                case IFLA_MAP:
+                case IFLA_XDP:
+                case IFLA_LINKINFO:
+                    outf(" -");
+                    break;
+                // mac
+                case IFLA_ADDRESS:
+                case IFLA_BROADCAST:
+                case IFLA_PERM_ADDRESS:
+                    print_rta_addr(ifm->ifi_family, rta);
+                    break;
+                // asciiz
+                case IFLA_IFNAME:
+                case IFLA_QDISC: {
+                    const char *val = RTA_DATA(rta);
+                    outf(" %s", val);
+                    break;
+                }
+                // unsigned char
+                case IFLA_OPERSTATE:
+                case IFLA_LINKMODE:
+                case IFLA_CARRIER:
+                case IFLA_PROTO_DOWN: {
+                    const unsigned char *val = RTA_DATA(rta);
+                    outf(" %u", *val);
+                    break;
+                }
+                // unsigned int
+                case IFLA_TXQLEN:
+                case IFLA_MTU:
+                case IFLA_MIN_MTU:
+                case IFLA_MAX_MTU:
+                case IFLA_GROUP:
+                case IFLA_PROMISCUITY:
+                case IFLA_NUM_TX_QUEUES:
+                case IFLA_GSO_MAX_SEGS:
+                case IFLA_GSO_MAX_SIZE:
+                case IFLA_NUM_RX_QUEUES:
+                case IFLA_CARRIER_CHANGES:
+                case IFLA_CARRIER_UP_COUNT:
+                case IFLA_CARRIER_DOWN_COUNT: {
+                    const unsigned *val = RTA_DATA(rta);
+                    outf(" %u", *val);
+                    break;
+                }
+                // int
+                case IFLA_LINK: {
+                    const int *val = RTA_DATA(rta);
+                    outf(" %d", *val);
+                    break;
+                }
+                case IFLA_WIRELESS: {
+                    // struct iw_event {
+                    //     __u16 len;                      /* Real length of this stuff (with header) */
+                    //     __u16 cmd;                      /* Wireless IOCTL */
+                    //     union iwreq_data u;             /* IOCTL fixed payload */
+                    // };
+                    // union iwreq_data {
+                    //     char            name[IFNAMSIZ]; /* Name : used to verify the presence of  wireless extensions. Name of the protocol/provider... */
+                    //     struct iw_point essid;          /* Extended network name */
+                    //     struct iw_param nwid;           /* network id (or domain - the cell) */
+                    //     struct iw_freq  freq;           /* frequency or channel : * 0-1000 = channel * > 1000 = frequency in Hz */
+                    //     struct iw_param sens;           /* signal level threshold */
+                    //     struct iw_param bitrate;        /* default bit rate */
+                    //     struct iw_param txpower;        /* default transmit power */
+                    //     struct iw_param rts;            /* RTS threshold */
+                    //     struct iw_param frag;           /* Fragmentation threshold */
+                    //     __u32           mode;           /* Operation mode */
+                    //     struct iw_param retry;          /* Retry limits & lifetime */
+                    //     struct iw_point encoding;       /* Encoding stuff : tokens */
+                    //     struct iw_param power;          /* PM duration/timeout */
+                    //     struct iw_quality qual;         /* Quality part of statistics */
+                    //     struct sockaddr ap_addr;        /* Access point address */
+                    //     struct sockaddr addr;           /* Destination address (hw/mac) */
+                    //     struct iw_param param;          /* Other small parameters */
+                    //     struct iw_point data;           /* Other large parameters */
+                    // };
+                    // struct iw_point {
+                    //     void *pointer; /* Pointer to the data  (in user space) */
+                    //     __u16 length;  /* number of fields or size in bytes (without header) */
+                    //     __u16 flags;   /* Optional params */
+                    // };
+
+                    struct iw_event *iw = RTA_DATA(rta);
+                    for (int iwlen = RTA_PAYLOAD(rta); iwlen > 0; iwlen -= iw->len,
+                            iw = (struct iw_event *) ((u8*)iw + iw->len)) {
+                        const char *iwcmd = iw_event_cmd_str[iw->cmd - SIOCIWFIRST];
+
+                        switch (iw->cmd) {
+                        // unsigned int
+                        case SIOCGIWSCAN: {
+                            outf(" %s:%u", iwcmd, iw->u.mode);
+                            break;
+                        }
+                        // hex
+                        case SIOCGIWAP: { // [16]
+                            outf(" AP:");
+                            print_ap_addr(&iw->u.ap_addr);
+                            //dump_hex(&iw->u, iwlen - sizeof(*iw) + sizeof(iw->u));
+                            break;
+                        }
+                        // struct wlan_ies (struct iw_point without pointer)
+                        case IWEVMICHAELMICFAILURE:
+                        case IWEVCUSTOM:
+                        case IWEVASSOCREQIE:
+                        case IWEVASSOCRESPIE:
+                        case IWEVPMKIDCAND: {
+                            outf(" %s:", iwcmd);
+                            struct wlan_ies *ies = (struct wlan_ies *) &iw->u.data;
+                            struct wlan_ie *ie = ies->ies;
+                            for (int ieslen = ies->len; ieslen > 0; ieslen -= sizeof(*ie) + ie->len,
+                                    ie = (struct wlan_ie *) (ie->data + ie->len)) {
+                                const char *ieid = wlan_eid_str[ie->id];
+                                switch (ie->id) {
+                                // ascii
+                                case WLAN_EID_SSID:
+                                    if (ie->len) outf(" %s=\"%.*s\"", ieid, ie->len, ie->data);
+                                    break;
+                                // hex
+                                case WLAN_EID_SUPP_RATES: // [6..8]
+                                case WLAN_EID_EXT_SUPP_RATES: // [4]
+                                case WLAN_EID_PWR_CAPABILITY: // [2]
+                                case WLAN_EID_SUPPORTED_CHANNELS: // [2]
+                                case WLAN_EID_RSN: // [20]
+                                case WLAN_EID_EXT_CAPAB: // [8]
+                                case WLAN_EID_VENDOR_SPECIFIC: // [7..9]
+                                case WLAN_EID_HT_CAP: // [26]
+                                    outf(" %s=", ieid);
+                                    dump_hex(ie->data, ie->len);
+                                    break;
+                                // 3-byte int
+                                case WLAN_EID_BSS_MAX_IDLE_PERIOD: { // [3]
+                                    unsigned v = ie->data[0] | ie->data[1] << 8 | ie->data[2] << 16;
+                                    outf(" %s:%u", ieid, v);
+                                    break;
+                                }
+                                case WLAN_EID_EXTENSION: {
+                                    const char *extid = wlan_eid_ext_str[ie->data[0]];
+                                    outf(" %s[%d]=", extid, ie->len - 1);
+                                    dump_str(&ie->data[1], ie->len - 1);
+                                    break;
+                                }
+                                default:
+                                    outf(" %s[%d]=", ieid, ie->len);
+                                    dump_str(ie->data, ie->len);
+                                    break;
+                                }
+
+                            }
+                            //outf("\n"); dump(iw, iwlen, 0, "\tIEs:\t");
+                            break;
+                        }
+                        default:
+                            outf("\n\t%s(cmd=%#x,iwlen=%d,len=%u):", iwcmd, iw->cmd, iwlen, iw->len);
+                            outf("\n"); dump(iw, iwlen, 0, "\t\t");
+                            break;
+                        }
+
+                    }
+
+                    //outf("\n"); dump(RTA_DATA(rta), RTA_PAYLOAD(rta), 0, "\t");
+                    break;
+                }
+                default:
+                    outf("\n"); dump(RTA_DATA(rta), RTA_PAYLOAD(rta), 0, "\t");
+                    break;
+                }
+            }
+            outf("\n");
+
+        } else if (nh->nlmsg_type == RTM_NEWADDR || nh->nlmsg_type == RTM_DELADDR) {
+            // struct ifaddrmsg {
+            //     unsigned char ifa_family;    /* Address type */
+            //     unsigned char ifa_prefixlen; /* Prefixlength of address */
+            //     unsigned char ifa_flags;     /* Address flags */
+            //     unsigned char ifa_scope;     /* Address scope */
+            //     unsigned int  ifa_index;     /* Interface index */
+            // };
+            struct ifaddrmsg *ifm = (struct ifaddrmsg *) NLMSG_DATA(nh);
+            size_t rta_len = IFA_PAYLOAD(nh); //NLMSG_PAYLOAD(nh, sizeof(*ifm));
+
+            outf("%s address ifindex %d, family %d, prefix /%d, flags %x, scope %#x,",
+                nh->nlmsg_type == RTM_NEWADDR ? "+" : "-", ifm->ifa_index, ifm->ifa_family,
+                ifm->ifa_prefixlen, ifm->ifa_flags, ifm->ifa_scope);
+
+            for (struct rtattr *rta = IFA_RTA(ifm); RTA_OK(rta, rta_len); rta = RTA_NEXT(rta, rta_len)) {
+                outf(" %s", ifa_rta_type_str[rta->rta_type]);
+                switch (rta->rta_type) {
+                // address
+                case IFA_ADDRESS:
+                case IFA_LOCAL:
+                case IFA_BROADCAST:
+                case IFA_ANYCAST:
+                case IFA_MULTICAST:
+                    print_rta_addr(ifm->ifa_family, rta);
+                    break;
+                // asciiz
+                case IFA_LABEL: {
+                    const char *ifname = RTA_DATA(rta);
+                    outf(" %s", ifname);
+                    break;
+                }
+                // ifa_cacheinfo
+                case IFA_CACHEINFO: {
+                    // struct ifa_cacheinfo {
+                    //     __u32 ifa_prefered;
+                    //     __u32 ifa_valid;
+                    //     __u32 cstamp; // created timestamp, hundredths of seconds
+                    //     __u32 tstamp; // updated timestamp, hundredths of seconds
+                    // };
+                    struct ifa_cacheinfo *ifci = RTA_DATA(rta);
+                    outf(" prefered=%d,valid=%d,ct=%.2f,ut=%.2f",
+                        ifci->ifa_prefered, ifci->ifa_valid,
+                        ifci->cstamp/100.0, ifci->tstamp/100.0);
+                    break;
+                }
+                // flags
+                case IFA_FLAGS: {
+                    int *pflags = RTA_DATA(rta), flags_len = RTA_PAYLOAD(rta);
+                    if (flags_len == sizeof(int)) print_iff(*pflags);
+                    break;
+                }
+                default:
+                    //outf("IFA_0x%04x\n", rta->rta_type);
+                    dump(RTA_DATA(rta), RTA_PAYLOAD(rta), 0, "\t");
+                    break;
+                }
+            }
+            outf("\n");
+
+        } else if (nh->nlmsg_type == RTM_NEWROUTE || nh->nlmsg_type == RTM_DELROUTE) {
+            // struct rtmsg {
+            //     unsigned char rtm_family;
+            //     unsigned char rtm_dst_len;
+            //     unsigned char rtm_src_len;
+            //     unsigned char rtm_tos;
+            //     unsigned char rtm_table;     /* Routing table id */
+            //     unsigned char rtm_protocol;  /* Routing protocol; see below  */
+            //     unsigned char rtm_scope;     /* See below */
+            //     unsigned char rtm_type;      /* See below    */
+            //     unsigned      rtm_flags;
+            // };
+            struct rtmsg *ifm = (struct rtmsg *) NLMSG_DATA(nh);
+            size_t rta_len = RTM_PAYLOAD(nh); //NLMSG_PAYLOAD(nh, sizeof(*ifm));
+
+            outf("%s route %s, family %d, flags %#x, dst_len %u, src_len %u, tos %u, table %u, protocol %u, scope %u,",
+                nh->nlmsg_type == RTM_NEWROUTE ? "+" : "-", rtmsg_type_str[ifm->rtm_type], ifm->rtm_family,
+                ifm->rtm_flags, ifm->rtm_dst_len, ifm->rtm_src_len, ifm->rtm_tos,
+                ifm->rtm_table, ifm->rtm_protocol, ifm->rtm_scope);
+
+            for (struct rtattr *rta = RTM_RTA(ifm); RTA_OK(rta, rta_len); rta = RTA_NEXT(rta, rta_len)) {
+                outf(" %s", rtattr_type_str[rta->rta_type]);
+                switch (rta->rta_type) {
+                // not implemented
+                case RTA_UNSPEC:
+                case RTA_CACHEINFO:
+                    outf(" -");
+                    break;
+                // address
+                case RTA_DST:
+                case RTA_SRC:
+                case RTA_GATEWAY:
+                case RTA_PREFSRC:
+                case RTA_NEWDST:
+                    print_rta_addr(ifm->rtm_family, rta);
+                    break;
+                // unsigned char
+                case RTA_PREF: {
+                    const unsigned char *val = RTA_DATA(rta);
+                    outf(" %u", *val);
+                    break;
+                }
+                // unsigned short
+                case RTA_ENCAP_TYPE: {
+                    const unsigned short *val = RTA_DATA(rta);
+                    outf(" %hu", *val);
+                    break;
+                }
+                // unsigned int
+                case RTA_TABLE:
+                case RTA_PRIORITY:
+                case RTA_IIF:
+                case RTA_OIF:
+                case RTA_METRICS:
+                case RTA_FLOW:
+                case RTA_MARK:
+                case RTA_EXPIRES: {
+                    const unsigned *val = RTA_DATA(rta);
+                    outf(" %u", *val);
+                    break;
+                }
+                default:
+                    outf("\n");
+                    dump(RTA_DATA(rta), RTA_PAYLOAD(rta), 0, "\t");
+                    break;
+                }
+            }
+            outf("\n");
+
+        } else {
+                outf("unimplemented nlmsg_type %d (%s)\n", nh->nlmsg_type,
+                    nlmsg_type_str[nh->nlmsg_type]);
+                dump(NLMSG_DATA(nh), NLMSG_PAYLOAD(nh, 0), NLMSG_DATA(nh) - (void*) &buf, "\t");
+        }
+    }
+
+    return len;
+}
+
+#ifdef MAIN
+
+static int send_req(int nls, unsigned seqno)
+{
+    int rc;
+    struct sockaddr_nl nladdr = { AF_NETLINK, 0, 0, 0 };
+    struct {
+        struct nlmsghdr hdr;
+        struct rtgenmsg gen;
+    } req = {
+        { sizeof(req), NLMSG_NOOP, NLM_F_REQUEST | NLM_F_ROOT | NLM_F_ACK, seqno, getpid() },
+        { AF_UNSPEC },
+    };
+
+    switch (seqno) {
+    case 0:
+        req.hdr.nlmsg_type = RTM_GETLINK;
+        rc = sendto(nls, &req, sizeof(req), 0, (struct sockaddr *) &nladdr, sizeof(nladdr));
+        break;
+    case 1:
+        req.hdr.nlmsg_type = RTM_GETADDR;
+        rc = sendto(nls, &req, sizeof(req), 0, (struct sockaddr *) &nladdr, sizeof(nladdr));
+        break;
+    case 2:
+        req.hdr.nlmsg_type = RTM_GETROUTE;
+        rc = sendto(nls, &req, sizeof(req), 0, (struct sockaddr *) &nladdr, sizeof(nladdr));
+        break;
+    }
+
+    return rc == (int) sizeof(req);
+}
+
+int main(int argc, char *argv[])
+{
+    int rc;
+    (void)argc;
+    (void)argv;
+
+    int nls = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+    if (nls < 0) goto fail;
+
+    int bufsize = 65536;
+    rc = setsockopt(nls, SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(bufsize));
+    if (rc < 0) goto fail;
+    rc = setsockopt(nls, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize));
+    if (rc < 0) goto fail;
+    rc = setsockopt(nls, SOL_SOCKET, SO_RCVBUFFORCE, &bufsize, sizeof(bufsize));
+    if (rc < 0) perror("setsockopt(SO_RCVBUFFORCE)");
+
+    const int enable = 1;
+    rc = setsockopt(nls, SOL_NETLINK, NETLINK_NO_ENOBUFS, &enable, sizeof(enable));
+    if (rc < 0) goto fail;
+
+    struct sockaddr_nl nlsaddr = { AF_NETLINK, 0, getpid(),
+        RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV4_ROUTE |
+        RTMGRP_IPV6_IFADDR | RTMGRP_IPV6_ROUTE };
+
+    rc = bind(nls, (struct sockaddr *) &nlsaddr, sizeof(nlsaddr));
+    if (rc < 0) goto fail;
+
+    // Connect to kernel (pid 0) as remote address.
+    struct sockaddr_nl nlraddr = { AF_NETLINK, 0, 0, 0 };
+    rc = connect(nls, (struct sockaddr *) &nlraddr, sizeof(nlraddr));
+    if (rc != 0) goto fail;
+
+    size_t nlslen = sizeof(nlsaddr);
+    rc = getsockname(nls, (struct sockaddr *) &nlsaddr, &nlslen);
+    if (rc < 0) goto fail;
+
+    outf("getsockname: len=%d family=%d pid=%d groups=%#x\n", nlslen,
+        nlsaddr.nl_family, nlsaddr.nl_pid, nlsaddr.nl_groups);
+
+    size_t nlrlen = sizeof(nlraddr);
+    rc = getpeername(nls, (struct sockaddr *) &nlraddr, &nlrlen);
+    if (rc < 0) goto fail;
+
+    outf("getpeername: len=%d family=%d pid=%d groups=%#x\n", nlrlen,
+        nlraddr.nl_family, nlraddr.nl_pid, nlraddr.nl_groups);
+
+    //rc = fcntl(nls, F_GETFL, 0);
+    //if (rc < 0) goto fail;
+    //rc = fcntl(nls, F_SETFL, rc | O_NONBLOCK);
+    //if (rc < 0) goto fail;
+
+    // struct iovec {                    /* Scatter/gather array items */
+    //     void  *iov_base;              /* Starting address */
+    //     size_t iov_len;               /* Number of bytes to transfer */
+    // };
+
+    // struct msghdr {
+    //     void         *msg_name;       /* Optional address */
+    //     socklen_t     msg_namelen;    /* Size of address */
+    //     struct iovec *msg_iov;        /* Scatter/gather array */
+    //     size_t        msg_iovlen;     /* # elements in msg_iov */
+    //     void         *msg_control;    /* Ancillary data, see below */
+    //     size_t        msg_controllen; /* Ancillary data buffer len */
+    //     int           msg_flags;      /* Flags on received message */
+    // };
+
+    // struct nlmsghdr {
+    //     __u32 nlmsg_len;    /* Length of message including header */
+    //     __u16 nlmsg_type;   /* Type of message content */
+    //     __u16 nlmsg_flags;  /* Additional flags */
+    //     __u32 nlmsg_seq;    /* Sequence number */
+    //     __u32 nlmsg_pid;    /* Sender port ID */
+    // };
+
+    // struct rtgenmsg {
+    //     unsigned char rtgen_family;
+    // };
+
+    // struct sockaddr_nl {
+    //     unsigned short  nl_family;      /* AF_NETLINK   */
+    //     unsigned short  nl_pad;         /* zero         */
+    //     __u32           nl_pid;         /* port ID      */
+    //     __u32           nl_groups;      /* multicast groups mask */
+    // };
+
+    union {
+        struct nlmsghdr nh;
+        char buf[8192];
+    } buf;
+
+    int done = 0;
+    unsigned seqno = 0;
+    struct iovec iov = { &buf, sizeof(buf) };
+    struct sockaddr_nl nladdr = { AF_NETLINK, 0, 0, 0 }; // send to kernel (pid 0) as remote address
+    struct msghdr msg = { &nladdr, sizeof(nladdr), &iov, 1, NULL, 0, MSG_WAITALL };
+
+    send_req(nls, seqno++);
+
+    do {
+        int len = recvmsg(nls, &msg, 0);
+
+        if (len < 0) {
+            goto fail;
+        } else if (len == 0) {
+            outf("netlink_read: EOF\n");
+            goto fail;
+        } else if (msg.msg_flags & MSG_TRUNC) {
+            outf("netlink_read: message truncated (%d)\n", len);
+            continue;
+        } else if (len < NLMSG_HDRLEN) {
+            outf("netlink_read: short read (%d)\n", len);
+            continue;
+        } else if (msg.msg_namelen != nlslen) {
+            outf("netlink_read: unexpected sender address length (%d)\n", msg.msg_namelen);
+            goto fail;
+        } else if (nladdr.nl_pid != 0) {
+            outf("netlink_read: message from pid=%d\n", nladdr.nl_pid);
+            continue;
+        }
+
+        if (1) {
+            struct nlmsghdr *nh = (void *) &buf;
+            outf("\n-------------------- Netlink message %s seq %d pid %d, %d bytes %s ----------------------------\n",
+                len >= NLMSG_HDRLEN ? nlmsg_type_str[nh->nlmsg_type] : "?",
+                len >= NLMSG_HDRLEN ? nh->nlmsg_seq : 0xffffffff,
+                len >= NLMSG_HDRLEN ? nh->nlmsg_pid : 0xffffffff,
+                len, nh->nlmsg_flags & NLM_F_MULTI ? "[multi]" : ""
+            );
+            if (nh->nlmsg_type == NLMSG_DONE || (nh->nlmsg_flags & NLM_F_MULTI) == 0)
+                send_req(nls, seqno++);
+        }
+
+        if (nl_debug(&buf, len) < 0)
+            goto fail;
+    } while (!done);
+
+    return 0;
+
+  fail:
+    fflush(stdout);
+    perror("netlink");
+    if (nls > 0) close(nls);
+    return 1;
+}
+#endif
diff -urpN wsdd2.old/nl_debug.h wsdd2/nl_debug.h
--- wsdd2.old/nl_debug.h	1970-01-01 07:00:00.000000000 +0700
+++ wsdd2/nl_debug.h	2021-11-29 14:22:49.857126999 +0700
@@ -0,0 +1,2398 @@
+#include <stdint.h> // uint8_t, ...
+#include <net/ethernet.h> // #define ETHER_ADDR_LEN  ETH_ALEN
+#include <linux/if_ether.h> // ETH_ALEN
+
+/* from hostap-git/src/common/ieee802_11_defs.h */
+/*
+ * IEEE 802.11 Frame type definitions
+ * Copyright (c) 2002-2019, Jouni Malinen <j@w1.fi>
+ * Copyright (c) 2007-2008 Intel Corporation
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#ifndef IEEE802_11_DEFS_H
+#define IEEE802_11_DEFS_H
+
+/* from #include <utils/common.h> */
+
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint16_t u16;
+typedef uint8_t u8;
+typedef int64_t s64;
+typedef int32_t s32;
+typedef int16_t s16;
+typedef int8_t s8;
+
+#undef __bitwise
+#define __bitwise
+typedef u16 __bitwise be16;
+typedef u16 __bitwise le16;
+typedef u32 __bitwise be32;
+typedef u32 __bitwise le32;
+typedef u64 __bitwise be64;
+typedef u64 __bitwise le64;
+
+#ifdef __GNUC__
+#define PRINTF_FORMAT(a,b) __attribute__ ((format (printf, (a), (b))))
+#define STRUCT_PACKED __attribute__ ((packed))
+#else
+#define PRINTF_FORMAT(a,b)
+#define STRUCT_PACKED
+#endif
+
+/* IEEE 802.11 defines */
+
+#define WLAN_FC_PVER		0x0003
+#define WLAN_FC_TODS		0x0100
+#define WLAN_FC_FROMDS		0x0200
+#define WLAN_FC_MOREFRAG	0x0400
+#define WLAN_FC_RETRY		0x0800
+#define WLAN_FC_PWRMGT		0x1000
+#define WLAN_FC_MOREDATA	0x2000
+#define WLAN_FC_ISWEP		0x4000
+#define WLAN_FC_ORDER		0x8000
+
+#define WLAN_FC_GET_TYPE(fc)	(((fc) & 0x000c) >> 2)
+#define WLAN_FC_GET_STYPE(fc)	(((fc) & 0x00f0) >> 4)
+
+#define WLAN_INVALID_MGMT_SEQ   0xFFFF
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & (BIT(3) | BIT(2) | BIT(1) | BIT(0)))
+#define WLAN_GET_SEQ_SEQ(seq) \
+	(((seq) & (~(BIT(3) | BIT(2) | BIT(1) | BIT(0)))) >> 4)
+
+#define WLAN_FC_TYPE_MGMT		0
+#define WLAN_FC_TYPE_CTRL		1
+#define WLAN_FC_TYPE_DATA		2
+
+/* management */
+#define WLAN_FC_STYPE_ASSOC_REQ		0
+#define WLAN_FC_STYPE_ASSOC_RESP	1
+#define WLAN_FC_STYPE_REASSOC_REQ	2
+#define WLAN_FC_STYPE_REASSOC_RESP	3
+#define WLAN_FC_STYPE_PROBE_REQ		4
+#define WLAN_FC_STYPE_PROBE_RESP	5
+#define WLAN_FC_STYPE_BEACON		8
+#define WLAN_FC_STYPE_ATIM		9
+#define WLAN_FC_STYPE_DISASSOC		10
+#define WLAN_FC_STYPE_AUTH		11
+#define WLAN_FC_STYPE_DEAUTH		12
+#define WLAN_FC_STYPE_ACTION		13
+
+/* control */
+#define WLAN_FC_STYPE_PSPOLL		10
+#define WLAN_FC_STYPE_RTS		11
+#define WLAN_FC_STYPE_CTS		12
+#define WLAN_FC_STYPE_ACK		13
+#define WLAN_FC_STYPE_CFEND		14
+#define WLAN_FC_STYPE_CFENDACK		15
+
+/* data */
+#define WLAN_FC_STYPE_DATA		0
+#define WLAN_FC_STYPE_DATA_CFACK	1
+#define WLAN_FC_STYPE_DATA_CFPOLL	2
+#define WLAN_FC_STYPE_DATA_CFACKPOLL	3
+#define WLAN_FC_STYPE_NULLFUNC		4
+#define WLAN_FC_STYPE_CFACK		5
+#define WLAN_FC_STYPE_CFPOLL		6
+#define WLAN_FC_STYPE_CFACKPOLL		7
+#define WLAN_FC_STYPE_QOS_DATA		8
+#define WLAN_FC_STYPE_QOS_DATA_CFACK	9
+#define WLAN_FC_STYPE_QOS_DATA_CFPOLL	10
+#define WLAN_FC_STYPE_QOS_DATA_CFACKPOLL	11
+#define WLAN_FC_STYPE_QOS_NULL		12
+#define WLAN_FC_STYPE_QOS_CFPOLL	14
+#define WLAN_FC_STYPE_QOS_CFACKPOLL	15
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN			0
+#define WLAN_AUTH_SHARED_KEY		1
+#define WLAN_AUTH_FT			2
+#define WLAN_AUTH_SAE			3
+#define WLAN_AUTH_FILS_SK		4
+#define WLAN_AUTH_FILS_SK_PFS		5
+#define WLAN_AUTH_FILS_PK		6
+#define WLAN_AUTH_LEAP			128
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_ESS BIT(0)
+#define WLAN_CAPABILITY_IBSS BIT(1)
+#define WLAN_CAPABILITY_CF_POLLABLE BIT(2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST BIT(3)
+#define WLAN_CAPABILITY_PRIVACY BIT(4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE BIT(5)
+#define WLAN_CAPABILITY_PBCC BIT(6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY BIT(7)
+#define WLAN_CAPABILITY_SPECTRUM_MGMT BIT(8)
+#define WLAN_CAPABILITY_QOS BIT(9)
+#define WLAN_CAPABILITY_SHORT_SLOT_TIME BIT(10)
+#define WLAN_CAPABILITY_APSD BIT(11)
+#define WLAN_CAPABILITY_RADIO_MEASUREMENT BIT(12)
+#define WLAN_CAPABILITY_DSSS_OFDM BIT(13)
+#define WLAN_CAPABILITY_DELAYED_BLOCK_ACK BIT(14)
+#define WLAN_CAPABILITY_IMM_BLOCK_ACK BIT(15)
+
+/* Status codes (IEEE Std 802.11-2016, 9.4.1.9, Table 9-46) */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_TDLS_WAKEUP_ALTERNATE 2
+#define WLAN_STATUS_TDLS_WAKEUP_REJECT 3
+#define WLAN_STATUS_SECURITY_DISABLED 5
+#define WLAN_STATUS_UNACCEPTABLE_LIFETIME 6
+#define WLAN_STATUS_NOT_IN_SAME_BSS 7
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
+#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
+#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
+#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
+#define WLAN_STATUS_ASSOC_DENIED_NO_HT 27
+#define WLAN_STATUS_R0KH_UNREACHABLE 28
+#define WLAN_STATUS_ASSOC_DENIED_NO_PCO 29
+#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
+#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
+#define WLAN_STATUS_UNSPECIFIED_QOS_FAILURE 32
+#define WLAN_STATUS_DENIED_INSUFFICIENT_BANDWIDTH 33
+#define WLAN_STATUS_DENIED_POOR_CHANNEL_CONDITIONS 34
+#define WLAN_STATUS_DENIED_QOS_NOT_SUPPORTED 35
+#define WLAN_STATUS_REQUEST_DECLINED 37
+#define WLAN_STATUS_INVALID_PARAMETERS 38
+#define WLAN_STATUS_REJECTED_WITH_SUGGESTED_CHANGES 39
+#define WLAN_STATUS_INVALID_IE 40
+#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
+#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
+#define WLAN_STATUS_AKMP_NOT_VALID 43
+#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
+#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
+#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
+#define WLAN_STATUS_TS_NOT_CREATED 47
+#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
+#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
+#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
+#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
+#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
+#define WLAN_STATUS_INVALID_PMKID 53
+#define WLAN_STATUS_INVALID_MDIE 54
+#define WLAN_STATUS_INVALID_FTIE 55
+#define WLAN_STATUS_REQUESTED_TCLAS_NOT_SUPPORTED 56
+#define WLAN_STATUS_INSUFFICIENT_TCLAS_PROCESSING_RESOURCES 57
+#define WLAN_STATUS_TRY_ANOTHER_BSS 58
+#define WLAN_STATUS_GAS_ADV_PROTO_NOT_SUPPORTED 59
+#define WLAN_STATUS_NO_OUTSTANDING_GAS_REQ 60
+#define WLAN_STATUS_GAS_RESP_NOT_RECEIVED 61
+#define WLAN_STATUS_STA_TIMED_OUT_WAITING_FOR_GAS_RESP 62
+#define WLAN_STATUS_GAS_RESP_LARGER_THAN_LIMIT 63
+#define WLAN_STATUS_REQ_REFUSED_HOME 64
+#define WLAN_STATUS_ADV_SRV_UNREACHABLE 65
+#define WLAN_STATUS_REQ_REFUSED_SSPN 67
+#define WLAN_STATUS_REQ_REFUSED_UNAUTH_ACCESS 68
+#define WLAN_STATUS_INVALID_RSNIE 72
+#define WLAN_STATUS_U_APSD_COEX_NOT_SUPPORTED 73
+#define WLAN_STATUS_U_APSD_COEX_MODE_NOT_SUPPORTED 74
+#define WLAN_STATUS_BAD_INTERVAL_WITH_U_APSD_COEX 75
+#define WLAN_STATUS_ANTI_CLOGGING_TOKEN_REQ 76
+#define WLAN_STATUS_FINITE_CYCLIC_GROUP_NOT_SUPPORTED 77
+#define WLAN_STATUS_CANNOT_FIND_ALT_TBTT 78
+#define WLAN_STATUS_TRANSMISSION_FAILURE 79
+#define WLAN_STATUS_REQ_TCLAS_NOT_SUPPORTED 80
+#define WLAN_STATUS_TCLAS_RESOURCES_EXCHAUSTED 81
+#define WLAN_STATUS_REJECTED_WITH_SUGGESTED_BSS_TRANSITION 82
+#define WLAN_STATUS_REJECT_WITH_SCHEDULE 83
+#define WLAN_STATUS_REJECT_NO_WAKEUP_SPECIFIED 84
+#define WLAN_STATUS_SUCCESS_POWER_SAVE_MODE 85
+#define WLAN_STATUS_PENDING_ADMITTING_FST_SESSION 86
+#define WLAN_STATUS_PERFORMING_FST_NOW 87
+#define WLAN_STATUS_PENDING_GAP_IN_BA_WINDOW 88
+#define WLAN_STATUS_REJECT_U_PID_SETTING 89
+#define WLAN_STATUS_REFUSED_EXTERNAL_REASON 92
+#define WLAN_STATUS_REFUSED_AP_OUT_OF_MEMORY 93
+#define WLAN_STATUS_REJECTED_EMERGENCY_SERVICE_NOT_SUPPORTED 94
+#define WLAN_STATUS_QUERY_RESP_OUTSTANDING 95
+#define WLAN_STATUS_REJECT_DSE_BAND 96
+#define WLAN_STATUS_TCLAS_PROCESSING_TERMINATED 97
+#define WLAN_STATUS_TS_SCHEDULE_CONFLICT 98
+#define WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL 99
+#define WLAN_STATUS_MCCAOP_RESERVATION_CONFLICT 100
+#define WLAN_STATUS_MAF_LIMIT_EXCEEDED 101
+#define WLAN_STATUS_MCCA_TRACK_LIMIT_EXCEEDED 102
+#define WLAN_STATUS_DENIED_DUE_TO_SPECTRUM_MANAGEMENT 103
+#define WLAN_STATUS_ASSOC_DENIED_NO_VHT 104
+#define WLAN_STATUS_ENABLEMENT_DENIED 105
+#define WLAN_STATUS_RESTRICTION_FROM_AUTHORIZED_GDB 106
+#define WLAN_STATUS_AUTHORIZATION_DEENABLED 107
+#define WLAN_STATUS_FILS_AUTHENTICATION_FAILURE 112
+#define WLAN_STATUS_UNKNOWN_AUTHENTICATION_SERVER 113
+#define WLAN_STATUS_UNKNOWN_PASSWORD_IDENTIFIER 123
+#define WLAN_STATUS_DENIED_HE_NOT_SUPPORTED 124
+#define WLAN_STATUS_SAE_HASH_TO_ELEMENT 126
+#define WLAN_STATUS_SAE_PK 127
+
+/* Reason codes (IEEE Std 802.11-2016, 9.4.1.7, Table 9-45) */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
+#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
+#define WLAN_REASON_BSS_TRANSITION_DISASSOC 12
+#define WLAN_REASON_INVALID_IE 13
+#define WLAN_REASON_MICHAEL_MIC_FAILURE 14
+#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
+#define WLAN_REASON_GROUP_KEY_UPDATE_TIMEOUT 16
+#define WLAN_REASON_IE_IN_4WAY_DIFFERS 17
+#define WLAN_REASON_GROUP_CIPHER_NOT_VALID 18
+#define WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID 19
+#define WLAN_REASON_AKMP_NOT_VALID 20
+#define WLAN_REASON_UNSUPPORTED_RSN_IE_VERSION 21
+#define WLAN_REASON_INVALID_RSN_IE_CAPAB 22
+#define WLAN_REASON_IEEE_802_1X_AUTH_FAILED 23
+#define WLAN_REASON_CIPHER_SUITE_REJECTED 24
+#define WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE 25
+#define WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED 26
+#define WLAN_REASON_SSP_REQUESTED_DISASSOC 27
+#define WLAN_REASON_NO_SSP_ROAMING_AGREEMENT 28
+#define WLAN_REASON_BAD_CIPHER_OR_AKM 29
+#define WLAN_REASON_NOT_AUTHORIZED_THIS_LOCATION 30
+#define WLAN_REASON_SERVICE_CHANGE_PRECLUDES_TS 31
+#define WLAN_REASON_UNSPECIFIED_QOS_REASON 32
+#define WLAN_REASON_NOT_ENOUGH_BANDWIDTH 33
+#define WLAN_REASON_DISASSOC_LOW_ACK 34
+#define WLAN_REASON_EXCEEDED_TXOP 35
+#define WLAN_REASON_STA_LEAVING 36
+#define WLAN_REASON_END_TS_BA_DLS 37
+#define WLAN_REASON_UNKNOWN_TS_BA 38
+#define WLAN_REASON_TIMEOUT 39
+#define WLAN_REASON_PEERKEY_MISMATCH 45
+#define WLAN_REASON_AUTHORIZED_ACCESS_LIMIT_REACHED 46
+#define WLAN_REASON_EXTERNAL_SERVICE_REQUIREMENTS 47
+#define WLAN_REASON_INVALID_FT_ACTION_FRAME_COUNT 48
+#define WLAN_REASON_INVALID_PMKID 49
+#define WLAN_REASON_INVALID_MDE 50
+#define WLAN_REASON_INVALID_FTE 51
+#define WLAN_REASON_MESH_PEERING_CANCELLED 52
+#define WLAN_REASON_MESH_MAX_PEERS 53
+#define WLAN_REASON_MESH_CONFIG_POLICY_VIOLATION 54
+#define WLAN_REASON_MESH_CLOSE_RCVD 55
+#define WLAN_REASON_MESH_MAX_RETRIES 56
+#define WLAN_REASON_MESH_CONFIRM_TIMEOUT 57
+#define WLAN_REASON_MESH_INVALID_GTK 58
+#define WLAN_REASON_MESH_INCONSISTENT_PARAMS 59
+#define WLAN_REASON_MESH_INVALID_SECURITY_CAP 60
+#define WLAN_REASON_MESH_PATH_ERROR_NO_PROXY_INFO 61
+#define WLAN_REASON_MESH_PATH_ERROR_NO_FORWARDING_INFO 62
+#define WLAN_REASON_MESH_PATH_ERROR_DEST_UNREACHABLE 63
+#define WLAN_REASON_MAC_ADDRESS_ALREADY_EXISTS_IN_MBSS 64
+#define WLAN_REASON_MESH_CHANNEL_SWITCH_REGULATORY_REQ 65
+#define WLAN_REASON_MESH_CHANNEL_SWITCH_UNSPECIFIED 66
+
+
+/* Information Element IDs (IEEE Std 802.11-2016, 9.4.2.1, Table 9-77) */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_COUNTRY 7
+#define WLAN_EID_REQUEST 10
+#define WLAN_EID_BSS_LOAD 11
+#define WLAN_EID_EDCA_PARAM_SET 12
+#define WLAN_EID_TSPEC 13
+#define WLAN_EID_TCLAS 14
+#define WLAN_EID_SCHEDULE 15
+#define WLAN_EID_CHALLENGE 16
+#define WLAN_EID_PWR_CONSTRAINT 32
+#define WLAN_EID_PWR_CAPABILITY 33
+#define WLAN_EID_TPC_REQUEST 34
+#define WLAN_EID_TPC_REPORT 35
+#define WLAN_EID_SUPPORTED_CHANNELS 36
+#define WLAN_EID_CHANNEL_SWITCH 37
+#define WLAN_EID_MEASURE_REQUEST 38
+#define WLAN_EID_MEASURE_REPORT 39
+#define WLAN_EID_QUIET 40
+#define WLAN_EID_IBSS_DFS 41
+#define WLAN_EID_ERP_INFO 42
+#define WLAN_EID_TS_DELAY 43
+#define WLAN_EID_TCLAS_PROCESSING 44
+#define WLAN_EID_HT_CAP 45
+#define WLAN_EID_QOS 46
+#define WLAN_EID_RSN 48
+#define WLAN_EID_EXT_SUPP_RATES 50
+#define WLAN_EID_AP_CHANNEL_REPORT 51
+#define WLAN_EID_NEIGHBOR_REPORT 52
+#define WLAN_EID_RCPI 53
+#define WLAN_EID_MOBILITY_DOMAIN 54
+#define WLAN_EID_FAST_BSS_TRANSITION 55
+#define WLAN_EID_TIMEOUT_INTERVAL 56
+#define WLAN_EID_RIC_DATA 57
+#define WLAN_EID_DSE_REGISTERED_LOCATION 58
+#define WLAN_EID_SUPPORTED_OPERATING_CLASSES 59
+#define WLAN_EID_EXT_CHANSWITCH_ANN 60
+#define WLAN_EID_HT_OPERATION 61
+#define WLAN_EID_SECONDARY_CHANNEL_OFFSET 62
+#define WLAN_EID_BSS_AVERAGE_ACCESS_DELAY 63
+#define WLAN_EID_ANTENNA 64
+#define WLAN_EID_RSNI 65
+#define WLAN_EID_MEASUREMENT_PILOT_TRANSMISSION 66
+#define WLAN_EID_BSS_AVAILABLE_ADM_CAPA 67
+#define WLAN_EID_BSS_AC_ACCESS_DELAY 68 /* note: also used by WAPI */
+#define WLAN_EID_TIME_ADVERTISEMENT 69
+#define WLAN_EID_RRM_ENABLED_CAPABILITIES 70
+#define WLAN_EID_MULTIPLE_BSSID 71
+#define WLAN_EID_20_40_BSS_COEXISTENCE 72
+#define WLAN_EID_20_40_BSS_INTOLERANT 73
+#define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
+#define WLAN_EID_RIC_DESCRIPTOR 75
+#define WLAN_EID_MMIE 76
+#define WLAN_EID_EVENT_REQUEST 78
+#define WLAN_EID_EVENT_REPORT 79
+#define WLAN_EID_DIAGNOSTIC_REQUEST 80
+#define WLAN_EID_DIAGNOSTIC_REPORT 81
+#define WLAN_EID_LOCATION_PARAMETERS 82
+#define WLAN_EID_NONTRANSMITTED_BSSID_CAPA 83
+#define WLAN_EID_SSID_LIST 84
+#define WLAN_EID_MULTIPLE_BSSID_INDEX 85
+#define WLAN_EID_FMS_DESCRIPTOR 86
+#define WLAN_EID_FMS_REQUEST 87
+#define WLAN_EID_FMS_RESPONSE 88
+#define WLAN_EID_QOS_TRAFFIC_CAPABILITY 89
+#define WLAN_EID_BSS_MAX_IDLE_PERIOD 90
+#define WLAN_EID_TFS_REQ 91
+#define WLAN_EID_TFS_RESP 92
+#define WLAN_EID_WNMSLEEP 93
+#define WLAN_EID_TIM_BROADCAST_REQUEST 94
+#define WLAN_EID_TIM_BROADCAST_RESPONSE 95
+#define WLAN_EID_COLLOCATED_INTERFERENCE_REPORT 96
+#define WLAN_EID_CHANNEL_USAGE 97
+#define WLAN_EID_TIME_ZONE 98
+#define WLAN_EID_DMS_REQUEST 99
+#define WLAN_EID_DMS_RESPONSE 100
+#define WLAN_EID_LINK_ID 101
+#define WLAN_EID_WAKEUP_SCHEDULE 102
+#define WLAN_EID_CHANNEL_SWITCH_TIMING 104
+#define WLAN_EID_PTI_CONTROL 105
+#define WLAN_EID_TPU_BUFFER_STATUS 106
+#define WLAN_EID_INTERWORKING 107
+#define WLAN_EID_ADV_PROTO 108
+#define WLAN_EID_EXPEDITED_BANDWIDTH_REQ 109
+#define WLAN_EID_QOS_MAP_SET 110
+#define WLAN_EID_ROAMING_CONSORTIUM 111
+#define WLAN_EID_EMERGENCY_ALERT_ID 112
+#define WLAN_EID_MESH_CONFIG 113
+#define WLAN_EID_MESH_ID 114
+#define WLAN_EID_MESH_LINK_METRIC_REPORT 115
+#define WLAN_EID_CONGESTION_NOTIFICATION 116
+#define WLAN_EID_PEER_MGMT 117
+#define WLAN_EID_MESH_CHANNEL_SWITCH_PARAMETERS 118
+#define WLAN_EID_MESH_AWAKE_WINDOW 119
+#define WLAN_EID_BEACON_TIMING 120
+#define WLAN_EID_MCCAOP_SETUP_REQUEST 121
+#define WLAN_EID_MCCAOP_SETUP_REPLY 122
+#define WLAN_EID_MCCAOP_ADVERTISEMENT 123
+#define WLAN_EID_MCCAOP_TEARDOWN 124
+#define WLAN_EID_GANN 125
+#define WLAN_EID_RANN 126
+#define WLAN_EID_EXT_CAPAB 127
+#define WLAN_EID_PREQ 130
+#define WLAN_EID_PREP 131
+#define WLAN_EID_PERR 132
+#define WLAN_EID_PXU 137
+#define WLAN_EID_PXUC 138
+#define WLAN_EID_AMPE 139
+#define WLAN_EID_MIC 140
+#define WLAN_EID_DESTINATION_URI 141
+#define WLAN_EID_U_APSD_COEX 142
+#define WLAN_EID_DMG_WAKEUP_SCHEDULE 143
+#define WLAN_EID_EXTENDED_SCHEDULE 144
+#define WLAN_EID_STA_AVAILABILITY 145
+#define WLAN_EID_DMG_TSPEC 146
+#define WLAN_EID_NEXT_DMG_ATI 147
+#define WLAN_EID_DMG_CAPABILITIES 148
+#define WLAN_EID_DMG_OPERATION 151
+#define WLAN_EID_DMG_BSS_PARAMETER_CHANGE 152
+#define WLAN_EID_DMG_BEAM_REFINEMENT 153
+#define WLAN_EID_CHANNEL_MEASUREMENT_FEEDBACK 154
+#define WLAN_EID_CCKM 156
+#define WLAN_EID_AWAKE_WINDOW 157
+#define WLAN_EID_MULTI_BAND 158
+#define WLAN_EID_ADDBA_EXTENSION 159
+#define WLAN_EID_NEXTPCP_LIST 160
+#define WLAN_EID_PCP_HANDOVER 161
+#define WLAN_EID_DMG_LINK_MARGIN 162
+#define WLAN_EID_SWITCHING_STREAM 163
+#define WLAN_EID_SESSION_TRANSITION 164
+#define WLAN_EID_DYNAMIC_TONE_PAIRING_REPORT 165
+#define WLAN_EID_CLUSTER_REPORT 166
+#define WLAN_EID_REPLAY_CAPABILITIES 167
+#define WLAN_EID_RELAY_TRANSFER_PARAM_SET 168
+#define WLAN_EID_BEAMLINK_MAINTENANCE 169
+#define WLAN_EID_MULTIPLE_MAC_SUBLAYERS 170
+#define WLAN_EID_U_PID 171
+#define WLAN_EID_DMG_LINK_ADAPTATION_ACK 172
+#define WLAN_EID_MCCAOP_ADVERTISEMENT_OVERVIEW 174
+#define WLAN_EID_QUIET_PERIOD_REQUEST 175
+#define WLAN_EID_QUIET_PERIOD_RESPONSE 177
+#define WLAN_EID_QMF_POLICY 181
+#define WLAN_EID_ECAPC_POLICY 182
+#define WLAN_EID_CLUSTER_TIME_OFFSET 183
+#define WLAN_EID_INTRA_ACCESS_CATEGORY_PRIORITY 184
+#define WLAN_EID_SCS_DESCRIPTOR 185
+#define WLAN_EID_QLOAD_REPORT 186
+#define WLAN_EID_HCCA_TXOP_UPDATE_COUNT 187
+#define WLAN_EID_HIGHER_LAYER_STREAM_ID 188
+#define WLAN_EID_GCR_GROUP_ADDRESS 189
+#define WLAN_EID_ANTENNA_SECTOR_ID_PATTERN 190
+#define WLAN_EID_VHT_CAP 191
+#define WLAN_EID_VHT_OPERATION 192
+#define WLAN_EID_VHT_EXTENDED_BSS_LOAD 193
+#define WLAN_EID_VHT_WIDE_BW_CHSWITCH  194
+#define WLAN_EID_VHT_TRANSMIT_POWER_ENVELOPE 195
+#define WLAN_EID_VHT_CHANNEL_SWITCH_WRAPPER 196
+#define WLAN_EID_VHT_AID 197
+#define WLAN_EID_VHT_QUIET_CHANNEL 198
+#define WLAN_EID_VHT_OPERATING_MODE_NOTIFICATION 199
+#define WLAN_EID_UPSIM 200
+#define WLAN_EID_REDUCED_NEIGHBOR_REPORT 201
+#define WLAN_EID_TVHT_OPERATION 202
+#define WLAN_EID_DEVICE_LOCATION 204
+#define WLAN_EID_WHITE_SPACE_MAP 205
+#define WLAN_EID_FTM_PARAMETERS 206
+#define WLAN_EID_VENDOR_SPECIFIC 221
+#define WLAN_EID_CAG_NUMBER 237
+#define WLAN_EID_AP_CSN 239
+#define WLAN_EID_FILS_INDICATION 240
+#define WLAN_EID_DILS 241
+#define WLAN_EID_FRAGMENT 242
+#define WLAN_EID_RSNX 244
+#define WLAN_EID_EXTENSION 255
+
+/* Element ID Extension (EID 255) values */
+#define WLAN_EID_EXT_ASSOC_DELAY_INFO 1
+#define WLAN_EID_EXT_FILS_REQ_PARAMS 2
+#define WLAN_EID_EXT_FILS_KEY_CONFIRM 3
+#define WLAN_EID_EXT_FILS_SESSION 4
+#define WLAN_EID_EXT_FILS_HLP_CONTAINER 5
+#define WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN 6
+#define WLAN_EID_EXT_KEY_DELIVERY 7
+#define WLAN_EID_EXT_WRAPPED_DATA 8
+#define WLAN_EID_EXT_FTM_SYNC_INFO 9
+#define WLAN_EID_EXT_EXTENDED_REQUEST 10
+#define WLAN_EID_EXT_ESTIMATED_SERVICE_PARAMS 11
+#define WLAN_EID_EXT_FILS_PUBLIC_KEY 12
+#define WLAN_EID_EXT_FILS_NONCE 13
+#define WLAN_EID_EXT_FUTURE_CHANNEL_GUIDANCE 14
+#define WLAN_EID_EXT_OWE_DH_PARAM 32
+#define WLAN_EID_EXT_PASSWORD_IDENTIFIER 33
+#define WLAN_EID_EXT_HE_CAPABILITIES 35
+#define WLAN_EID_EXT_HE_OPERATION 36
+#define WLAN_EID_EXT_HE_MU_EDCA_PARAMS 38
+#define WLAN_EID_EXT_SPATIAL_REUSE 39
+#define WLAN_EID_EXT_OCV_OCI 54
+#define WLAN_EID_EXT_SHORT_SSID_LIST 58
+#define WLAN_EID_EXT_HE_6GHZ_BAND_CAP 59
+#define WLAN_EID_EXT_EDMG_CAPABILITIES 61
+#define WLAN_EID_EXT_EDMG_OPERATION 62
+#define WLAN_EID_EXT_MSCS_DESCRIPTOR 88
+#define WLAN_EID_EXT_TCLAS_MASK 89
+#define WLAN_EID_EXT_REJECTED_GROUPS 92
+#define WLAN_EID_EXT_ANTI_CLOGGING_TOKEN 93
+
+/* Extended Capabilities field */
+#define WLAN_EXT_CAPAB_20_40_COEX 0
+#define WLAN_EXT_CAPAB_GLK 1
+#define WLAN_EXT_CAPAB_EXT_CHAN_SWITCH 2
+#define WLAN_EXT_CAPAB_GLK_GCR 3
+#define WLAN_EXT_CAPAB_PSMP 4
+/* 5 - Reserved */
+#define WLAN_EXT_CAPAB_S_PSMP 6
+#define WLAN_EXT_CAPAB_EVENT 7
+#define WLAN_EXT_CAPAB_DIAGNOSTICS 8
+#define WLAN_EXT_CAPAB_MULTICAST_DIAGNOSTICS 9
+#define WLAN_EXT_CAPAB_LOCATION_TRACKING 10
+#define WLAN_EXT_CAPAB_FMS 11
+#define WLAN_EXT_CAPAB_PROXY_ARP 12
+#define WLAN_EXT_CAPAB_COLL_INTERF_REP 13
+#define WLAN_EXT_CAPAB_CIVIC_LOCATION 14
+#define WLAN_EXT_CAPAB_GEOSPATIAL_LOCATION 15
+#define WLAN_EXT_CAPAB_TFS 16
+#define WLAN_EXT_CAPAB_WNM_SLEEP_MODE 17
+#define WLAN_EXT_CAPAB_TIM_BROADCAST 18
+#define WLAN_EXT_CAPAB_BSS_TRANSITION 19
+#define WLAN_EXT_CAPAB_QOS_TRAFFIC 20
+#define WLAN_EXT_CAPAB_AC_STA_COUNT 21
+#define WLAN_EXT_CAPAB_MULTIPLE_BSSID 22
+#define WLAN_EXT_CAPAB_TIMING_MEASUREMENT 23
+#define WLAN_EXT_CAPAB_CHANNEL_USAGE 24
+#define WLAN_EXT_CAPAB_SSID_LIST 25
+#define WLAN_EXT_CAPAB_DMS 26
+#define WLAN_EXT_CAPAB_UTF_TSF_OFFSET 27
+#define WLAN_EXT_CAPAB_TPU_BUFFER_STA 28
+#define WLAN_EXT_CAPAB_TDLS_PEER_PSM 29
+#define WLAN_EXT_CAPAB_TDLS_CHANNEL_SWITCH 30
+#define WLAN_EXT_CAPAB_INTERWORKING 31
+#define WLAN_EXT_CAPAB_QOS_MAP 32
+#define WLAN_EXT_CAPAB_EBR 33
+#define WLAN_EXT_CAPAB_SSPN_INTERFACE 34
+/* 35 - Reserved */
+#define WLAN_EXT_CAPAB_MSGCF 36
+#define WLAN_EXT_CAPAB_TDLS 37
+#define WLAN_EXT_CAPAB_TDLS_PROHIBITED 38
+#define WLAN_EXT_CAPAB_TDLS_CHANNEL_SWITCH_PROHIBITED 39
+#define WLAN_EXT_CAPAB_REJECT_UNADMITTED_FRAME 40
+#define WLAN_EXT_CAPAB_
+/* 41-43 - Service Interval Granularity */
+#define WLAN_EXT_CAPAB_IDENTIFIER_LOCATION 44
+#define WLAN_EXT_CAPAB_U_APSD_COEX 45
+#define WLAN_EXT_CAPAB_WNM_NOTIFCATION 46
+#define WLAN_EXT_CAPAB_QAB 47
+#define WLAN_EXT_CAPAB_UTF_8_SSID 48
+#define WLAN_EXT_CAPAB_QMF 49
+#define WLAN_EXT_CAPAB_QMF_RECONFIG 50
+#define WLAN_EXT_CAPAB_ROBUST_AV_STREAMING 51
+#define WLAN_EXT_CAPAB_ADVANCED_GCR 52
+#define WLAN_EXT_CAPAB_MESH_GCR 53
+#define WLAN_EXT_CAPAB_SCS 54
+#define WLAN_EXT_CAPAB_QLOAD_REPORT 55
+#define WLAN_EXT_CAPAB_ALT_EDCA 56
+#define WLAN_EXT_CAPAB_UNPROT_TXOP_NEG 57
+#define WLAN_EXT_CAPAB_PROT_TXOP_NEG 58
+/* 59 - Reserved */
+#define WLAN_EXT_CAPAB_PROT_QLOAD_REPORT 60
+#define WLAN_EXT_CAPAB_TDLS_WIDER_BW 61
+#define WLAN_EXT_CAPAB_OPMODE_NOTIF 62
+#define WLAN_EXT_CAPAB_
+/* 63-64 - Max Number of MSDUs In A-MSDU */
+#define WLAN_EXT_CAPAB_CHANNEL_SCHEDULE_MGMT 65
+#define WLAN_EXT_CAPAB_GEODB_INBAND_ENABLING_SIGNAL 66
+#define WLAN_EXT_CAPAB_NETWORK_CHANNEL_CTRL 67
+#define WLAN_EXT_CAPAB_WHITE_SPACE_MAP 68
+#define WLAN_EXT_CAPAB_CHANNEL_AVAIL_QUERY 69
+#define WLAN_EXT_CAPAB_FTM_RESPONDER 70
+#define WLAN_EXT_CAPAB_FTM_INITIATOR 71
+#define WLAN_EXT_CAPAB_FILS 72
+#define WLAN_EXT_CAPAB_EXT_SPECTRUM_MGMT 73
+#define WLAN_EXT_CAPAB_FUTURE_CHANNEL_GUIDANCE 74
+#define WLAN_EXT_CAPAB_PAD 75
+/* 76-79 - Reserved */
+#define WLAN_EXT_CAPAB_COMPLETE_NON_TX_BSSID_PROFILE 80
+#define WLAN_EXT_CAPAB_SAE_PW_ID 81
+#define WLAN_EXT_CAPAB_SAE_PW_ID_EXCLUSIVELY 82
+#define WLAN_EXT_CAPAB_BEACON_PROTECTION 84
+#define WLAN_EXT_CAPAB_MSCS 85
+#define WLAN_EXT_CAPAB_SAE_PK_EXCLUSIVELY 88
+
+/* Extended RSN Capabilities */
+/* bits 0-3: Field length (n-1) */
+#define WLAN_RSNX_CAPAB_PROTECTED_TWT 4
+#define WLAN_RSNX_CAPAB_SAE_H2E 5
+#define WLAN_RSNX_CAPAB_SAE_PK 6
+
+/* Action frame categories (IEEE Std 802.11-2016, 9.4.1.11, Table 9-76) */
+#define WLAN_ACTION_SPECTRUM_MGMT 0
+#define WLAN_ACTION_QOS 1
+#define WLAN_ACTION_DLS 2
+#define WLAN_ACTION_BLOCK_ACK 3
+#define WLAN_ACTION_PUBLIC 4
+#define WLAN_ACTION_RADIO_MEASUREMENT 5
+#define WLAN_ACTION_FT 6
+#define WLAN_ACTION_HT 7
+#define WLAN_ACTION_SA_QUERY 8
+#define WLAN_ACTION_PROTECTED_DUAL 9
+#define WLAN_ACTION_WNM 10
+#define WLAN_ACTION_UNPROTECTED_WNM 11
+#define WLAN_ACTION_TDLS 12
+#define WLAN_ACTION_MESH 13
+#define WLAN_ACTION_MULTIHOP 14
+#define WLAN_ACTION_SELF_PROTECTED 15
+#define WLAN_ACTION_DMG 16
+#define WLAN_ACTION_WMM 17 /* WMM Specification 1.1 */
+#define WLAN_ACTION_FST 18
+#define WLAN_ACTION_ROBUST_AV_STREAMING 19
+#define WLAN_ACTION_UNPROTECTED_DMG 20
+#define WLAN_ACTION_VHT 21
+#define WLAN_ACTION_FILS 26
+#define WLAN_ACTION_VENDOR_SPECIFIC_PROTECTED 126
+#define WLAN_ACTION_VENDOR_SPECIFIC 127
+/* Note: 128-255 used to report errors by setting category | 0x80 */
+
+/* Public action codes (IEEE Std 802.11-2016, 9.6.8.1, Table 9-307) */
+#define WLAN_PA_20_40_BSS_COEX 0
+#define WLAN_PA_DSE_ENABLEMENT 1
+#define WLAN_PA_DSE_DEENABLEMENT 2
+#define WLAN_PA_DSE_REG_LOCATION_ANNOUNCE 3
+#define WLAN_PA_EXT_CHANNEL_SWITCH_ANNOUNCE 4
+#define WLAN_PA_DSE_MEASUREMENT_REQ 5
+#define WLAN_PA_DSE_MEASUREMENT_RESP 6
+#define WLAN_PA_MEASUREMENT_PILOT 7
+#define WLAN_PA_DSE_POWER_CONSTRAINT 8
+#define WLAN_PA_VENDOR_SPECIFIC 9
+#define WLAN_PA_GAS_INITIAL_REQ 10
+#define WLAN_PA_GAS_INITIAL_RESP 11
+#define WLAN_PA_GAS_COMEBACK_REQ 12
+#define WLAN_PA_GAS_COMEBACK_RESP 13
+#define WLAN_TDLS_DISCOVERY_RESPONSE 14
+#define WLAN_PA_LOCATION_TRACK_NOTIFICATION 15
+#define WLAN_PA_QAB_REQUEST_FRAME 16
+#define WLAN_PA_QAB_RESPONSE_FRAME 17
+#define WLAN_PA_QMF_POLICY 18
+#define WLAN_PA_QMF_POLICY_CHANGE 19
+#define WLAN_PA_QLOAD_REQUEST 20
+#define WLAN_PA_QLOAD_REPORT 21
+#define WLAN_PA_HCCA_TXOP_ADVERTISEMENT 22
+#define WLAN_PA_HCCA_TXOP_RESPONSE 23
+#define WLAN_PA_PUBLIC_KEY 24
+#define WLAN_PA_CHANNEL_AVAILABILITY_QUERY 25
+#define WLAN_PA_CHANNEL_SCHEDULE_MANAGEMENT 26
+#define WLAN_PA_CONTACT_VERIFICATION_SIGNAL 27
+#define WLAN_PA_GDD_ENABLEMENT_REQ 28
+#define WLAN_PA_GDD_ENABLEMENT_RESP 29
+#define WLAN_PA_NETWORK_CHANNEL_CONTROL 30
+#define WLAN_PA_WHITE_SPACE_MAP_ANNOUNCEMENT 31
+#define WLAN_PA_FTM_REQUEST 32
+#define WLAN_PA_FTM 33
+#define WLAN_PA_FILS_DISCOVERY 34
+
+/* Protected Dual of Public Action frames (IEEE Std 802.11-2016, 9.6.11,
+ * Table 9-332) */
+#define WLAN_PROT_DSE_ENABLEMENT 1
+#define WLAN_PROT_DSE_DEENABLEMENT 2
+#define WLAN_PROT_EXT_CSA 4
+#define WLAN_PROT_MEASUREMENT_REQ 5
+#define WLAN_PROT_MEASUREMENT_REPORT 6
+#define WLAN_PROT_DSE_POWER_CONSTRAINT 8
+#define WLAN_PROT_VENDOR_SPECIFIC 9
+#define WLAN_PROT_GAS_INITIAL_REQ 10
+#define WLAN_PROT_GAS_INITIAL_RESP 11
+#define WLAN_PROT_GAS_COMEBACK_REQ 12
+#define WLAN_PROT_GAS_COMEBACK_RESP 13
+#define WLAN_PROT_QAB_REQUEST_FRAME 16
+#define WLAN_PROT_QAB_RESPONSE_FRAME 17
+#define WLAN_PROT_QMF_POLICY 18
+#define WLAN_PROT_QMF_POLICY_CHANGE 19
+#define WLAN_PROT_QLOAD_REQUEST 20
+#define WLAN_PROT_QLOAD_REPORT 21
+#define WLAN_PROT_HCCA_TXOP_ADVERTISEMENT 22
+#define WLAN_PROT_HCCA_TXOP_RESPONSE 23
+#define WLAN_PROT_CHANNEL_AVAILABILITY_QUERY 25
+#define WLAN_PROT_CHANNEL_SCHEDULE_MANAGEMENT 26
+#define WLAN_PROT_CONTACT_VERIFICATION_SIGNAL 27
+#define WLAN_PROT_GDD_ENABLEMENT_REQ 28
+#define WLAN_PROT_GDD_ENABLEMENT_RESP 29
+#define WLAN_PROT_NETWORK_CHANNEL_CONTROL 30
+#define WLAN_PROT_WHITE_SPACE_MAP_ANNOUNCEMENT 31
+
+/* SA Query Action frame (IEEE 802.11w/D8.0, 7.4.9) */
+#define WLAN_SA_QUERY_REQUEST 0
+#define WLAN_SA_QUERY_RESPONSE 1
+
+#define WLAN_SA_QUERY_TR_ID_LEN 2
+
+/* TDLS action codes */
+#define WLAN_TDLS_SETUP_REQUEST 0
+#define WLAN_TDLS_SETUP_RESPONSE 1
+#define WLAN_TDLS_SETUP_CONFIRM 2
+#define WLAN_TDLS_TEARDOWN 3
+#define WLAN_TDLS_PEER_TRAFFIC_INDICATION 4
+#define WLAN_TDLS_CHANNEL_SWITCH_REQUEST 5
+#define WLAN_TDLS_CHANNEL_SWITCH_RESPONSE 6
+#define WLAN_TDLS_PEER_PSM_REQUEST 7
+#define WLAN_TDLS_PEER_PSM_RESPONSE 8
+#define WLAN_TDLS_PEER_TRAFFIC_RESPONSE 9
+#define WLAN_TDLS_DISCOVERY_REQUEST 10
+
+/* Radio Measurement Action codes */
+#define WLAN_RRM_RADIO_MEASUREMENT_REQUEST 0
+#define WLAN_RRM_RADIO_MEASUREMENT_REPORT 1
+#define WLAN_RRM_LINK_MEASUREMENT_REQUEST 2
+#define WLAN_RRM_LINK_MEASUREMENT_REPORT 3
+#define WLAN_RRM_NEIGHBOR_REPORT_REQUEST 4
+#define WLAN_RRM_NEIGHBOR_REPORT_RESPONSE 5
+
+/* Radio Measurement capabilities (from RM Enabled Capabilities element)
+ * IEEE Std 802.11-2016, 9.4.2.45, Table 9-157 */
+/* byte 1 (out of 5) */
+#define WLAN_RRM_CAPS_LINK_MEASUREMENT BIT(0)
+#define WLAN_RRM_CAPS_NEIGHBOR_REPORT BIT(1)
+#define WLAN_RRM_CAPS_BEACON_REPORT_PASSIVE BIT(4)
+#define WLAN_RRM_CAPS_BEACON_REPORT_ACTIVE BIT(5)
+#define WLAN_RRM_CAPS_BEACON_REPORT_TABLE BIT(6)
+/* byte 2 (out of 5) */
+#define WLAN_RRM_CAPS_LCI_MEASUREMENT BIT(4)
+/* byte 5 (out of 5) */
+#define WLAN_RRM_CAPS_FTM_RANGE_REPORT BIT(2)
+
+/*
+ * IEEE P802.11-REVmc/D5.0, 9.4.2.21.19 (Fine Timing Measurement Range
+ * request) - Minimum AP count
+ */
+#define WLAN_RRM_RANGE_REQ_MAX_MIN_AP 15
+
+/* Timeout Interval Type */
+#define WLAN_TIMEOUT_REASSOC_DEADLINE 1
+#define WLAN_TIMEOUT_KEY_LIFETIME 2
+#define WLAN_TIMEOUT_ASSOC_COMEBACK 3
+
+/* Interworking element (IEEE 802.11u) - Access Network Options */
+#define INTERWORKING_ANO_ACCESS_NETWORK_MASK 0x0f
+#define INTERWORKING_ANO_INTERNET 0x10
+#define INTERWORKING_ANO_ASRA 0x20
+#define INTERWORKING_ANO_ESR 0x40
+#define INTERWORKING_ANO_UESA 0x80
+
+#define INTERWORKING_ANT_PRIVATE 0
+#define INTERWORKING_ANT_PRIVATE_WITH_GUEST 1
+#define INTERWORKING_ANT_CHARGEABLE_PUBLIC 2
+#define INTERWORKING_ANT_FREE_PUBLIC 3
+#define INTERWORKING_ANT_PERSONAL_DEVICE 4
+#define INTERWORKING_ANT_EMERGENCY_SERVICES 5
+#define INTERWORKING_ANT_TEST 6
+#define INTERWORKING_ANT_WILDCARD 15
+
+/* Advertisement Protocol ID definitions (IEEE Std 802.11-2016, Table 9-215) */
+enum adv_proto_id {
+	ACCESS_NETWORK_QUERY_PROTOCOL = 0,
+	MIH_INFO_SERVICE = 1,
+	MIH_CMD_AND_EVENT_DISCOVERY = 2,
+	EMERGENCY_ALERT_SYSTEM = 3,
+	REGISTERED_LOCATION_QUERY_PROTO = 4,
+	ADV_PROTO_VENDOR_SPECIFIC = 221
+};
+
+/* Access Network Query Protocol info ID definitions (IEEE Std 802.11-2016,
+ * Table 9-271; P802.11ai) */
+enum anqp_info_id {
+	ANQP_QUERY_LIST = 256,
+	ANQP_CAPABILITY_LIST = 257,
+	ANQP_VENUE_NAME = 258,
+	ANQP_EMERGENCY_CALL_NUMBER = 259,
+	ANQP_NETWORK_AUTH_TYPE = 260,
+	ANQP_ROAMING_CONSORTIUM = 261,
+	ANQP_IP_ADDR_TYPE_AVAILABILITY = 262,
+	ANQP_NAI_REALM = 263,
+	ANQP_3GPP_CELLULAR_NETWORK = 264,
+	ANQP_AP_GEOSPATIAL_LOCATION = 265,
+	ANQP_AP_CIVIC_LOCATION = 266,
+	ANQP_AP_LOCATION_PUBLIC_URI = 267,
+	ANQP_DOMAIN_NAME = 268,
+	ANQP_EMERGENCY_ALERT_URI = 269,
+	ANQP_TDLS_CAPABILITY = 270,
+	ANQP_EMERGENCY_NAI = 271,
+	ANQP_NEIGHBOR_REPORT = 272,
+	ANQP_QUERY_AP_LIST = 273,
+	ANQP_AP_LIST_RESPONSE = 274,
+	ANQP_FILS_REALM_INFO = 275,
+	ANQP_CAG = 276,
+	ANQP_VENUE_URL = 277,
+	ANQP_ADVICE_OF_CHARGE = 278,
+	ANQP_LOCAL_CONTENT = 279,
+	ANQP_NETWORK_AUTH_TYPE_TIMESTAMP = 280,
+	ANQP_VENDOR_SPECIFIC = 56797
+};
+
+/* NAI Realm list - EAP Method subfield - Authentication Parameter ID */
+enum nai_realm_eap_auth_param {
+	NAI_REALM_EAP_AUTH_EXPANDED_EAP_METHOD = 1,
+	NAI_REALM_EAP_AUTH_NON_EAP_INNER_AUTH = 2,
+	NAI_REALM_EAP_AUTH_INNER_AUTH_EAP_METHOD = 3,
+	NAI_REALM_EAP_AUTH_EXPANDED_INNER_EAP_METHOD = 4,
+	NAI_REALM_EAP_AUTH_CRED_TYPE = 5,
+	NAI_REALM_EAP_AUTH_TUNNELED_CRED_TYPE = 6,
+	NAI_REALM_EAP_AUTH_VENDOR_SPECIFIC = 221
+};
+
+enum nai_realm_eap_auth_inner_non_eap {
+	NAI_REALM_INNER_NON_EAP_PAP = 1,
+	NAI_REALM_INNER_NON_EAP_CHAP = 2,
+	NAI_REALM_INNER_NON_EAP_MSCHAP = 3,
+	NAI_REALM_INNER_NON_EAP_MSCHAPV2 = 4
+};
+
+enum nai_realm_eap_cred_type {
+	NAI_REALM_CRED_TYPE_SIM = 1,
+	NAI_REALM_CRED_TYPE_USIM = 2,
+	NAI_REALM_CRED_TYPE_NFC_SECURE_ELEMENT = 3,
+	NAI_REALM_CRED_TYPE_HARDWARE_TOKEN = 4,
+	NAI_REALM_CRED_TYPE_SOFTOKEN = 5,
+	NAI_REALM_CRED_TYPE_CERTIFICATE = 6,
+	NAI_REALM_CRED_TYPE_USERNAME_PASSWORD = 7,
+	NAI_REALM_CRED_TYPE_NONE = 8,
+	NAI_REALM_CRED_TYPE_ANONYMOUS = 9,
+	NAI_REALM_CRED_TYPE_VENDOR_SPECIFIC = 10
+};
+
+/*
+ * IEEE P802.11-REVmc/D5.0 Table 9-81 - Measurement type definitions for
+ * measurement requests
+ */
+enum measure_type {
+	MEASURE_TYPE_BASIC = 0,
+	MEASURE_TYPE_CCA = 1,
+	MEASURE_TYPE_RPI_HIST = 2,
+	MEASURE_TYPE_CHANNEL_LOAD = 3,
+	MEASURE_TYPE_NOISE_HIST = 4,
+	MEASURE_TYPE_BEACON = 5,
+	MEASURE_TYPE_FRAME = 6,
+	MEASURE_TYPE_STA_STATISTICS = 7,
+	MEASURE_TYPE_LCI = 8,
+	MEASURE_TYPE_TRANSMIT_STREAM = 9,
+	MEASURE_TYPE_MULTICAST_DIAG = 10,
+	MEASURE_TYPE_LOCATION_CIVIC = 11,
+	MEASURE_TYPE_LOCATION_ID = 12,
+	MEASURE_TYPE_DIRECTIONAL_CHAN_QUALITY = 13,
+	MEASURE_TYPE_DIRECTIONAL_MEASURE = 14,
+	MEASURE_TYPE_DIRECTIONAL_STATS = 15,
+	MEASURE_TYPE_FTM_RANGE = 16,
+	MEASURE_TYPE_MEASURE_PAUSE = 255,
+};
+
+/* IEEE Std 802.11-2012 Table 8-71 - Location subject definition */
+enum location_subject {
+	LOCATION_SUBJECT_LOCAL = 0,
+	LOCATION_SUBJECT_REMOTE = 1,
+	LOCATION_SUBJECT_3RD_PARTY = 2,
+};
+
+/*
+ * IEEE P802.11-REVmc/D5.0 Table 9-94 - Optional subelement IDs for LCI request
+ */
+enum lci_req_subelem {
+	LCI_REQ_SUBELEM_AZIMUTH_REQ = 1,
+	LCI_REQ_SUBELEM_ORIGINATOR_MAC_ADDR = 2,
+	LCI_REQ_SUBELEM_TARGET_MAC_ADDR = 3,
+	LCI_REQ_SUBELEM_MAX_AGE = 4,
+};
+
+#define FILS_NONCE_LEN 16
+#define FILS_SESSION_LEN 8
+#define FILS_CACHE_ID_LEN 2
+#define FILS_MAX_KEY_AUTH_LEN 48
+
+#ifdef _MSC_VER
+#pragma pack(push, 1)
+#endif /* _MSC_VER */
+
+struct ieee80211_hdr {
+	le16 frame_control;
+	le16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	le16 seq_ctrl;
+	/* followed by 'u8 addr4[6];' if ToDS and FromDS is set in data frame
+	 */
+} STRUCT_PACKED;
+
+#define IEEE80211_DA_FROMDS addr1
+#define IEEE80211_BSSID_FROMDS addr2
+#define IEEE80211_SA_FROMDS addr3
+
+#define IEEE80211_HDRLEN (sizeof(struct ieee80211_hdr))
+
+#define IEEE80211_FC(type, stype) host_to_le16((type << 2) | (stype << 4))
+
+struct ieee80211_mgmt {
+	le16 frame_control;
+	le16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	le16 seq_ctrl;
+	union {
+		struct {
+			le16 auth_alg;
+			le16 auth_transaction;
+			le16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[];
+		} STRUCT_PACKED auth;
+		struct {
+			le16 reason_code;
+			u8 variable[];
+		} STRUCT_PACKED deauth;
+		struct {
+			le16 capab_info;
+			le16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[];
+		} STRUCT_PACKED assoc_req;
+		struct {
+			le16 capab_info;
+			le16 status_code;
+			le16 aid;
+			/* followed by Supported rates */
+			u8 variable[];
+		} STRUCT_PACKED assoc_resp, reassoc_resp;
+		struct {
+			le16 capab_info;
+			le16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[];
+		} STRUCT_PACKED reassoc_req;
+		struct {
+			le16 reason_code;
+			u8 variable[];
+		} STRUCT_PACKED disassoc;
+		struct {
+			u8 timestamp[8];
+			le16 beacon_int;
+			le16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[];
+		} STRUCT_PACKED beacon;
+		/* probe_req: only variable items: SSID, Supported rates */
+		struct {
+			u8 timestamp[8];
+			le16 beacon_int;
+			le16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[];
+		} STRUCT_PACKED probe_resp;
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[];
+				} STRUCT_PACKED wmm_action;
+				struct{
+					u8 action_code;
+					u8 element_id;
+					u8 length;
+					u8 switch_mode;
+					u8 new_chan;
+					u8 switch_count;
+				} STRUCT_PACKED chan_switch;
+				struct {
+					u8 action;
+					u8 sta_addr[ETH_ALEN];
+					u8 target_ap_addr[ETH_ALEN];
+					u8 variable[]; /* FT Request */
+				} STRUCT_PACKED ft_action_req;
+				struct {
+					u8 action;
+					u8 sta_addr[ETH_ALEN];
+					u8 target_ap_addr[ETH_ALEN];
+					le16 status_code;
+					u8 variable[]; /* FT Request */
+				} STRUCT_PACKED ft_action_resp;
+				struct {
+					u8 action;
+					u8 trans_id[WLAN_SA_QUERY_TR_ID_LEN];
+					u8 variable[]; /* OCI element */
+				} STRUCT_PACKED sa_query_req;
+				struct {
+					u8 action; /* */
+					u8 trans_id[WLAN_SA_QUERY_TR_ID_LEN];
+					u8 variable[]; /* OCI element */
+				} STRUCT_PACKED sa_query_resp;
+				struct {
+					u8 action;
+					u8 dialogtoken;
+					u8 variable[];
+				} STRUCT_PACKED wnm_sleep_req;
+				struct {
+					u8 action;
+					u8 dialogtoken;
+					le16 keydata_len;
+					u8 variable[];
+				} STRUCT_PACKED wnm_sleep_resp;
+				struct {
+					u8 action;
+					u8 variable[];
+				} STRUCT_PACKED public_action;
+				struct {
+					u8 action; /* 9 */
+					u8 oui[3];
+					/* Vendor-specific content */
+					u8 variable[];
+				} STRUCT_PACKED vs_public_action;
+				struct {
+					u8 action; /* 7 */
+					u8 dialog_token;
+					u8 req_mode;
+					le16 disassoc_timer;
+					u8 validity_interval;
+					/* BSS Termination Duration (optional),
+					 * Session Information URL (optional),
+					 * BSS Transition Candidate List
+					 * Entries */
+					u8 variable[];
+				} STRUCT_PACKED bss_tm_req;
+				struct {
+					u8 action; /* 8 */
+					u8 dialog_token;
+					u8 status_code;
+					u8 bss_termination_delay;
+					/* Target BSSID (optional),
+					 * BSS Transition Candidate List
+					 * Entries (optional) */
+					u8 variable[];
+				} STRUCT_PACKED bss_tm_resp;
+				struct {
+					u8 action; /* 6 */
+					u8 dialog_token;
+					u8 query_reason;
+					/* BSS Transition Candidate List
+					 * Entries (optional) */
+					u8 variable[];
+				} STRUCT_PACKED bss_tm_query;
+				struct {
+					u8 action; /* 11 */
+					u8 dialog_token;
+					u8 req_info;
+				} STRUCT_PACKED coloc_intf_req;
+				struct {
+					u8 action; /* 12 */
+					u8 dialog_token;
+					u8 variable[];
+				} STRUCT_PACKED coloc_intf_report;
+				struct {
+					u8 action; /* 15 */
+					u8 variable[];
+				} STRUCT_PACKED slf_prot_action;
+				struct {
+					u8 action;
+					u8 variable[];
+				} STRUCT_PACKED fst_action;
+				struct {
+					u8 action;
+					u8 dialog_token;
+					u8 variable[];
+				} STRUCT_PACKED rrm;
+			} u;
+		} STRUCT_PACKED action;
+	} u;
+} STRUCT_PACKED;
+
+
+#define IEEE80211_MAX_MMPDU_SIZE 2304
+
+/* Rx MCS bitmask is in the first 77 bits of supported_mcs_set */
+#define IEEE80211_HT_MCS_MASK_LEN 10
+
+/* HT Capabilities element */
+struct ieee80211_ht_capabilities {
+	le16 ht_capabilities_info;
+	u8 a_mpdu_params; /* Maximum A-MPDU Length Exponent B0..B1
+			   * Minimum MPDU Start Spacing B2..B4
+			   * Reserved B5..B7 */
+	u8 supported_mcs_set[16];
+	le16 ht_extended_capabilities;
+	le32 tx_bf_capability_info;
+	u8 asel_capabilities;
+} STRUCT_PACKED;
+
+
+/* HT Operation element */
+struct ieee80211_ht_operation {
+	u8 primary_chan;
+	/* Five octets of HT Operation Information */
+	u8 ht_param; /* B0..B7 */
+	le16 operation_mode; /* B8..B23 */
+	le16 param; /* B24..B39 */
+	u8 basic_mcs_set[16];
+} STRUCT_PACKED;
+
+
+struct ieee80211_obss_scan_parameters {
+	le16 scan_passive_dwell;
+	le16 scan_active_dwell;
+	le16 width_trigger_scan_interval;
+	le16 scan_passive_total_per_channel;
+	le16 scan_active_total_per_channel;
+	le16 channel_transition_delay_factor;
+	le16 scan_activity_threshold;
+} STRUCT_PACKED;
+
+
+struct ieee80211_vht_capabilities {
+	le32 vht_capabilities_info;
+	struct {
+		le16 rx_map;
+		le16 rx_highest;
+		le16 tx_map;
+		le16 tx_highest;
+	} vht_supported_mcs_set;
+} STRUCT_PACKED;
+
+struct ieee80211_vht_operation {
+	u8 vht_op_info_chwidth;
+	u8 vht_op_info_chan_center_freq_seg0_idx;
+	u8 vht_op_info_chan_center_freq_seg1_idx;
+	le16 vht_basic_mcs_set;
+} STRUCT_PACKED;
+
+struct ieee80211_ampe_ie {
+	u8 selected_pairwise_suite[4];
+	u8 local_nonce[32];
+	u8 peer_nonce[32];
+	/* Followed by
+	 * Key Replay Counter[8] (optional)
+	 *	(only in Mesh Group Key Inform/Acknowledge frames)
+	 * GTKdata[variable] (optional)
+	 *	(MGTK[variable] || Key RSC[8] || GTKExpirationTime[4])
+	 * IGTKdata[variable] (optional)
+	 *	(Key ID[2], IPN[6], IGTK[variable] in IGTK KDE format)
+	 */
+} STRUCT_PACKED;
+
+#ifdef _MSC_VER
+#pragma pack(pop)
+#endif /* _MSC_VER */
+
+#define ERP_INFO_NON_ERP_PRESENT BIT(0)
+#define ERP_INFO_USE_PROTECTION BIT(1)
+#define ERP_INFO_BARKER_PREAMBLE_MODE BIT(2)
+
+#define OVERLAPPING_BSS_TRANS_DELAY_FACTOR 5
+
+/* HT Capabilities Info field within HT Capabilities element */
+#define HT_CAP_INFO_LDPC_CODING_CAP		((u16) BIT(0))
+#define HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET	((u16) BIT(1))
+#define HT_CAP_INFO_SMPS_MASK			((u16) (BIT(2) | BIT(3)))
+#define HT_CAP_INFO_SMPS_STATIC			((u16) 0)
+#define HT_CAP_INFO_SMPS_DYNAMIC		((u16) BIT(2))
+#define HT_CAP_INFO_SMPS_DISABLED		((u16) (BIT(2) | BIT(3)))
+#define HT_CAP_INFO_GREEN_FIELD			((u16) BIT(4))
+#define HT_CAP_INFO_SHORT_GI20MHZ		((u16) BIT(5))
+#define HT_CAP_INFO_SHORT_GI40MHZ		((u16) BIT(6))
+#define HT_CAP_INFO_TX_STBC			((u16) BIT(7))
+#define HT_CAP_INFO_RX_STBC_MASK		((u16) (BIT(8) | BIT(9)))
+#define HT_CAP_INFO_RX_STBC_1			((u16) BIT(8))
+#define HT_CAP_INFO_RX_STBC_12			((u16) BIT(9))
+#define HT_CAP_INFO_RX_STBC_123			((u16) (BIT(8) | BIT(9)))
+#define HT_CAP_INFO_DELAYED_BA			((u16) BIT(10))
+#define HT_CAP_INFO_MAX_AMSDU_SIZE		((u16) BIT(11))
+#define HT_CAP_INFO_DSSS_CCK40MHZ		((u16) BIT(12))
+/* B13 - Reserved (was PSMP support during P802.11n development) */
+#define HT_CAP_INFO_40MHZ_INTOLERANT		((u16) BIT(14))
+#define HT_CAP_INFO_LSIG_TXOP_PROTECT_SUPPORT	((u16) BIT(15))
+
+/* HT Extended Capabilities field within HT Capabilities element */
+#define EXT_HT_CAP_INFO_PCO			((u16) BIT(0))
+#define EXT_HT_CAP_INFO_PCO_TRANS_TIME_MASK	((u16) (BIT(1) | BIT(2)))
+#define EXT_HT_CAP_INFO_TRANS_TIME_OFFSET	1
+/* B3..B7 - Reserved */
+#define EXT_HT_CAP_INFO_MCS_FEEDBACK_MASK	((u16) (BIT(8) | BIT(9)))
+#define EXT_HT_CAP_INFO_MCS_FEEDBACK_OFFSET	8
+#define EXT_HT_CAP_INFO_HTC_SUPPORT		((u16) BIT(10))
+#define EXT_HT_CAP_INFO_RD_RESPONDER		((u16) BIT(11))
+/* B12..B15 - Reserved */
+
+/* Transmit Beanforming Capabilities within HT Capabilities element */
+#define TX_BF_CAP_IMPLICIT_TXBF_RX_CAP ((u32) BIT(0))
+#define TX_BF_CAP_RX_STAGGERED_SOUNDING_CAP ((u32) BIT(1))
+#define TX_BF_CAP_TX_STAGGERED_SOUNDING_CAP ((u32) BIT(2))
+#define TX_BF_CAP_RX_NDP_CAP ((u32) BIT(3))
+#define TX_BF_CAP_TX_NDP_CAP ((u32) BIT(4))
+#define TX_BF_CAP_IMPLICIT_TX_BF_CAP ((u32) BIT(5))
+#define TX_BF_CAP_CALIBRATION_MASK ((u32) (BIT(6) | BIT(7))
+#define TX_BF_CAP_CALIB_OFFSET 6
+#define TX_BF_CAP_EXPLICIT_CSI_TXBF_CAP ((u32) BIT(8))
+#define TX_BF_CAP_EXPLICIT_NONCOMPR_STEERING_CAP ((u32) BIT(9))
+#define TX_BF_CAP_EXPLICIT_COMPR_STEERING_CAP ((u32) BIT(10))
+#define TX_BF_CAP_EXPLICIT_TX_BF_CSI_FEEDBACK_MASK ((u32) (BIT(10) | BIT(11)))
+#define TX_BF_CAP_EXPLICIT_BF_CSI_FEEDBACK_OFFSET 11
+#define TX_BF_CAP_EXPLICIT_UNCOMPR_STEERING_MATRIX_FEEDBACK_OFFSET 13
+#define TX_BF_CAP_EXPLICIT_COMPRESSED_STEERING_MATRIX_FEEDBACK_OFFSET 15
+#define TX_BF_CAP_MINIMAL_GROUPING_OFFSET 17
+#define TX_BF_CAP_CSI_NUM_BEAMFORMER_ANT_OFFSET 19
+#define TX_BF_CAP_UNCOMPRESSED_STEERING_MATRIX_BEAMFORMER_ANT_OFFSET 21
+#define TX_BF_CAP_COMPRESSED_STEERING_MATRIX_BEAMFORMER_ANT_OFFSET 23
+#define TX_BF_CAP_SCI_MAX_OF_ROWS_BEANFORMER_SUPPORTED_OFFSET 25
+#define TX_BF_CAP_CHANNEL_ESTIMATION_CAP_MASK ((u32) (BIT(27) | BIT(28)))
+#define TX_BF_CAP_CHANNEL_ESTIMATION_CAP_OFFSET 27
+/* B29..B31 - Reserved */
+
+/* ASEL Capability field within HT Capabilities element */
+#define ASEL_CAP_ASEL_CAPABLE ((u8) BIT(0))
+#define ASEL_CAP_EXPLICIT_CSI_FEEDBACK_BASED_TX_AS_CAP ((u8) BIT(1))
+#define ASEL_CAP_ANT_INDICES_FEEDBACK_BASED_TX_AS_CAP ((u8) BIT(2))
+#define ASEL_CAP_EXPLICIT_CSI_FEEDBACK_CAP ((u8) BIT(3))
+#define ASEL_CAP_ANT_INDICES_FEEDBACK_CAP ((u8) BIT(4))
+#define ASEL_CAP_RX_AS_CAP ((u8) BIT(5))
+#define ASEL_CAP_TX_SOUNDING_PPDUS_CAP ((u8) BIT(6))
+/* B7 - Reserved */
+
+/* First octet of HT Operation Information within HT Operation element */
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK	((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE		((u8) BIT(0))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW		((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_STA_CHNL_WIDTH			((u8) BIT(2))
+#define HT_INFO_HT_PARAM_RIFS_MODE			((u8) BIT(3))
+/* B4..B7 - Reserved */
+
+/* HT Protection (B8..B9 of HT Operation Information) */
+#define HT_PROT_NO_PROTECTION           0
+#define HT_PROT_NONMEMBER_PROTECTION    1
+#define HT_PROT_20MHZ_PROTECTION        2
+#define HT_PROT_NON_HT_MIXED            3
+/* Bits within ieee80211_ht_operation::operation_mode (BIT(0) maps to B8 in
+ * HT Operation Information) */
+#define HT_OPER_OP_MODE_HT_PROT_MASK ((u16) (BIT(0) | BIT(1))) /* B8..B9 */
+#define HT_OPER_OP_MODE_NON_GF_HT_STAS_PRESENT	((u16) BIT(2)) /* B10 */
+/* BIT(3), i.e., B11 in HT Operation Information field - Reserved */
+#define HT_OPER_OP_MODE_OBSS_NON_HT_STAS_PRESENT	((u16) BIT(4)) /* B12 */
+/* BIT(5)..BIT(15), i.e., B13..B23 - Reserved */
+
+/* Last two octets of HT Operation Information (BIT(0) = B24) */
+/* B24..B29 - Reserved */
+#define HT_OPER_PARAM_DUAL_BEACON			((u16) BIT(6))
+#define HT_OPER_PARAM_DUAL_CTS_PROTECTION		((u16) BIT(7))
+#define HT_OPER_PARAM_STBC_BEACON			((u16) BIT(8))
+#define HT_OPER_PARAM_LSIG_TXOP_PROT_FULL_SUPP		((u16) BIT(9))
+#define HT_OPER_PARAM_PCO_ACTIVE			((u16) BIT(10))
+#define HT_OPER_PARAM_PCO_PHASE				((u16) BIT(11))
+/* B36..B39 - Reserved */
+
+#define BSS_MEMBERSHIP_SELECTOR_VHT_PHY 126
+#define BSS_MEMBERSHIP_SELECTOR_HT_PHY 127
+#define BSS_MEMBERSHIP_SELECTOR_SAE_H2E_ONLY 123
+
+/* VHT Defines */
+#define VHT_CAP_MAX_MPDU_LENGTH_7991                ((u32) BIT(0))
+#define VHT_CAP_MAX_MPDU_LENGTH_11454               ((u32) BIT(1))
+#define VHT_CAP_MAX_MPDU_LENGTH_MASK                ((u32) BIT(0) | BIT(1))
+#define VHT_CAP_MAX_MPDU_LENGTH_MASK_SHIFT          0
+#define VHT_CAP_SUPP_CHAN_WIDTH_160MHZ              ((u32) BIT(2))
+#define VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ     ((u32) BIT(3))
+#define VHT_CAP_SUPP_CHAN_WIDTH_MASK                ((u32) BIT(2) | BIT(3))
+#define VHT_CAP_SUPP_CHAN_WIDTH_MASK_SHIFT          2
+#define VHT_CAP_RXLDPC                              ((u32) BIT(4))
+#define VHT_CAP_SHORT_GI_80                         ((u32) BIT(5))
+#define VHT_CAP_SHORT_GI_160                        ((u32) BIT(6))
+#define VHT_CAP_TXSTBC                              ((u32) BIT(7))
+#define VHT_CAP_RXSTBC_1                            ((u32) BIT(8))
+#define VHT_CAP_RXSTBC_2                            ((u32) BIT(9))
+#define VHT_CAP_RXSTBC_3                            ((u32) BIT(8) | BIT(9))
+#define VHT_CAP_RXSTBC_4                            ((u32) BIT(10))
+#define VHT_CAP_RXSTBC_MASK                         ((u32) BIT(8) | BIT(9) | \
+							   BIT(10))
+#define VHT_CAP_RXSTBC_MASK_SHIFT                   8
+#define VHT_CAP_SU_BEAMFORMER_CAPABLE               ((u32) BIT(11))
+#define VHT_CAP_SU_BEAMFORMEE_CAPABLE               ((u32) BIT(12))
+#define VHT_CAP_BEAMFORMEE_STS_MAX                  ((u32) BIT(13) | \
+							   BIT(14) | BIT(15))
+#define VHT_CAP_BEAMFORMEE_STS_MAX_SHIFT            13
+#define VHT_CAP_BEAMFORMEE_STS_OFFSET               13
+#define VHT_CAP_SOUNDING_DIMENSION_MAX              ((u32) BIT(16) | \
+							   BIT(17) | BIT(18))
+#define VHT_CAP_SOUNDING_DIMENSION_MAX_SHIFT        16
+#define VHT_CAP_SOUNDING_DIMENSION_OFFSET           16
+#define VHT_CAP_MU_BEAMFORMER_CAPABLE               ((u32) BIT(19))
+#define VHT_CAP_MU_BEAMFORMEE_CAPABLE               ((u32) BIT(20))
+#define VHT_CAP_VHT_TXOP_PS                         ((u32) BIT(21))
+#define VHT_CAP_HTC_VHT                             ((u32) BIT(22))
+
+#define VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_1        ((u32) BIT(23))
+#define VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_2        ((u32) BIT(24))
+#define VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_3        ((u32) BIT(23) | BIT(24))
+#define VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_4        ((u32) BIT(25))
+#define VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_5        ((u32) BIT(23) | BIT(25))
+#define VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_6        ((u32) BIT(24) | BIT(25))
+#define VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MAX      ((u32) BIT(23) | \
+							   BIT(24) | BIT(25))
+#define VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MAX_SHIFT 23
+#define VHT_CAP_VHT_LINK_ADAPTATION_VHT_UNSOL_MFB   ((u32) BIT(27))
+#define VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB     ((u32) BIT(26) | BIT(27))
+#define VHT_CAP_RX_ANTENNA_PATTERN                  ((u32) BIT(28))
+#define VHT_CAP_TX_ANTENNA_PATTERN                  ((u32) BIT(29))
+
+#define VHT_OPMODE_CHANNEL_WIDTH_MASK		    ((u8) BIT(0) | BIT(1))
+#define VHT_OPMODE_CHANNEL_RxNSS_MASK		    ((u8) BIT(4) | BIT(5) | \
+						     BIT(6))
+#define VHT_OPMODE_NOTIF_RX_NSS_SHIFT		    4
+
+#define VHT_RX_NSS_MAX_STREAMS			    8
+
+/* VHT/EDMG channel widths */
+#define CHANWIDTH_USE_HT	0
+#define CHANWIDTH_80MHZ		1
+#define CHANWIDTH_160MHZ	2
+#define CHANWIDTH_80P80MHZ	3
+#define CHANWIDTH_2160MHZ	4
+#define CHANWIDTH_4320MHZ	5
+#define CHANWIDTH_6480MHZ	6
+#define CHANWIDTH_8640MHZ	7
+
+#define HE_NSS_MAX_STREAMS			    8
+
+#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
+				* 00:50:F2 */
+#define WPA_IE_VENDOR_TYPE 0x0050f201
+#define WMM_IE_VENDOR_TYPE 0x0050f202
+#define WPS_IE_VENDOR_TYPE 0x0050f204
+#define OUI_WFA 0x506f9a
+#define P2P_IE_VENDOR_TYPE 0x506f9a09
+#define WFD_IE_VENDOR_TYPE 0x506f9a0a
+#define WFD_OUI_TYPE 10
+#define HS20_IE_VENDOR_TYPE 0x506f9a10
+#define OSEN_IE_VENDOR_TYPE 0x506f9a12
+#define MBO_IE_VENDOR_TYPE 0x506f9a16
+#define MBO_OUI_TYPE 22
+#define OWE_IE_VENDOR_TYPE 0x506f9a1c
+#define OWE_OUI_TYPE 28
+#define MULTI_AP_OUI_TYPE 0x1B
+#define DPP_CC_IE_VENDOR_TYPE 0x506f9a1e
+#define DPP_CC_OUI_TYPE 0x1e
+#define SAE_PK_IE_VENDOR_TYPE 0x506f9a1f
+#define SAE_PK_OUI_TYPE 0x1f
+
+#define MULTI_AP_SUB_ELEM_TYPE 0x06
+#define MULTI_AP_TEAR_DOWN BIT(4)
+#define MULTI_AP_FRONTHAUL_BSS BIT(5)
+#define MULTI_AP_BACKHAUL_BSS BIT(6)
+#define MULTI_AP_BACKHAUL_STA BIT(7)
+
+#define WMM_OUI_TYPE 2
+#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WMM_VERSION 1
+
+#define WMM_ACTION_CODE_ADDTS_REQ 0
+#define WMM_ACTION_CODE_ADDTS_RESP 1
+#define WMM_ACTION_CODE_DELTS 2
+
+#define WMM_ADDTS_STATUS_ADMISSION_ACCEPTED 0
+#define WMM_ADDTS_STATUS_INVALID_PARAMETERS 1
+/* 2 - Reserved */
+#define WMM_ADDTS_STATUS_REFUSED 3
+/* 4-255 - Reserved */
+
+/* WMM TSPEC Direction Field Values */
+#define WMM_TSPEC_DIRECTION_UPLINK 0
+#define WMM_TSPEC_DIRECTION_DOWNLINK 1
+/* 2 - Reserved */
+#define WMM_TSPEC_DIRECTION_BI_DIRECTIONAL 3
+
+/*
+ * WMM Information Element (used in (Re)Association Request frames; may also be
+ * used in Beacon frames)
+ */
+struct wmm_information_element {
+	/* Element ID: 221 (0xdd); Length: 7 */
+	/* required fields for WMM version 1 */
+	u8 oui[3]; /* 00:50:f2 */
+	u8 oui_type; /* 2 */
+	u8 oui_subtype; /* 0 */
+	u8 version; /* 1 for WMM version 1.0 */
+	u8 qos_info; /* AP/STA specific QoS info */
+
+} STRUCT_PACKED;
+
+#define WMM_QOSINFO_AP_UAPSD 0x80
+
+#define WMM_QOSINFO_STA_AC_MASK 0x0f
+#define WMM_QOSINFO_STA_SP_MASK 0x03
+#define WMM_QOSINFO_STA_SP_SHIFT 5
+
+#define WMM_AC_AIFSN_MASK 0x0f
+#define WMM_AC_AIFNS_SHIFT 0
+#define WMM_AC_ACM 0x10
+#define WMM_AC_ACI_MASK 0x60
+#define WMM_AC_ACI_SHIFT 5
+
+#define WMM_AC_ECWMIN_MASK 0x0f
+#define WMM_AC_ECWMIN_SHIFT 0
+#define WMM_AC_ECWMAX_MASK 0xf0
+#define WMM_AC_ECWMAX_SHIFT 4
+
+struct wmm_ac_parameter {
+	u8 aci_aifsn; /* AIFSN, ACM, ACI */
+	u8 cw; /* ECWmin, ECWmax (CW = 2^ECW - 1) */
+	le16 txop_limit;
+}  STRUCT_PACKED;
+
+/*
+ * WMM Parameter Element (used in Beacon, Probe Response, and (Re)Association
+ * Response frmaes)
+ */
+struct wmm_parameter_element {
+	/* Element ID: 221 (0xdd); Length: 24 */
+	/* required fields for WMM version 1 */
+	u8 oui[3]; /* 00:50:f2 */
+	u8 oui_type; /* 2 */
+	u8 oui_subtype; /* 1 */
+	u8 version; /* 1 for WMM version 1.0 */
+	u8 qos_info; /* AP/STA specific QoS info */
+	u8 reserved; /* 0 */
+	struct wmm_ac_parameter ac[4]; /* AC_BE, AC_BK, AC_VI, AC_VO */
+
+} STRUCT_PACKED;
+
+/* WMM TSPEC Element */
+struct wmm_tspec_element {
+	u8 eid; /* 221 = 0xdd */
+	u8 length; /* 6 + 55 = 61 */
+	u8 oui[3]; /* 00:50:f2 */
+	u8 oui_type; /* 2 */
+	u8 oui_subtype; /* 2 */
+	u8 version; /* 1 */
+	/* WMM TSPEC body (55 octets): */
+	u8 ts_info[3];
+	le16 nominal_msdu_size;
+	le16 maximum_msdu_size;
+	le32 minimum_service_interval;
+	le32 maximum_service_interval;
+	le32 inactivity_interval;
+	le32 suspension_interval;
+	le32 service_start_time;
+	le32 minimum_data_rate;
+	le32 mean_data_rate;
+	le32 peak_data_rate;
+	le32 maximum_burst_size;
+	le32 delay_bound;
+	le32 minimum_phy_rate;
+	le16 surplus_bandwidth_allowance;
+	le16 medium_time;
+} STRUCT_PACKED;
+
+
+/* Access Categories / ACI to AC coding */
+enum wmm_ac {
+	WMM_AC_BE = 0 /* Best Effort */,
+	WMM_AC_BK = 1 /* Background */,
+	WMM_AC_VI = 2 /* Video */,
+	WMM_AC_VO = 3 /* Voice */,
+	WMM_AC_NUM = 4
+};
+
+
+#define HS20_INDICATION_OUI_TYPE 16
+#define HS20_ANQP_OUI_TYPE 17
+#define HS20_OSEN_OUI_TYPE 18
+#define HS20_ROAMING_CONS_SEL_OUI_TYPE 29
+#define HS20_STYPE_QUERY_LIST 1
+#define HS20_STYPE_CAPABILITY_LIST 2
+#define HS20_STYPE_OPERATOR_FRIENDLY_NAME 3
+#define HS20_STYPE_WAN_METRICS 4
+#define HS20_STYPE_CONNECTION_CAPABILITY 5
+#define HS20_STYPE_NAI_HOME_REALM_QUERY 6
+#define HS20_STYPE_OPERATING_CLASS 7
+#define HS20_STYPE_OSU_PROVIDERS_LIST 8
+#define HS20_STYPE_ICON_REQUEST 10
+#define HS20_STYPE_ICON_BINARY_FILE 11
+#define HS20_STYPE_OPERATOR_ICON_METADATA 12
+#define HS20_STYPE_OSU_PROVIDERS_NAI_LIST 13
+
+#define HS20_DGAF_DISABLED 0x01
+#define HS20_PPS_MO_ID_PRESENT 0x02
+#define HS20_ANQP_DOMAIN_ID_PRESENT 0x04
+#ifndef HS20_VERSION
+#define HS20_VERSION 0x20 /* Release 3 */
+#endif /* HS20_VERSION */
+
+/* WNM-Notification WFA vendors specific subtypes */
+#define HS20_WNM_SUB_REM_NEEDED 0
+#define HS20_WNM_DEAUTH_IMMINENT_NOTICE 1
+#define WFA_WNM_NOTIF_SUBELEM_NON_PREF_CHAN_REPORT 2
+#define WFA_WNM_NOTIF_SUBELEM_CELL_DATA_CAPA 3
+#define HS20_WNM_T_C_ACCEPTANCE 4
+
+#define HS20_DEAUTH_REASON_CODE_BSS 0
+#define HS20_DEAUTH_REASON_CODE_ESS 1
+
+/* MBO v0.0_r19, 4.2: MBO Attributes */
+/* Table 4-5: MBO Attributes */
+/* OCE v0.0.10, Table 4-3: OCE Attributes */
+enum mbo_attr_id {
+	MBO_ATTR_ID_AP_CAPA_IND = 1,
+	MBO_ATTR_ID_NON_PREF_CHAN_REPORT = 2,
+	MBO_ATTR_ID_CELL_DATA_CAPA = 3,
+	MBO_ATTR_ID_ASSOC_DISALLOW = 4,
+	MBO_ATTR_ID_CELL_DATA_PREF = 5,
+	MBO_ATTR_ID_TRANSITION_REASON = 6,
+	MBO_ATTR_ID_TRANSITION_REJECT_REASON = 7,
+	MBO_ATTR_ID_ASSOC_RETRY_DELAY = 8,
+	OCE_ATTR_ID_CAPA_IND = 101,
+	OCE_ATTR_ID_RSSI_BASED_ASSOC_REJECT = 102,
+	OCE_ATTR_ID_REDUCED_WAN_METRICS = 103,
+	OCE_ATTR_ID_RNR_COMPLETENESS = 104,
+};
+
+/* MBO v0.0_r19, 4.2.1: MBO AP Capability Indication Attribute */
+/* Table 4-7: MBO AP Capability Indication Field Values */
+#define MBO_AP_CAPA_CELL_AWARE BIT(6)
+
+/* MBO v0.0_r19, 4.2.2: Non-preferred Channel Report Attribute */
+/* Table 4-10: Reason Code Field Values */
+enum mbo_non_pref_chan_reason {
+	MBO_NON_PREF_CHAN_REASON_UNSPECIFIED = 0,
+	MBO_NON_PREF_CHAN_REASON_RSSI = 1,
+	MBO_NON_PREF_CHAN_REASON_EXT_INTERFERENCE = 2,
+	MBO_NON_PREF_CHAN_REASON_INT_INTERFERENCE = 3,
+};
+
+/* MBO v0.0_r19, 4.2.3: Cellular Data Capabilities Attribute */
+/* Table 4-13: Cellular Data Connectivity Field */
+enum mbo_cellular_capa {
+	MBO_CELL_CAPA_AVAILABLE = 1,
+	MBO_CELL_CAPA_NOT_AVAILABLE = 2,
+	MBO_CELL_CAPA_NOT_SUPPORTED = 3,
+};
+
+/* MBO v0.0_r19, 4.2.4: Association Disallowed Attribute */
+/* Table 4-15: Reason Code Field Values */
+enum mbo_assoc_disallow_reason {
+	MBO_ASSOC_DISALLOW_REASON_UNSPECIFIED = 1,
+	MBO_ASSOC_DISALLOW_REASON_MAX_STA = 2,
+	MBO_ASSOC_DISALLOW_REASON_AIR_INTERFERENCE = 3,
+	MBO_ASSOC_DISALLOW_REASON_AUTH_SERVER_OVERLOAD = 4,
+	MBO_ASSOC_DISALLOW_REASON_LOW_RSSI = 5,
+};
+
+/* MBO v0.0_r19, 4.2.5: Cellular Data Connection Preference Attribute */
+/* Table 4-17: Cellular Preference Field Values */
+enum mbo_cell_pref {
+	MBO_CELL_PREF_EXCLUDED = 0,
+	MBO_CELL_PREF_NO_USE = 1,
+	MBO_CELL_PREF_USE = 255
+};
+
+/* MBO v0.0_r19, 4.2.6: Transition Reason Code Attribute */
+/* Table 4-19: Transition Reason Code Field Values */
+enum mbo_transition_reason {
+	MBO_TRANSITION_REASON_UNSPECIFIED = 0,
+	MBO_TRANSITION_REASON_FRAME_LOSS = 1,
+	MBO_TRANSITION_REASON_DELAY = 2,
+	MBO_TRANSITION_REASON_BANDWIDTH = 3,
+	MBO_TRANSITION_REASON_LOAD_BALANCE = 4,
+	MBO_TRANSITION_REASON_RSSI = 5,
+	MBO_TRANSITION_REASON_RETRANSMISSIONS = 6,
+	MBO_TRANSITION_REASON_INTERFERENCE = 7,
+	MBO_TRANSITION_REASON_GRAY_ZONE = 8,
+	MBO_TRANSITION_REASON_PREMIUM_AP = 9,
+};
+
+/* MBO v0.0_r19, 4.2.7: Transition Rejection Reason Code Attribute */
+/* Table 4-21: Transition Rejection Reason Code Field Values */
+enum mbo_transition_reject_reason {
+	MBO_TRANSITION_REJECT_REASON_UNSPECIFIED = 0,
+	MBO_TRANSITION_REJECT_REASON_FRAME_LOSS = 1,
+	MBO_TRANSITION_REJECT_REASON_DELAY = 2,
+	MBO_TRANSITION_REJECT_REASON_QOS_CAPACITY = 3,
+	MBO_TRANSITION_REJECT_REASON_RSSI = 4,
+	MBO_TRANSITION_REJECT_REASON_INTERFERENCE = 5,
+	MBO_TRANSITION_REJECT_REASON_SERVICES = 6,
+};
+
+/* MBO v0.0_r27, 4.3: MBO ANQP-elements */
+#define MBO_ANQP_OUI_TYPE 0x12
+#define MBO_ANQP_SUBTYPE_QUERY_LIST 1
+#define MBO_ANQP_SUBTYPE_CELL_CONN_PREF 2
+#define MAX_MBO_ANQP_SUBTYPE MBO_ANQP_SUBTYPE_CELL_CONN_PREF
+
+/* OCE v0.0.10, 4.2.1: OCE Capability Indication Attribute */
+#define OCE_RELEASE 1
+#define OCE_RELEASE_MASK (BIT(0) | BIT(1) | BIT(2))
+#define OCE_IS_STA_CFON BIT(3)
+#define OCE_IS_NON_OCE_AP_PRESENT BIT(4)
+
+/* Wi-Fi Direct (P2P) */
+
+#define P2P_OUI_TYPE 9
+
+enum p2p_attr_id {
+	P2P_ATTR_STATUS = 0,
+	P2P_ATTR_MINOR_REASON_CODE = 1,
+	P2P_ATTR_CAPABILITY = 2,
+	P2P_ATTR_DEVICE_ID = 3,
+	P2P_ATTR_GROUP_OWNER_INTENT = 4,
+	P2P_ATTR_CONFIGURATION_TIMEOUT = 5,
+	P2P_ATTR_LISTEN_CHANNEL = 6,
+	P2P_ATTR_GROUP_BSSID = 7,
+	P2P_ATTR_EXT_LISTEN_TIMING = 8,
+	P2P_ATTR_INTENDED_INTERFACE_ADDR = 9,
+	P2P_ATTR_MANAGEABILITY = 10,
+	P2P_ATTR_CHANNEL_LIST = 11,
+	P2P_ATTR_NOTICE_OF_ABSENCE = 12,
+	P2P_ATTR_DEVICE_INFO = 13,
+	P2P_ATTR_GROUP_INFO = 14,
+	P2P_ATTR_GROUP_ID = 15,
+	P2P_ATTR_INTERFACE = 16,
+	P2P_ATTR_OPERATING_CHANNEL = 17,
+	P2P_ATTR_INVITATION_FLAGS = 18,
+	P2P_ATTR_OOB_GO_NEG_CHANNEL = 19,
+	P2P_ATTR_SERVICE_HASH = 21,
+	P2P_ATTR_SESSION_INFORMATION_DATA = 22,
+	P2P_ATTR_CONNECTION_CAPABILITY = 23,
+	P2P_ATTR_ADVERTISEMENT_ID = 24,
+	P2P_ATTR_ADVERTISED_SERVICE = 25,
+	P2P_ATTR_SESSION_ID = 26,
+	P2P_ATTR_FEATURE_CAPABILITY = 27,
+	P2P_ATTR_PERSISTENT_GROUP = 28,
+	P2P_ATTR_VENDOR_SPECIFIC = 221
+};
+
+#define P2P_MAX_GO_INTENT 15
+
+/* P2P Capability - Device Capability bitmap */
+#define P2P_DEV_CAPAB_SERVICE_DISCOVERY BIT(0)
+#define P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY BIT(1)
+#define P2P_DEV_CAPAB_CONCURRENT_OPER BIT(2)
+#define P2P_DEV_CAPAB_INFRA_MANAGED BIT(3)
+#define P2P_DEV_CAPAB_DEVICE_LIMIT BIT(4)
+#define P2P_DEV_CAPAB_INVITATION_PROCEDURE BIT(5)
+
+/* P2P Capability - Group Capability bitmap */
+#define P2P_GROUP_CAPAB_GROUP_OWNER BIT(0)
+#define P2P_GROUP_CAPAB_PERSISTENT_GROUP BIT(1)
+#define P2P_GROUP_CAPAB_GROUP_LIMIT BIT(2)
+#define P2P_GROUP_CAPAB_INTRA_BSS_DIST BIT(3)
+#define P2P_GROUP_CAPAB_CROSS_CONN BIT(4)
+#define P2P_GROUP_CAPAB_PERSISTENT_RECONN BIT(5)
+#define P2P_GROUP_CAPAB_GROUP_FORMATION BIT(6)
+#define P2P_GROUP_CAPAB_IP_ADDR_ALLOCATION BIT(7)
+
+/* P2PS Coordination Protocol Transport Bitmap */
+#define P2PS_FEATURE_CAPAB_UDP_TRANSPORT BIT(0)
+#define P2PS_FEATURE_CAPAB_MAC_TRANSPORT BIT(1)
+
+struct p2ps_feature_capab {
+	u8 cpt;
+	u8 reserved;
+} STRUCT_PACKED;
+
+/* Invitation Flags */
+#define P2P_INVITATION_FLAGS_TYPE BIT(0)
+
+/* P2P Manageability */
+#define P2P_MAN_DEVICE_MANAGEMENT BIT(0)
+#define P2P_MAN_CROSS_CONNECTION_PERMITTED BIT(1)
+#define P2P_MAN_COEXISTENCE_OPTIONAL BIT(2)
+
+enum p2p_status_code {
+	P2P_SC_SUCCESS = 0,
+	P2P_SC_FAIL_INFO_CURRENTLY_UNAVAILABLE = 1,
+	P2P_SC_FAIL_INCOMPATIBLE_PARAMS = 2,
+	P2P_SC_FAIL_LIMIT_REACHED = 3,
+	P2P_SC_FAIL_INVALID_PARAMS = 4,
+	P2P_SC_FAIL_UNABLE_TO_ACCOMMODATE = 5,
+	P2P_SC_FAIL_PREV_PROTOCOL_ERROR = 6,
+	P2P_SC_FAIL_NO_COMMON_CHANNELS = 7,
+	P2P_SC_FAIL_UNKNOWN_GROUP = 8,
+	P2P_SC_FAIL_BOTH_GO_INTENT_15 = 9,
+	P2P_SC_FAIL_INCOMPATIBLE_PROV_METHOD = 10,
+	P2P_SC_FAIL_REJECTED_BY_USER = 11,
+	P2P_SC_SUCCESS_DEFERRED = 12,
+};
+
+enum p2p_role_indication {
+	P2P_DEVICE_NOT_IN_GROUP = 0x00,
+	P2P_CLIENT_IN_A_GROUP = 0x01,
+	P2P_GO_IN_A_GROUP = 0x02,
+};
+
+#define P2P_WILDCARD_SSID "DIRECT-"
+#define P2P_WILDCARD_SSID_LEN 7
+
+/* P2P action frames */
+enum p2p_act_frame_type {
+	P2P_NOA = 0,
+	P2P_PRESENCE_REQ = 1,
+	P2P_PRESENCE_RESP = 2,
+	P2P_GO_DISC_REQ = 3
+};
+
+/* P2P public action frames */
+enum p2p_action_frame_type {
+	P2P_GO_NEG_REQ = 0,
+	P2P_GO_NEG_RESP = 1,
+	P2P_GO_NEG_CONF = 2,
+	P2P_INVITATION_REQ = 3,
+	P2P_INVITATION_RESP = 4,
+	P2P_DEV_DISC_REQ = 5,
+	P2P_DEV_DISC_RESP = 6,
+	P2P_PROV_DISC_REQ = 7,
+	P2P_PROV_DISC_RESP = 8
+};
+
+enum p2p_service_protocol_type {
+	P2P_SERV_ALL_SERVICES = 0,
+	P2P_SERV_BONJOUR = 1,
+	P2P_SERV_UPNP = 2,
+	P2P_SERV_WS_DISCOVERY = 3,
+	P2P_SERV_WIFI_DISPLAY = 4,
+	P2P_SERV_P2PS = 11,
+	P2P_SERV_VENDOR_SPECIFIC = 255
+};
+
+enum p2p_sd_status {
+	P2P_SD_SUCCESS = 0,
+	P2P_SD_PROTO_NOT_AVAILABLE = 1,
+	P2P_SD_REQUESTED_INFO_NOT_AVAILABLE = 2,
+	P2P_SD_BAD_REQUEST = 3
+};
+
+
+enum wifi_display_subelem {
+	WFD_SUBELEM_DEVICE_INFO = 0,
+	WFD_SUBELEM_ASSOCIATED_BSSID = 1,
+	WFD_SUBELEM_AUDIO_FORMATS = 2,
+	WFD_SUBELEM_VIDEO_FORMATS = 3,
+	WFD_SUBELEM_3D_VIDEO_FORMATS = 4,
+	WFD_SUBELEM_CONTENT_PROTECTION = 5,
+	WFD_SUBELEM_COUPLED_SINK = 6,
+	WFD_SUBELEM_EXT_CAPAB = 7,
+	WFD_SUBELEM_LOCAL_IP_ADDRESS = 8,
+	WFD_SUBELEM_SESSION_INFO = 9,
+	WFD_SUBELEM_MAC_INFO = 10,
+	WFD_SUBELEM_R2_DEVICE_INFO = 11,
+};
+
+/* 802.11s */
+#define MESH_SYNC_METHOD_NEIGHBOR_OFFSET 1
+#define MESH_SYNC_METHOD_VENDOR		255
+#define MESH_PATH_PROTOCOL_HWMP		1
+#define MESH_PATH_PROTOCOL_VENDOR	255
+#define MESH_PATH_METRIC_AIRTIME	1
+#define MESH_PATH_METRIC_VENDOR		255
+/* IEEE 802.11s - Mesh Capability */
+#define MESH_CAP_ACCEPT_ADDITIONAL_PEER	BIT(0)
+#define MESH_CAP_MCCA_SUPPORTED		BIT(1)
+#define MESH_CAP_MCCA_ENABLED		BIT(2)
+#define MESH_CAP_FORWARDING		BIT(3)
+#define MESH_CAP_MBCA_ENABLED		BIT(4)
+#define MESH_CAP_TBTT_ADJUSTING		BIT(5)
+#define MESH_CAP_MESH_PS_LEVEL		BIT(6)
+
+enum plink_action_field {
+	PLINK_OPEN = 1,
+	PLINK_CONFIRM,
+	PLINK_CLOSE
+};
+
+#define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
+#define VENDOR_VHT_TYPE		0x04
+#define VENDOR_VHT_SUBTYPE	0x08
+#define VENDOR_VHT_SUBTYPE2	0x00
+
+#define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */
+
+
+/* IEEE 802.11v - WNM Action field values */
+enum wnm_action {
+	WNM_EVENT_REQ = 0,
+	WNM_EVENT_REPORT = 1,
+	WNM_DIAGNOSTIC_REQ = 2,
+	WNM_DIAGNOSTIC_REPORT = 3,
+	WNM_LOCATION_CFG_REQ = 4,
+	WNM_LOCATION_CFG_RESP = 5,
+	WNM_BSS_TRANS_MGMT_QUERY = 6,
+	WNM_BSS_TRANS_MGMT_REQ = 7,
+	WNM_BSS_TRANS_MGMT_RESP = 8,
+	WNM_FMS_REQ = 9,
+	WNM_FMS_RESP = 10,
+	WNM_COLLOCATED_INTERFERENCE_REQ = 11,
+	WNM_COLLOCATED_INTERFERENCE_REPORT = 12,
+	WNM_TFS_REQ = 13,
+	WNM_TFS_RESP = 14,
+	WNM_TFS_NOTIFY = 15,
+	WNM_SLEEP_MODE_REQ = 16,
+	WNM_SLEEP_MODE_RESP = 17,
+	WNM_TIM_BROADCAST_REQ = 18,
+	WNM_TIM_BROADCAST_RESP = 19,
+	WNM_QOS_TRAFFIC_CAPAB_UPDATE = 20,
+	WNM_CHANNEL_USAGE_REQ = 21,
+	WNM_CHANNEL_USAGE_RESP = 22,
+	WNM_DMS_REQ = 23,
+	WNM_DMS_RESP = 24,
+	WNM_TIMING_MEASUREMENT_REQ = 25,
+	WNM_NOTIFICATION_REQ = 26,
+	WNM_NOTIFICATION_RESP = 27
+};
+
+/* IEEE 802.11v - BSS Transition Management Request - Request Mode */
+#define WNM_BSS_TM_REQ_PREF_CAND_LIST_INCLUDED BIT(0)
+#define WNM_BSS_TM_REQ_ABRIDGED BIT(1)
+#define WNM_BSS_TM_REQ_DISASSOC_IMMINENT BIT(2)
+#define WNM_BSS_TM_REQ_BSS_TERMINATION_INCLUDED BIT(3)
+#define WNM_BSS_TM_REQ_ESS_DISASSOC_IMMINENT BIT(4)
+
+/* IEEE Std 802.11-2012 - Table 8-253 */
+enum bss_trans_mgmt_status_code {
+	WNM_BSS_TM_ACCEPT = 0,
+	WNM_BSS_TM_REJECT_UNSPECIFIED = 1,
+	WNM_BSS_TM_REJECT_INSUFFICIENT_BEACON = 2,
+	WNM_BSS_TM_REJECT_INSUFFICIENT_CAPABITY = 3,
+	WNM_BSS_TM_REJECT_UNDESIRED = 4,
+	WNM_BSS_TM_REJECT_DELAY_REQUEST = 5,
+	WNM_BSS_TM_REJECT_STA_CANDIDATE_LIST_PROVIDED = 6,
+	WNM_BSS_TM_REJECT_NO_SUITABLE_CANDIDATES = 7,
+	WNM_BSS_TM_REJECT_LEAVING_ESS = 8
+};
+
+/*
+ * IEEE P802.11-REVmc/D5.0 Table 9-150 - Optional subelement IDs for
+ * neighbor report
+ */
+#define WNM_NEIGHBOR_TSF                         1
+#define WNM_NEIGHBOR_CONDENSED_COUNTRY_STRING    2
+#define WNM_NEIGHBOR_BSS_TRANSITION_CANDIDATE    3
+#define WNM_NEIGHBOR_BSS_TERMINATION_DURATION    4
+#define WNM_NEIGHBOR_BEARING                     5
+#define WNM_NEIGHBOR_WIDE_BW_CHAN                6
+#define WNM_NEIGHBOR_MEASUREMENT_REPORT         39
+#define WNM_NEIGHBOR_HT_CAPAB                   45
+#define WNM_NEIGHBOR_HT_OPER                    61
+#define WNM_NEIGHBOR_SEC_CHAN_OFFSET            62
+#define WNM_NEIGHBOR_MEASUREMENT_PILOT          66
+#define WNM_NEIGHBOR_RRM_ENABLED_CAPABILITIES   70
+#define WNM_NEIGHBOR_MULTIPLE_BSSID             71
+#define WNM_NEIGHBOR_VHT_CAPAB                 191
+#define WNM_NEIGHBOR_VHT_OPER                  192
+
+/* QoS action */
+enum qos_action {
+	QOS_ADDTS_REQ = 0,
+	QOS_ADDTS_RESP = 1,
+	QOS_DELTS = 2,
+	QOS_SCHEDULE = 3,
+	QOS_QOS_MAP_CONFIG = 4,
+};
+
+/* IEEE Std 802.11-2012, 8.4.2.62 20/40 BSS Coexistence element */
+#define WLAN_20_40_BSS_COEX_INFO_REQ            BIT(0)
+#define WLAN_20_40_BSS_COEX_40MHZ_INTOL         BIT(1)
+#define WLAN_20_40_BSS_COEX_20MHZ_WIDTH_REQ     BIT(2)
+#define WLAN_20_40_BSS_COEX_OBSS_EXEMPT_REQ     BIT(3)
+#define WLAN_20_40_BSS_COEX_OBSS_EXEMPT_GRNT    BIT(4)
+
+struct ieee80211_2040_bss_coex_ie {
+	u8 element_id;
+	u8 length;
+	u8 coex_param;
+} STRUCT_PACKED;
+
+struct ieee80211_2040_intol_chan_report {
+	u8 element_id;
+	u8 length;
+	u8 op_class;
+	u8 variable[0];	/* Channel List */
+} STRUCT_PACKED;
+
+/* IEEE 802.11v - WNM-Sleep Mode element */
+struct wnm_sleep_element {
+	u8 eid;     /* WLAN_EID_WNMSLEEP */
+	u8 len;
+	u8 action_type; /* WNM_SLEEP_ENTER/WNM_SLEEP_MODE_EXIT */
+	u8 status;
+	le16 intval;
+} STRUCT_PACKED;
+
+#define WNM_SLEEP_MODE_ENTER 0
+#define WNM_SLEEP_MODE_EXIT 1
+
+enum wnm_sleep_mode_response_status {
+	WNM_STATUS_SLEEP_ACCEPT = 0,
+	WNM_STATUS_SLEEP_EXIT_ACCEPT_GTK_UPDATE = 1,
+	WNM_STATUS_DENIED_ACTION = 2,
+	WNM_STATUS_DENIED_TMP = 3,
+	WNM_STATUS_DENIED_KEY = 4,
+	WNM_STATUS_DENIED_OTHER_WNM_SERVICE = 5
+};
+
+/* WNM-Sleep Mode subelement IDs */
+enum wnm_sleep_mode_subelement_id {
+	WNM_SLEEP_SUBELEM_GTK = 0,
+	WNM_SLEEP_SUBELEM_IGTK = 1,
+	WNM_SLEEP_SUBELEM_BIGTK = 2,
+};
+
+/* WNM notification type (IEEE P802.11-REVmd/D3.0, Table 9-430) */
+enum wnm_notification_Type {
+	WNM_NOTIF_TYPE_FIRMWARE_UPDATE = 0,
+	WNM_NOTIF_TYPE_BEACON_PROTECTION_FAILURE = 2,
+	WNM_NOTIF_TYPE_VENDOR_SPECIFIC = 221,
+};
+
+/* Channel Switch modes (802.11h) */
+#define CHAN_SWITCH_MODE_ALLOW_TX	0
+#define CHAN_SWITCH_MODE_BLOCK_TX	1
+
+struct tpc_report {
+	u8 eid;
+	u8 len;
+	u8 tx_power;
+	u8 link_margin;
+} STRUCT_PACKED;
+
+#define RRM_CAPABILITIES_IE_LEN 5
+
+/* IEEE Std 802.11-2012, 8.5.7.4 - Link Measurement Request frame format */
+struct rrm_link_measurement_request {
+	u8 dialog_token;
+	s8 tx_power;
+	s8 max_tp;
+	u8 variable[0];
+} STRUCT_PACKED;
+
+/* IEEE Std 802.11-2012, 8.5.7.5 - Link Measurement Report frame format */
+struct rrm_link_measurement_report {
+	u8 dialog_token;
+	struct tpc_report tpc;
+	u8 rx_ant_id;
+	u8 tx_ant_id;
+	u8 rcpi;
+	u8 rsni;
+	u8 variable[0];
+} STRUCT_PACKED;
+
+/* IEEE Std 802.11-2016, 9.4.2.21 - Measurement Request element */
+struct rrm_measurement_request_element {
+	u8 eid; /* Element ID */
+	u8 len; /* Length */
+	u8 token; /* Measurement Token */
+	u8 mode; /* Measurement Request Mode */
+	u8 type; /* Measurement Type */
+	u8 variable[0]; /* Measurement Request */
+} STRUCT_PACKED;
+
+/* IEEE Std 802.11-2016, Figure 9-148 - Measurement Request Mode field */
+#define MEASUREMENT_REQUEST_MODE_PARALLEL BIT(0)
+#define MEASUREMENT_REQUEST_MODE_ENABLE BIT(1)
+#define MEASUREMENT_REQUEST_MODE_REQUEST BIT(2)
+#define MEASUREMENT_REQUEST_MODE_REPORT BIT(3)
+#define MEASUREMENT_REQUEST_MODE_DURATION_MANDATORY BIT(4)
+
+/* IEEE Std 802.11-2016, 9.4.2.21.7 - Beacon request */
+struct rrm_measurement_beacon_request {
+	u8 oper_class; /* Operating Class */
+	u8 channel; /* Channel Number */
+	le16 rand_interval; /* Randomization Interval (in TUs) */
+	le16 duration; /* Measurement Duration (in TUs) */
+	u8 mode; /* Measurement Mode */
+	u8 bssid[ETH_ALEN]; /* BSSID */
+	u8 variable[0]; /* Optional Subelements */
+} STRUCT_PACKED;
+
+/*
+ * IEEE Std 802.11-2016, Table 9-87 - Measurement Mode definitions for Beacon
+ * request
+ */
+enum beacon_report_mode {
+	BEACON_REPORT_MODE_PASSIVE = 0,
+	BEACON_REPORT_MODE_ACTIVE = 1,
+	BEACON_REPORT_MODE_TABLE = 2,
+};
+
+/* IEEE Std 802.11-2016, Table 9-88 - Beacon Request subelement IDs */
+/* IEEE P802.11-REVmd/D2.0, Table 9-106 - Optional subelement IDs for
+ * Beacon request */
+#define WLAN_BEACON_REQUEST_SUBELEM_SSID	0
+#define WLAN_BEACON_REQUEST_SUBELEM_INFO	1 /* Beacon Reporting */
+#define WLAN_BEACON_REQUEST_SUBELEM_DETAIL	2 /* Reporting Detail */
+#define WLAN_BEACON_REQUEST_SUBELEM_REQUEST	10
+#define WLAN_BEACON_REQUEST_SUBELEM_AP_CHANNEL	51 /* AP Channel Report */
+#define WLAN_BEACON_REQUEST_SUBELEM_LAST_INDICATION	164
+#define WLAN_BEACON_REQUEST_SUBELEM_VENDOR	221
+
+/*
+ * IEEE Std 802.11-2016, Table 9-90 - Reporting Detail values
+ */
+enum beacon_report_detail {
+	/* No fixed-length fields or elements */
+	BEACON_REPORT_DETAIL_NONE = 0,
+	/* All fixed-length fields and any requested elements in the Request
+	 * element if present */
+	BEACON_REPORT_DETAIL_REQUESTED_ONLY = 1,
+	/* All fixed-length fields and elements (default, used when Reporting
+	 * Detail subelement is not included in a Beacon request) */
+	BEACON_REPORT_DETAIL_ALL_FIELDS_AND_ELEMENTS = 2,
+};
+
+/* IEEE Std 802.11-2016, 9.4.2.22 - Measurement Report element */
+struct rrm_measurement_report_element {
+	u8 eid; /* Element ID */
+	u8 len; /* Length */
+	u8 token; /* Measurement Token */
+	u8 mode; /* Measurement Report Mode */
+	u8 type; /* Measurement Type */
+	u8 variable[0]; /* Measurement Report */
+} STRUCT_PACKED;
+
+/* IEEE Std 802.11-2016, Figure 9-192 - Measurement Report Mode field */
+#define MEASUREMENT_REPORT_MODE_ACCEPT 0
+#define MEASUREMENT_REPORT_MODE_REJECT_LATE BIT(0)
+#define MEASUREMENT_REPORT_MODE_REJECT_INCAPABLE BIT(1)
+#define MEASUREMENT_REPORT_MODE_REJECT_REFUSED BIT(2)
+
+/* IEEE Std 802.11-2016, 9.4.2.22.7 - Beacon report */
+struct rrm_measurement_beacon_report {
+	u8 op_class; /* Operating Class */
+	u8 channel; /* Channel Number */
+	le64 start_time; /* Actual Measurement Start Time
+			  * (in TSF of the BSS requesting the measurement) */
+	le16 duration; /* in TUs */
+	u8 report_info; /* Reported Frame Information */
+	u8 rcpi; /* RCPI */
+	u8 rsni; /* RSNI */
+	u8 bssid[ETH_ALEN]; /* BSSID */
+	u8 antenna_id; /* Antenna ID */
+	le32 parent_tsf; /* Parent TSF */
+	u8 variable[0]; /* Optional Subelements */
+} STRUCT_PACKED;
+
+/* IEEE Std 802.11-2016, Table 9-112 - Beacon report Subelement IDs */
+/* IEEE P802.11-REVmd/D2.0, Table 9-130 - Optional subelement IDs for
+ * Beacon report */
+#define WLAN_BEACON_REPORT_SUBELEM_FRAME_BODY	1
+#define WLAN_BEACON_REPORT_SUBELEM_FRAME_BODY_FRAGMENT_ID	2
+#define WLAN_BEACON_REPORT_SUBELEM_LAST_INDICATION	164
+#define WLAN_BEACON_REPORT_SUBELEM_VENDOR	221
+
+/* IEEE P802.11-REVmd/D2.0, Table 9-232 - Data field format of the
+ * Reported Frame Body Fragment ID subelement */
+#define REPORTED_FRAME_BODY_SUBELEM_LEN		4
+#define REPORTED_FRAME_BODY_MORE_FRAGMENTS	BIT(7)
+
+/* IEEE P802.11-REVmd/D2.0, 9.4.2.21.7 - Beacon report  */
+#define BEACON_REPORT_LAST_INDICATION_SUBELEM_LEN	3
+
+/* IEEE Std 802.11ad-2012 - Multi-band element */
+struct multi_band_ie {
+	u8 eid; /* WLAN_EID_MULTI_BAND */
+	u8 len;
+	u8 mb_ctrl;
+	u8 band_id;
+	u8 op_class;
+	u8 chan;
+	u8 bssid[ETH_ALEN];
+	le16 beacon_int;
+	u8 tsf_offs[8];
+	u8 mb_connection_capability;
+	u8 fst_session_tmout;
+	/* Optional:
+	 *   STA MAC Address
+	 *   Pairwise Cipher Suite Count
+	 *   Pairwise Cipher Suite List
+	 */
+	u8 variable[0];
+} STRUCT_PACKED;
+
+enum mb_ctrl_sta_role {
+	MB_STA_ROLE_AP = 0,
+	MB_STA_ROLE_TDLS_STA = 1,
+	MB_STA_ROLE_IBSS_STA = 2,
+	MB_STA_ROLE_PCP = 3,
+	MB_STA_ROLE_NON_PCP_NON_AP = 4
+};
+
+#define MB_CTRL_ROLE_MASK (BIT(0) | BIT(1) | BIT(2))
+#define MB_CTRL_ROLE(ctrl) ((u8) ((ctrl) & MB_CTRL_ROLE_MASK))
+#define MB_CTRL_STA_MAC_PRESENT ((u8) (BIT(3)))
+#define MB_CTRL_PAIRWISE_CIPHER_SUITE_PRESENT ((u8) (BIT(4)))
+
+enum mb_band_id {
+	MB_BAND_ID_WIFI_2_4GHZ = 2, /* 2.4 GHz */
+	MB_BAND_ID_WIFI_5GHZ = 4, /* 4.9 and 5 GHz */
+	MB_BAND_ID_WIFI_60GHZ = 5, /* 60 GHz */
+};
+
+#define MB_CONNECTION_CAPABILITY_AP ((u8) (BIT(0)))
+#define MB_CONNECTION_CAPABILITY_PCP ((u8) (BIT(1)))
+#define MB_CONNECTION_CAPABILITY_DLS ((u8) (BIT(2)))
+#define MB_CONNECTION_CAPABILITY_TDLS ((u8) (BIT(3)))
+#define MB_CONNECTION_CAPABILITY_IBSS ((u8) (BIT(4)))
+
+/* IEEE Std 802.11ad-2014 - FST Action field */
+enum fst_action {
+	FST_ACTION_SETUP_REQUEST = 0,
+	FST_ACTION_SETUP_RESPONSE = 1,
+	FST_ACTION_TEAR_DOWN = 2,
+	FST_ACTION_ACK_REQUEST = 3,
+	FST_ACTION_ACK_RESPONSE = 4,
+	FST_ACTION_ON_CHANNEL_TUNNEL = 5,
+};
+
+/* IEEE Std 802.11ac-2013, Annex C - dot11PHYType */
+enum phy_type {
+	PHY_TYPE_UNSPECIFIED = 0,
+	PHY_TYPE_FHSS = 1,
+	PHY_TYPE_DSSS = 2,
+	PHY_TYPE_IRBASEBAND = 3,
+	PHY_TYPE_OFDM = 4,
+	PHY_TYPE_HRDSSS = 5,
+	PHY_TYPE_ERP = 6,
+	PHY_TYPE_HT = 7,
+	PHY_TYPE_DMG = 8,
+	PHY_TYPE_VHT = 9,
+};
+
+/* IEEE P802.11-REVmd/D3.0, 9.4.2.36 - Neighbor Report element */
+/* BSSID Information Field */
+#define NEI_REP_BSSID_INFO_AP_NOT_REACH BIT(0)
+#define NEI_REP_BSSID_INFO_AP_UNKNOWN_REACH BIT(1)
+#define NEI_REP_BSSID_INFO_AP_REACHABLE (BIT(0) | BIT(1))
+#define NEI_REP_BSSID_INFO_SECURITY BIT(2)
+#define NEI_REP_BSSID_INFO_KEY_SCOPE BIT(3)
+#define NEI_REP_BSSID_INFO_SPECTRUM_MGMT BIT(4)
+#define NEI_REP_BSSID_INFO_QOS BIT(5)
+#define NEI_REP_BSSID_INFO_APSD BIT(6)
+#define NEI_REP_BSSID_INFO_RM BIT(7)
+#define NEI_REP_BSSID_INFO_DELAYED_BA BIT(8)
+#define NEI_REP_BSSID_INFO_IMM_BA BIT(9)
+#define NEI_REP_BSSID_INFO_MOBILITY_DOMAIN BIT(10)
+#define NEI_REP_BSSID_INFO_HT BIT(11)
+#define NEI_REP_BSSID_INFO_VHT BIT(12)
+#define NEI_REP_BSSID_INFO_FTM BIT(13)
+#define NEI_REP_BSSID_INFO_HE BIT(14)
+
+/*
+ * IEEE P802.11-REVmc/D5.0 Table 9-152 - HT/VHT Operation Information
+ * subfields.
+ * Note: These definitions are not the same as other CHANWIDTH_*.
+ */
+enum nr_chan_width {
+	NR_CHAN_WIDTH_20 = 0,
+	NR_CHAN_WIDTH_40 = 1,
+	NR_CHAN_WIDTH_80 = 2,
+	NR_CHAN_WIDTH_160 = 3,
+	NR_CHAN_WIDTH_80P80 = 4,
+};
+
+struct ieee80211_he_capabilities {
+	u8 he_mac_capab_info[6];
+	u8 he_phy_capab_info[11];
+	/* Followed by 4, 8, or 12 octets of Supported HE-MCS And NSS Set field
+	* and optional variable length PPE Thresholds field. */
+	u8 optional[37];
+} STRUCT_PACKED;
+
+struct ieee80211_he_operation {
+	le32 he_oper_params; /* HE Operation Parameters[3] and
+			      * BSS Color Information[1] */
+	le16 he_mcs_nss_set;
+	/* Followed by conditional VHT Operation Information (3 octets),
+	 * Max Co-Hosted BSSID Indicator subfield (1 octet), and/or 6 GHz
+	 * Operation Information subfield (5 octets). */
+} STRUCT_PACKED;
+
+/* IEEE P802.11ax/D6.0, Figure 9-787k - 6 GHz Operation Information field */
+struct ieee80211_he_6ghz_oper_info {
+	u8 primary_chan;
+	u8 control;
+	u8 chan_center_freq_seg0;
+	u8 chan_center_freq_seg1;
+	u8 min_rate;
+} STRUCT_PACKED;
+
+#define HE_6GHZ_OPER_INFO_CTRL_CHAN_WIDTH_MASK	(BIT(0) | BIT(1))
+#define HE_6GHZ_OPER_INFO_CTRL_DUP_BEACON	BIT(2)
+
+/* IEEE P802.11ax/D6.0, 9.4.2.261 HE 6 GHz Band Capabilities element */
+struct ieee80211_he_6ghz_band_cap {
+	 /* Minimum MPDU Start Spacing B0..B2
+	  * Maximum A-MPDU Length Exponent B3..B5
+	  * Maximum MPDU Length B6..B7 */
+	le16 capab;
+} STRUCT_PACKED;
+
+#define HE_6GHZ_BAND_CAP_MIN_MPDU_START              (BIT(0) | BIT(1) | BIT(2))
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_16K       BIT(3)
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_32K       BIT(4)
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_64K       (BIT(3) | BIT(4))
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_128K      BIT(5)
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_256K      (BIT(3) | BIT(5))
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_512K      (BIT(4) | BIT(5))
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_1024K     (BIT(3) | BIT(4) | BIT(5))
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_MASK      (BIT(3) | BIT(4) | BIT(5))
+#define HE_6GHZ_BAND_CAP_MAX_AMPDU_LEN_EXP_SHIFT     3
+#define HE_6GHZ_BAND_CAP_MAX_MPDU_LEN_7991           BIT(6)
+#define HE_6GHZ_BAND_CAP_MAX_MPDU_LEN_11454          BIT(7)
+#define HE_6GHZ_BAND_CAP_MAX_MPDU_LEN_MASK           (BIT(6) | BIT(7))
+#define HE_6GHZ_BAND_CAP_MAX_MPDU_LEN_SHIFT	     6
+#define HE_6GHZ_BAND_CAP_SMPS_MASK                   (BIT(9) | BIT(10))
+#define HE_6GHZ_BAND_CAP_SMPS_STATIC                 0
+#define HE_6GHZ_BAND_CAP_SMPS_DYNAMIC                BIT(9)
+#define HE_6GHZ_BAND_CAP_SMPS_DISABLED               (BIT(9) | BIT(10))
+#define HE_6GHZ_BAND_CAP_RD_RESPONDER                BIT(11)
+#define HE_6GHZ_BAND_CAP_RX_ANTPAT_CONS              BIT(12)
+#define HE_6GHZ_BAND_CAP_TX_ANTPAT_CONS              BIT(13)
+
+/*
+ * IEEE P802.11ax/D4.0, 9.4.2.246 Spatial Reuse Parameter Set element
+ */
+struct ieee80211_spatial_reuse {
+	u8 sr_ctrl; /* SR Control */
+	/* Up to 19 octets of parameters:
+	 * Non-SRG OBSS PD Max Offset[0 or 1]
+	 * SRG OBSS PD Min Offset[0 or 1]
+	 * SRG OBSS PD Max Offset[0 or 1]
+	 * SRG BSS Color Bitmap[0 or 8]
+	 * SRG Partial BSSID Bitmap[0 or 8]
+	 */
+	u8 params[19];
+} STRUCT_PACKED;
+
+/* HE Capabilities Information defines */
+
+#define HE_MACCAP_TWT_RESPONDER			((u8) BIT(2))
+
+#define HE_PHYCAP_CHANNEL_WIDTH_SET_IDX		0
+#define HE_PHYCAP_CHANNEL_WIDTH_MASK		((u8) (BIT(1) | BIT(2) | \
+						      BIT(3) | BIT(4)))
+#define HE_PHYCAP_CHANNEL_WIDTH_SET_40MHZ_IN_2G         ((u8) BIT(1))
+#define HE_PHYCAP_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G	((u8) BIT(2))
+#define HE_PHYCAP_CHANNEL_WIDTH_SET_160MHZ_IN_5G	((u8) BIT(3))
+#define HE_PHYCAP_CHANNEL_WIDTH_SET_80PLUS80MHZ_IN_5G	((u8) BIT(4))
+
+#define HE_PHYCAP_SU_BEAMFORMER_CAPAB_IDX	3
+#define HE_PHYCAP_SU_BEAMFORMER_CAPAB		((u8) BIT(7))
+#define HE_PHYCAP_SU_BEAMFORMEE_CAPAB_IDX	4
+#define HE_PHYCAP_SU_BEAMFORMEE_CAPAB		((u8) BIT(0))
+#define HE_PHYCAP_MU_BEAMFORMER_CAPAB_IDX	4
+#define HE_PHYCAP_MU_BEAMFORMER_CAPAB		((u8) BIT(1))
+
+#define HE_PHYCAP_PPE_THRESHOLD_PRESENT_IDX	6
+#define HE_PHYCAP_PPE_THRESHOLD_PRESENT		((u8) BIT(7))
+
+/* HE PPE Threshold define */
+#define HE_PPE_THRES_RU_INDEX_BITMASK_MASK	0xf
+#define HE_PPE_THRES_RU_INDEX_BITMASK_SHIFT	3
+#define HE_PPE_THRES_NSS_MASK			0x7
+
+/* HE Operation defines */
+/* HE Operation Parameters and BSS Color Information fields */
+#define HE_OPERATION_DFLT_PE_DURATION_MASK	((u32) (BIT(0) | BIT(1) | \
+							BIT(2)))
+#define HE_OPERATION_DFLT_PE_DURATION_OFFSET	0
+#define HE_OPERATION_TWT_REQUIRED		((u32) BIT(3))
+#define HE_OPERATION_RTS_THRESHOLD_MASK	((u32) (BIT(4) | BIT(5) | \
+						BIT(6) | BIT(7) | \
+						BIT(8) | BIT(9) | \
+						BIT(10) | BIT(11) | \
+						BIT(12) | BIT(13)))
+#define HE_OPERATION_RTS_THRESHOLD_OFFSET	4
+#define HE_OPERATION_VHT_OPER_INFO		((u32) BIT(14))
+#define HE_OPERATION_COHOSTED_BSS		((u32) BIT(15))
+#define HE_OPERATION_ER_SU_DISABLE		((u32) BIT(16))
+#define HE_OPERATION_6GHZ_OPER_INFO		((u32) BIT(17))
+#define HE_OPERATION_BSS_COLOR_MASK		((u32) (BIT(24) | BIT(25) | \
+							BIT(26) | BIT(27) | \
+							BIT(28) | BIT(29)))
+#define HE_OPERATION_BSS_COLOR_PARTIAL		((u32) BIT(30))
+#define HE_OPERATION_BSS_COLOR_DISABLED		((u32) BIT(31))
+#define HE_OPERATION_BSS_COLOR_OFFSET		24
+
+/* Spatial Reuse defines */
+#define SPATIAL_REUSE_SRP_DISALLOWED		BIT(0)
+#define SPATIAL_REUSE_NON_SRG_OBSS_PD_SR_DISALLOWED	BIT(1)
+#define SPATIAL_REUSE_NON_SRG_OFFSET_PRESENT	BIT(2)
+#define SPATIAL_REUSE_SRG_INFORMATION_PRESENT	BIT(3)
+#define SPATIAL_REUSE_HESIGA_SR_VAL15_ALLOWED	BIT(4)
+
+struct ieee80211_he_mu_edca_parameter_set {
+	u8 he_qos_info;
+	u8 he_mu_ac_be_param[3];
+	u8 he_mu_ac_bk_param[3];
+	u8 he_mu_ac_vi_param[3];
+	u8 he_mu_ac_vo_param[3];
+} STRUCT_PACKED;
+
+/* HE MU AC parameter record field format */
+/* ACI/AIFSN */
+#define HE_MU_AC_PARAM_ACI_IDX 0
+#define HE_MU_AC_PARAM_AIFSN ((u8) (BIT(0) | BIT(1) | BIT(2) | BIT(3)))
+#define HE_MU_AC_PARAM_ACM ((u8) BIT(4))
+#define HE_MU_AC_PARAM_ACI ((u8) (BIT(5) | BIT(6)))
+/* B7: Reserved */
+
+/* ECWmin/ECWmax */
+#define HE_MU_AC_PARAM_ECW_IDX 1
+#define HE_MU_AC_PARAM_ECWMIN ((u8) (BIT(0) | BIT(1) | BIT(2) | BIT(3)))
+#define HE_MU_AC_PARAM_ECWMAX ((u8) (BIT(4) | BIT(5) | BIT(6) | BIT(7)))
+
+/* MU EDCA Timer */
+#define HE_MU_AC_PARAM_TIMER_IDX 2
+
+/* HE QoS Info field */
+#define HE_QOS_INFO_EDCA_PARAM_SET_COUNT ((u8) (BIT(0) | BIT(1) | \
+						BIT(2) | BIT(3)))
+#define HE_QOS_INFO_Q_ACK ((u8) (BIT(4)))
+#define HE_QOS_INFO_QUEUE_REQUEST ((u8) (BIT(5)))
+#define HE_QOS_INFO_TXOP_REQUEST ((u8) (BIT(6)))
+/* B7: Reserved if sent by an AP; More Data Ack if sent by a non-AP STA */
+#define HE_QOS_INFO_MORE_DATA_ACK ((u8) (BIT(7)))
+
+/* IEEE P802.11ay/D4.0, 9.4.2.251 - EDMG Operation element */
+#define EDMG_BSS_OPERATING_CHANNELS_OFFSET	6
+#define EDMG_OPERATING_CHANNEL_WIDTH_OFFSET	7
+
+/* IEEE P802.11ay/D4.0, 29.3.4 - Channelization */
+enum edmg_channel {
+	EDMG_CHANNEL_9	= 9,
+	EDMG_CHANNEL_10	= 10,
+	EDMG_CHANNEL_11	= 11,
+	EDMG_CHANNEL_12	= 12,
+	EDMG_CHANNEL_13	= 13,
+};
+
+/* Represent CB2 contiguous channels */
+#define EDMG_CHANNEL_9_SUBCHANNELS	(BIT(0) | BIT(1)) /* channels 1 and 2 */
+#define EDMG_CHANNEL_10_SUBCHANNELS	(BIT(1) | BIT(2)) /* channels 2 and 3 */
+#define EDMG_CHANNEL_11_SUBCHANNELS	(BIT(2) | BIT(3)) /* channels 3 and 4 */
+#define EDMG_CHANNEL_12_SUBCHANNELS	(BIT(3) | BIT(4)) /* channels 4 and 5 */
+#define EDMG_CHANNEL_13_SUBCHANNELS	(BIT(4) | BIT(5)) /* channels 5 and 6 */
+
+/**
+ * enum edmg_bw_config - Allowed channel bandwidth configurations
+ * @EDMG_BW_CONFIG_4: 2.16 GHz
+ * @EDMG_BW_CONFIG_5: 2.16 GHz and 4.32 GHz
+ *
+ * IEEE P802.11ay/D4.0, 9.4.2.251 (EDMG Operation element),
+ * Table 13 (Channel BW Configuration subfield definition)
+ */
+enum edmg_bw_config {
+	EDMG_BW_CONFIG_4	= 4,
+	EDMG_BW_CONFIG_5	= 5,
+};
+
+/* DPP Public Action frame identifiers - OUI_WFA */
+#define DPP_OUI_TYPE 0x1A
+
+/* Robust AV streaming Action field values */
+enum robust_av_streaming_action {
+	ROBUST_AV_SCS_REQ = 0,
+	ROBUST_AV_SCS_RESP = 1,
+	ROBUST_AV_GROUP_MEMBERSHIP_REQ = 2,
+	ROBUST_AV_GROUP_MEMBERSHIP_RESP = 3,
+	ROBUST_AV_MSCS_REQ = 4,
+	ROBUST_AV_MSCS_RESP = 5,
+};
+
+enum scs_request_type {
+	SCS_REQ_ADD = 0,
+	SCS_REQ_REMOVE = 1,
+	SCS_REQ_CHANGE = 2,
+};
+
+/* Optional subelement IDs for MSCS Descriptor element */
+enum mscs_description_subelem {
+	MCSC_SUBELEM_STATUS = 1,
+};
+
+#endif /* IEEE802_11_DEFS_H */
diff -urpN wsdd2.old/wsd.c wsdd2/wsd.c
--- wsdd2.old/wsd.c	2021-02-18 14:59:20.992472515 +0700
+++ wsdd2/wsd.c	2021-11-29 14:22:49.857126999 +0700
@@ -1,11 +1,11 @@
 /*
    WSDD - Web Service Dynamic Discovery protocol server
-  
+
    WSD protocol handler
 
-  	Copyright (c) 2016 NETGEAR
-  	Copyright (c) 2016 Hiro Sugawara
-  
+	Copyright (c) 2016 NETGEAR
+	Copyright (c) 2016 Hiro Sugawara
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
@@ -49,8 +49,22 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
-#include "wsdd.h"
-#include "wsd.h"
+
+#define _GNU_SOURCE // asprintf()
+
+#include "wsdd.h" // struct endpoint, DEBUG()
+#include "wsd.h" // struct wsd_req_info, WSD_ACTION_HELLO
+
+#include <stdbool.h> // bool
+#include <stdio.h> // FILE, fopen(), fscanf(), snprintf(), asprintf()
+#include <stdlib.h> // srand48()
+#include <unistd.h> // usleep()
+#include <string.h> // strcmp(), strdup()
+#include <ctype.h> // isdigit(), isspace()
+#include <time.h> // time_t, time()
+#include <errno.h> // errno
+#include <sys/socket.h> // sendto()
+#include <arpa/inet.h> // inet_ntop()
 
 #define UUIDLEN	37
 
@@ -92,11 +106,11 @@ static void uuid_random(char *uuid, size
 			mrand48() & 0xffff);
 }
 
-static void uuid_endpoint(char *uuid, size_t len)
+static void uuid_endpoint(char uuid[UUIDLEN])
 {
 	FILE *fp = fopen("/etc/machine-id", "r");
 	int c, i = 0;
-	
+
 	if (!fp) {
 		fp = fopen("/proc/sys/kernel/random/boot_id", "r");
 	}
@@ -122,50 +136,6 @@ static void uuid_endpoint(char *uuid, si
 	}
 }
 
-static char *get_smbparm(struct endpoint *ep,
-			const char *name, const char *_default)
-{
-#define __FUNCTION__	"get_smbparm"
-	char *cmd = NULL, *result = NULL;
-
-	if (asprintf(&cmd, "testparm -s --parameter-name=\"%s\" 2>/dev/null",
-			name) <= 0) {
-		ep->_errno = errno;
-		ep->errstr = __FUNCTION__ ": Can't allocate cmd string";
-		return NULL;
-	}
-
-	FILE *pp = popen(cmd, "r");
-
-	if (!pp) {
-		ep->_errno = errno;
-		ep->errstr = __FUNCTION__ ": Can't run testparam";
-		free(cmd);
-		return strdup(_default);
-	} else {
-		char buf[80];
-
-		if (!fgets(buf, sizeof buf, pp) || !buf[0]  || buf[0] == '\n') {
-			DEBUG(0, W, "cannot read %s from testparm", name);
-			result = strdup(_default);
-		} else {/* Trim sapces. */
-			char *p;
-
-			for (p = buf + strlen(buf) - 1;
-				buf < p && isspace(*p); p--)
-				*p = '\0';
-			for (p = buf; *p && isspace(*p); p++)
-				;
-			result = strdup(p);
-		}
-		pclose(pp);
-		free(cmd);
-	}
-
-	return result;
-#undef __FUNCTION__
-}
-
 static struct {
 	const char *key, *_default;
 	char *value;
@@ -180,14 +150,6 @@ static struct {
 	{}
 };
 
-void printBootInfoKeys(FILE *fp, int sp)
-{
-	int i = 0;
-
-	while (bootinfo[i].key)
-		fprintf(fp, "%*s%s\n", sp, "", bootinfo[i++].key);
-}
-
 int set_getresp(const char *str, const char **next)
 {
 	int i;
@@ -195,11 +157,11 @@ int set_getresp(const char *str, const c
 	size_t keylen, vallen;
 
 	if (str == NULL) {
-	    return -1;
+		return -1;
 	}
 
 	if (*str == '\0') {
-	    return -1;
+		return -1;
 	}
 
 	/* Trim leading space. */
@@ -239,11 +201,13 @@ int set_getresp(const char *str, const c
 	for (i = 0; bootinfo[i].key; i++)
 		if (!strncasecmp(bootinfo[i].key, str, keylen))
 			break;
+
 	if (!bootinfo[i].key)
 		return -1;
 
 	if (!bootinfo[i].value)
 		bootinfo[i].value = strndup(val, vallen + 1);
+
 	return 0;
 
 exit:
@@ -252,31 +216,36 @@ exit:
 	return -1;
 }
 
-static const char *get_getresp(const char *key)
+const char *get_getresp(const char *key)
 {
-	int i;
-
-	for (i = 0; bootinfo[i].key; i++)
+	for (int i = 0; bootinfo[i].key; i++)
 		if (!strcmp(bootinfo[i].key, key))
-			return bootinfo[i].value
-					? bootinfo[i].value
-					: bootinfo[i]._default;
+			return bootinfo[i].value ? bootinfo[i].value : bootinfo[i]._default;
 	return "UNKNOWN";
 }
 
-static bool getresp_inited;
-static void init_getresp(void)
+void printBootInfoKeys(FILE *fp, int indent)
 {
-	FILE *fp = fopen("/proc/sys/dev/boot/info", "r");
+	for (int i = 0; bootinfo[i].key; i++) {
+		fprintf(fp, "%*s%s %s\n", indent, "",
+			bootinfo[i].key, get_getresp(bootinfo[i].key));
+	}
+}
 
-	if (fp) {
-		char buf[80];
+void init_getresp(void)
+{
+	static bool getresp_inited = false;
 
-		while (fgets(buf, sizeof buf, fp))
-			set_getresp(buf, NULL);
-		fclose(fp);
+	if (!getresp_inited) {
+		FILE *fp = fopen("/proc/sys/dev/boot/info", "r");
+		if (fp) {
+			char buf[80];
+			while (fgets(buf, sizeof(buf), fp))
+				set_getresp(buf, NULL);
+			fclose(fp);
+		}
+		getresp_inited = true;
 	}
-	getresp_inited = true;
 }
 
 #define SOAP11_NS \
@@ -314,17 +283,17 @@ static void init_getresp(void)
  * macros
  */
 #define RESET_BUFFER(buf, buflen) \
-	if (buflen > 0) do { memset(buf, 0, buflen); buflen=0; } while(0)
+	if ((buflen) > 0) do { memset(buf, 0, buflen); (buflen)=0; } while(0)
 
 #define COPY_STRING_TO_BUFFER(dst, dstlen, start, src, srclen) \
 	do { \
-		srclen = strlen(src); \
-		if (((start + srclen) - dst) > dstlen) { \
-			srclen = -1; \
+		(srclen) = strlen(src); \
+		if ((((start) + (srclen)) - (dst)) > (dstlen)) { \
+			(srclen) = -1; \
 			break; \
 		} \
 		strncpy(start, src, srclen); \
-		start += srclen; \
+		(start) += (srclen); \
 	} while(0)
 
 #define RESOLVE_TAG_AND_SAVE \
@@ -368,7 +337,7 @@ static const char *wsd_tag_find(const ch
 /*
  * Extremely simplified flat XML parser - practical enough for our purposes.
  */
-static struct wsd_req_info *wsd_req_parse(const char *xml, size_t length)
+static struct wsd_req_info *wsd_req_parse(const char *xml)
 {
 	static const char *action_tag[][2] = {
 		{"<wsa:Action>", "</wsa:Action>"},
@@ -393,22 +362,27 @@ static struct wsd_req_info *wsd_req_pars
 	if (!msgid)
 		return NULL;
 
-	struct wsd_req_info *info = calloc(sizeof *info, 1);
+	struct wsd_req_info *info = (struct wsd_req_info *) calloc(sizeof *info, 1);
 	if (!info)
 		return NULL;
 
 	info->action = strndup(action, action_len);
 	info->msgid = strndup(msgid, msgid_len);
 
+	static const char *address_tag[][2] = { {"<wsa:Address>", "</wsa:Address>"}, {} };
+	size_t address_len;
+	const char *address = wsd_tag_find(xml, address_tag, &address_len);
+	info->address = address ? strndup(address, address_len) : NULL;
+
 	return info;
 }
 
 static void wsd_req_destruct(struct wsd_req_info *info)
 {
-	if (!info)
-		return;
+	if (!info) return;
 	free(info->action);
 	free(info->msgid);
+	free(info->address);
 	free(info);
 }
 
@@ -456,27 +430,26 @@ enum wsd_action wsd_action_id(const stru
 static int wsd_send_msg(int fd, struct endpoint *ep, const _saddr_t *sa,
 			const char *msg, size_t msglen, unsigned int rwait)
 {
-	char ip[_ADDRSTRLEN];
 	int ret;
 
-	inet_ntop(sa->ss.ss_family, _SIN_ADDR(sa), ip, sizeof ip);
-	DEBUG(3, W, "TO: %s:%u (fd=%d)\n%s\n", ip, _SIN_PORT(sa), fd, msg);
-
-	if (rwait) {
-		useconds_t us = random() % rwait;
-		usleep(us);
+	errno = 0;
+	if (ep->type == SOCK_STREAM) {
+		ret = send(fd, msg, msglen, MSG_NOSIGNAL);
+	} else {
+		if (rwait) {
+			useconds_t us = random() % rwait;
+			usleep(us);
+		}
+		ret = sendto(fd, msg, msglen, MSG_NOSIGNAL, (struct sockaddr *)sa,
+			(ep->family == AF_INET) ? sizeof sa->in : sizeof sa->in6);
 	}
 
-	if (ep->type == SOCK_STREAM)
-		ret = send(fd, msg, msglen, MSG_NOSIGNAL);
-	else
-		ret = sendto(fd, msg, msglen, MSG_NOSIGNAL,
-				(struct sockaddr *)sa,
-				(ep->family == AF_INET)
-					? sizeof sa->in
-					: sizeof sa->in6);
+	char ip[_ADDRSTRLEN];
+	inet_ntop(sa->ss.ss_family, _SIN_ADDR(sa), ip, sizeof ip);
+	DEBUG(3, W, "WSD-TO %s port %u (fd=%d,len=%ld,sent=%d) '%s'\n", ip, _SIN_PORT(sa), fd,
+		msglen, ret, msg);
 
-	return !(ret == msglen);
+	return ret != (int) msglen;
 }
 
 /*
@@ -525,8 +498,8 @@ static int wsd_send_soap_fault(int fd, s
 	}
 
 	rv = wsd_send_msg(fd, ep, sa, s, len, 0);
-	free(s);
 
+	free(s);
 	return rv;
 }
 
@@ -559,7 +532,7 @@ static int wsd_send_soap_msg(int fd, str
 	"<wsa:To>%s</wsa:To>"
 	"<wsa:Action>%s</wsa:Action>"
 	"<wsa:MessageID>urn:uuid:%s</wsa:MessageID>"
-	"<wsd:AppSequence InstanceId=\"%lu\" SequenceId=\"urn:uuid:%s\" "
+	"<wsd:AppSequence InstanceId=\"%lld\" SequenceId=\"urn:uuid:%s\" "
 	"MessageNumber=\"%u\" />"
 	"%s"
 	"</soap:Header>"
@@ -586,7 +559,7 @@ static int wsd_send_soap_msg(int fd, str
 	}
 
 	ssize_t msglen = asprintf(&msg, soap_msg_templ, to, action, msg_id,
-				wsd_instance, wsd_sequence,
+				(long long)wsd_instance, wsd_sequence,
 				++msg_no, soap_relates,
 				body);
 	free(soap_relates);
@@ -601,7 +574,7 @@ static int wsd_send_soap_msg(int fd, str
 	if (header)
 		rv = header(fd, ep, sa, status, msglen);
 
-	if (!rv) {
+	if (rv == 0) {
 		rv = wsd_send_msg(fd, ep, sa, msg, msglen, 0);
 		if (rv) {
 			ep->errstr = __FUNCTION__ ": send";
@@ -609,8 +582,8 @@ static int wsd_send_soap_msg(int fd, str
 			rv = -1;
 		}
 	}
-	free(msg);
 
+	free(msg);
 	return rv;
 #undef __FUNCTION__
 }
@@ -635,10 +608,9 @@ static int wsd_send_hello(struct endpoin
 		return -1;
 	}
 
-	int rv = wsd_send_soap_msg(ep->sock, ep,
-				&ep->mcast, WSD_TO_DISCOVERY,
-				WSD_ACT_HELLO, NULL, body,
-				NULL, 0);
+	int rv = wsd_send_soap_msg(ep->sock, ep, &ep->mcast, WSD_TO_DISCOVERY,
+				WSD_ACT_HELLO, NULL, body, NULL, 0);
+
 	free(body);
 	return rv;
 }
@@ -663,12 +635,10 @@ static int wsd_send_bye(struct endpoint
 		return -1;
 	}
 
-	int rv = wsd_send_soap_msg(ep->sock, ep,
-				&ep->mcast, WSD_TO_DISCOVERY,
-				WSD_ACT_BYE, NULL, body,
-				NULL, 0);
-	free(body);
+	int rv = wsd_send_soap_msg(ep->sock, ep, &ep->mcast, WSD_TO_DISCOVERY,
+				WSD_ACT_BYE, NULL, body, NULL, 0);
 
+	free(body);
 	return rv;
 }
 
@@ -693,12 +663,7 @@ static int wsd_send_probe_match(int fd,
 		"</soap:Body>";
 	char *body, *uri_ip = ip2uri(ip);
 
-	if (!uri_ip ||
-		asprintf(&body, body_templ,
-			wsd_endpoint,
-			uri_ip,
-			ep->port,
-			wsd_endpoint) <= 0) {
+	if (!uri_ip || asprintf(&body, body_templ, wsd_endpoint, uri_ip, ep->port, wsd_endpoint) <= 0) {
 		ep->errstr = "wsd_send_probe_match: ip2uri/asprintf";
 		ep->_errno = errno;
 		free(uri_ip);
@@ -706,8 +671,8 @@ static int wsd_send_probe_match(int fd,
 	}
 
 	int rv = wsd_send_soap_msg(fd, ep, sa, WSD_TO_ANONYMOUS,
-				WSD_ACT_PROBEMATCH, info->msgid, body,
-				NULL, 0);
+				WSD_ACT_PROBEMATCH, info->msgid, body, NULL, 0);
+
 	free(uri_ip);
 	free(body);
 	return rv;
@@ -734,12 +699,7 @@ static int wsd_send_resolve_match(int fd
 		"</soap:Body>";
 	char *body, *uri_ip = ip2uri(ip);
 
-	if (!uri_ip ||
-		asprintf(&body, body_templ,
-			wsd_endpoint,
-			uri_ip,
-			ep->port,
-			wsd_endpoint) <= 0) {
+	if (!uri_ip || asprintf(&body, body_templ, wsd_endpoint, uri_ip, ep->port, wsd_endpoint) <= 0) {
 		ep->errstr = "wsd_send_resolve_match: ip2uri/asprintf";
 		ep->_errno = errno;
 		free(uri_ip);
@@ -747,8 +707,8 @@ static int wsd_send_resolve_match(int fd
 	}
 
 	int err = wsd_send_soap_msg(fd, ep, sa, WSD_TO_ANONYMOUS,
-				WSD_ACT_RESOLVEMATCH, info->msgid, body,
-				NULL, 0);
+				WSD_ACT_RESOLVEMATCH, info->msgid, body, NULL, 0);
+
 	free(uri_ip);
 	free(body);
 	return err;
@@ -798,8 +758,7 @@ static int send_http_resp_header(int fd,
 	time_t t;
 
 	time(&t);
-	strftime(time_str, sizeof(time_str), "%a, %d %b %Y %H:%M:%S GMT",
-		 gmtime(&t));
+	strftime(time_str, sizeof(time_str), "%a, %d %b %Y %H:%M:%S GMT", gmtime(&t));
 
 	char *s;
 	ssize_t len = asprintf(&s, resp_hdr_fmt, status_str, time_str, length);
@@ -810,19 +769,18 @@ static int send_http_resp_header(int fd,
 		return -1;
 	}
 
-	DEBUG(3, W, "HEADER:\n%s\n", s);
+	DEBUG(4, W, "---------- HEADER:\n%s----------\n", s);
 
-	if (wsd_send_msg(fd, ep, sa, s, len, 50000)) {
+	if (wsd_send_msg(fd, ep, sa, s, len, WSD_RANDOM_DELAY) != 0) {
 		ep->errstr = "send_http_resp_header: send";
 		ep->_errno = errno;
 		rv = -1;
 	}
+
 	free(s);
 	return rv;
 }
 
-char *netbiosname=NULL, *workgroup=NULL;
-
 static int wsd_send_get_response(int fd,
 				struct endpoint *ep,
 				const _saddr_t *sa,
@@ -884,6 +842,9 @@ static int wsd_send_get_response(int fd,
 				netbiosname,
 				workgroup
 			);
+
+	(void) ip; // silent "unused" warning
+
 	if (len <= 0) {
 		ep->errstr = "wsd_send_get_response: asprintf";
 		ep->_errno = errno;
@@ -891,8 +852,8 @@ static int wsd_send_get_response(int fd,
 	}
 
 	int rv = wsd_send_soap_msg(fd, ep, sa, WSD_TO_ANONYMOUS,
-					WXT_ACT_GETRESPONSE, info->msgid, body,
-					send_http_resp_header, 200);
+				WXT_ACT_GETRESPONSE, info->msgid, body, send_http_resp_header, 200);
+
 	free(body);
 	return rv;
 }
@@ -915,15 +876,15 @@ static int wsd_parse_http_header(int fd,
 		endpointlen = strlen(wsd_endpoint);
 
 	*eol = '\0';
-	if (strncmp(p, "POST /", 6)) {
+	if (strncmp(p, "POST /", 6) != 0) {
 		ep->errstr = __FUNCTION__ ": Only POST method supported";
 		return 405;
 	}
-	if (strncmp(p + 6, wsd_endpoint, endpointlen)) {
+	if (strncmp(p + 6, wsd_endpoint, endpointlen) != 0) {
 		ep->errstr = __FUNCTION__ ": Invalid endpoint UUID";
 		return 404;
 	}
-	if (strncmp(p + 6 + endpointlen, " HTTP/", 6)) {
+	if (strncmp(p + 6 + endpointlen, " HTTP/", 6) != 0) {
 		ep->errstr = __FUNCTION__ ": Must be HTTP/1.0 and up";
 		return 405;
 	}
@@ -931,23 +892,25 @@ static int wsd_parse_http_header(int fd,
 	p = eol + 2;
 
 again:
-#define HEADER_IS(p,h)	(strncasecmp((p),(h),strlen((h)))? NULL :(p)+strlen(h)) 
+#define HEADER_IS(p,h) (strncasecmp((p), (h), strlen((h))) ? NULL : (p) + strlen(h))
 	while (*p && (eol = strstr(p, "\r\n")) != p) {
 		const char *val;
 
-		if (!eol)
-			break;
+		if (!eol) break;
 		*eol = '\0';
-		if ((val = HEADER_IS(p, "Content-Type: "))) {
-			if (strcmp(val, "application/soap+xml")) {
-				ep->errstr = __FUNCTION__
-						": Unsupported Content-Type";
+
+		if ((val = HEADER_IS(p, "Content-Type:"))) {
+			while (*val == ' ' || *val == '\t' || *val == '\r' || *val == '\n')
+				val++; // skip LWS
+			if (strcmp(val, "application/soap+xml") != 0) {
+				ep->errstr = __FUNCTION__ ": Unsupported Content-Type";
 				return 400;
 			}
-		} else if ((val = HEADER_IS(p, "Content-Length: "))) {
+		} else if ((val = HEADER_IS(p, "Content-Length:"))) {
+			while (*val == ' ' || *val == '\t' || *val == '\r' || *val == '\n')
+				val++; // skip LWS
 			if ((contentlength = atoi(val)) <= 0) {
-				ep->errstr = __FUNCTION__
-						": Invalid Content-Length";
+				ep->errstr = __FUNCTION__ ": Invalid Content-Length";
 				return 400;
 			}
 		}
@@ -962,7 +925,7 @@ again:
 	memmove(buf, p, len -= (p - buf));
 	buf[len] = '\0';
 
-	if (!eoh) {/* Have not reached end of header. */
+	if (!eoh) { /* Have not reached end of header. */
 		ssize_t len2 = recv(fd, buf + len, bsize - len - 1, 0);
 
 		if (len2 <= 0) {
@@ -987,26 +950,25 @@ again:
 
 		ssize_t len2 = recv(fd, buf + len, contentlength - len, 0);
 
-		if (len2 < contentlength - len) {
+		if (len2 < (ssize_t) (contentlength - len)) {
 			ep->errstr = __FUNCTION__ ": Data receiving error";
 			return 500;
 		}
 	}
+
 	buf[contentlength] = '\0';
 	return 200;
 #undef	__FUNCTION__
 }
 
-static char hostname[HOST_NAME_MAX + 1];
-
 int wsd_init(struct endpoint *ep)
 {
 	if (!wsd_instance)
 		time(&wsd_instance);
 	if (!wsd_sequence[0])
-		uuid_random(wsd_sequence, sizeof wsd_sequence);
+		uuid_random(wsd_sequence, sizeof(wsd_sequence));
 	if (!wsd_endpoint[0]) {
-		uuid_endpoint(wsd_endpoint, UUIDLEN);
+		uuid_endpoint(wsd_endpoint);
 		if (!wsd_endpoint[0]) {
 			ep->errstr = "wsd_init: uuid_endpoint";
 			ep->_errno = errno;
@@ -1014,22 +976,6 @@ int wsd_init(struct endpoint *ep)
 		}
 	}
 
-	if (!hostname[0] && gethostname(hostname, sizeof hostname - 1)) {
-		ep->errstr = "wsd_init: gethostname";
-		ep->_errno = errno;
-		return -1;
-	}
-
-	if (!workgroup &&
-		!(workgroup = get_smbparm(ep, "workgroup", "WORKGROUP")))
-		return -1;
-	if (!netbiosname &&
-		!(netbiosname = get_smbparm(ep, "netbios name", hostname)))
-		return -1;
-
-	if (!getresp_inited)
-		init_getresp();
-
 	return wsd_send_hello(ep);
 }
 
@@ -1052,8 +998,7 @@ static int wsd_recv_action(int (*f)(int
 	}
 
 	char ip[_ADDRSTRLEN];
-	void *src = (sa->ss.ss_family == AF_INET) ? (void *)&ci.in.sin_addr
-						: (void *)&ci.in6.sin6_addr;
+	void *src = (sa->ss.ss_family == AF_INET) ? (void *)&ci.in.sin_addr : (void *)&ci.in6.sin6_addr;
 
 	if (!inet_ntop(sa->ss.ss_family, src, ip, sizeof ip)) {
 		ep->errstr = "wsd_recv_action: inet_ntop";
@@ -1067,13 +1012,11 @@ static int wsd_recv_action(int (*f)(int
 int wsd_recv(struct endpoint *ep)
 {
 	char buf[10000];
-	_saddr_t sa;
+	_saddr_t sa = {};
 	socklen_t slen = (ep->family == AF_INET) ? sizeof sa.in : sizeof sa.in6;
 	int fd = ep->sock;
 	ssize_t len;
 
-	memset(&sa, 0, slen);
-
 	if (ep->type == SOCK_STREAM) {
 		struct timeval to = { .tv_sec = 1, .tv_usec = 0};
 
@@ -1087,9 +1030,9 @@ int wsd_recv(struct endpoint *ep)
 			DEBUG(3, W, "Unable to set receive timeout\n");
 		}
 		len = recv(fd, buf, sizeof buf - 1, 0);
-	} else
-		len = recvfrom(fd, buf, sizeof buf - 1, 0,
-				(struct sockaddr *)&sa, &slen);
+	} else {
+		len = recvfrom(fd, buf, sizeof buf - 1, 0, (struct sockaddr *)&sa, &slen);
+	}
 
 	if (len <= 0) {
 		if (ep->sock != fd)
@@ -1102,40 +1045,42 @@ int wsd_recv(struct endpoint *ep)
 	{
 		char ip[_ADDRSTRLEN];
 		inet_ntop(sa.ss.ss_family, _SIN_ADDR(&sa), ip, sizeof ip);
-		DEBUG(3, W, "FROM: %s:%u (fd=%d)\n%s\n",
-			ip, _SIN_PORT(&sa), fd, buf);
+		DEBUG(3, W, "WSD-FROM %s port %u (fd=%d,len=%ld): '%s'\n", ip, _SIN_PORT(&sa), fd, len, buf);
 	}
 
-	if (ep->type == SOCK_STREAM) {
-		if (!strncmp(buf, "POST ", 5)) {
-			int status = wsd_parse_http_header(fd, ep,
-							buf, len, sizeof buf);
-
-			{
-				char ip[_ADDRSTRLEN];
-				inet_ntop(sa.ss.ss_family,
-					_SIN_ADDR(&sa), ip, sizeof ip);
-				DEBUG(3, W, "BODY: %s:%u (fd=%d)\n%s\n",
-					ip, _SIN_PORT(&sa), fd, buf);
-			}
+	if (ep->type == SOCK_STREAM && strncmp(buf, "POST ", 5) == 0) {
+		int status = wsd_parse_http_header(fd, ep, buf, len, sizeof buf);
+
+		{
+			char ip[_ADDRSTRLEN];
+			inet_ntop(sa.ss.ss_family, _SIN_ADDR(&sa), ip, sizeof ip);
+			DEBUG(3, W, "WSD-BODY %s port %u (fd=%d,status=%d,len=%ld): '%s'\n", ip, _SIN_PORT(&sa),
+				fd, status, strlen(buf), buf);
+		}
 
-			if (status > 200) {
-				send_http_resp_header(fd, ep, &sa, status, 0);
-				if (status >= 400)
-					wsd_send_soap_fault(fd, ep, &sa,
-							status,
-							ep->errstr,
-							ep->errstr);
+		if (status > 200) {
+			send_http_resp_header(fd, ep, &sa, status, 0);
+			if (status >= 400)
+				wsd_send_soap_fault(fd, ep, &sa, status, ep->errstr, ep->errstr);
+			if (ep->sock != fd)
 				close(fd);
-				return 0;
-			}
+			return 0;
 		}
 	}
 
 	int rv = 0;
-	struct wsd_req_info *info = wsd_req_parse(buf, len);
+	struct wsd_req_info *info = wsd_req_parse(buf);
+
+	{
+		char src[_ADDRSTRLEN];
+		inet_ntop(sa.ss.ss_family, _SIN_ADDR(&sa), src, sizeof src);
+		const char *action = info && info->action ? strrchr(info->action, '/') : "NONE";
+		if (!action) action = info->action;
+		const char *address = info && info->address ? info->address : NULL;
+		DEBUG(2, W, "WSD-ACTION %s port %u %s %s %s", src, _SIN_PORT(&sa),
+			ep->service->name, action, address);
+	}
 
-	DEBUG(2, W, "WSD_ACTION: %s", info ? info->action : "NONE");
 	switch (wsd_action_id(info)) {
 	case WSD_ACTION_PROBE:
 		rv = wsd_recv_action(wsd_send_probe_match, fd, ep, &sa, info);
@@ -1152,8 +1097,7 @@ int wsd_recv(struct endpoint *ep)
 	}
 
 	if (rv)
-		DEBUG(1, W,
-			"wsd_recv: %s: %s", ep->errstr, strerror(ep->_errno));
+		DEBUG(1, W, "wsd_recv: %s: %s", ep->errstr, strerror(ep->_errno));
 
 	wsd_req_destruct(info);
 	if (ep->sock != fd)
@@ -1165,4 +1109,3 @@ void wsd_exit(struct endpoint *ep)
 {
 	wsd_send_bye(ep);
 }
-
diff -urpN wsdd2.old/wsd.h wsdd2/wsd.h
--- wsdd2.old/wsd.h	2020-01-31 19:31:29.516885489 +0700
+++ wsdd2/wsd.h	2021-11-29 14:22:49.857126999 +0700
@@ -25,11 +25,14 @@
 #ifndef WSD_H
 #define WSD_H
 
+#include <sys/types.h> // size_t
+
 #define WSD_PORT		3702
 #define WSD_HTTP_PORT		WSD_PORT
 #define WSD_MCAST_ADDR		("239.255.255.250")
 #define WSD_MCAST6_ADDR		("FF02::C")
 #define WSD_HTTP_TIMEOUT	120
+#define WSD_RANDOM_DELAY	50000
 
 enum wsd_action {
 	WSD_ACTION_NONE,
@@ -46,6 +49,7 @@ enum wsd_action {
 struct wsd_req_info {
 	char *action;
 	char *msgid;
+	char *address;
 	struct {
 		struct xmlns_qname *types[64];
 		size_t types_length;
diff -urpN wsdd2.old/wsdd.h wsdd2/wsdd.h
--- wsdd2.old/wsdd.h	2020-01-31 19:31:29.516885489 +0700
+++ wsdd2/wsdd.h	2021-11-29 14:22:49.857126999 +0700
@@ -21,41 +21,41 @@
 #ifndef _WSDD_H_
 #define _WSDD_H_
 
-#define _GNU_SOURCE
+#include <stdbool.h> // bool
+#include <stdio.h> // FILE, fopen(), fprintf()
+#include <syslog.h> // syslog()
+#include <net/if.h> // IFNAMSIZ
+#include <arpa/inet.h> // ntohs()
+#include <netinet/in.h> // struct sockaddr_in, struct ip_mreq
+#include <linux/in.h> // struct ip_mreqn
+#include <linux/netlink.h> // struct sockaddr_nl
+#include <time.h> // time_t, time()
 
-#include <sys/types.h>
+/* wsdd2.c */
+extern const char *hostname, *hostaliases, *netbiosname, *netbiosaliases, *workgroup;
+extern int debug_L, debug_W;
+extern bool is_daemon;
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <strings.h>
-#include <unistd.h>
-
-#include <stdbool.h>
-#include <ctype.h>
-#include <err.h>
-#include <errno.h>
-
-#include <time.h>
-#include <syslog.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <arpa/inet.h>
-#include <net/if.h>
-#include <netinet/in.h>
-#include <netdb.h>
-#include <ifaddrs.h>
-#include <linux/rtnetlink.h>
+#define LOG(level, ...)						\
+	do {							\
+		if (is_daemon) {				\
+			syslog(LOG_USER | (level), __VA_ARGS__);\
+		} else {					\
+			fprintf(stderr, __VA_ARGS__);		\
+			putc('\n', stderr);			\
+		}						\
+	} while (0)
 
-extern int debug_L, debug_W;
-extern char *netbiosname, *workgroup;
-#define DEBUG(x, y, ...)	\
-	do {	\
-		if (debug_##y >= (x)) {	\
-			fprintf(stderr, __VA_ARGS__);	\
-			putc('\n', stderr);		\
-			syslog(LOG_USER|LOG_ERR, __VA_ARGS__);	\
-		}		\
+#define DEBUG(x, y, ...)						\
+	do {								\
+		if (debug_##y >= (x)) {					\
+			if (is_daemon) {				\
+				syslog(LOG_USER | LOG_DEBUG, __VA_ARGS__);\
+			} else {					\
+				fprintf(stderr, __VA_ARGS__);		\
+				putc('\n', stderr);			\
+			}						\
+		}							\
 	} while (0)
 
 #ifndef HOST_NAME_MAX
@@ -63,16 +63,17 @@ extern char *netbiosname, *workgroup;
 #endif
 
 #ifndef ARRAY_SIZE
-#define ARRAY_SIZE(a)	(sizeof(a)/sizeof(a[0]))
+#define ARRAY_SIZE(a)	(sizeof(a) / sizeof((a)[0]))
 #endif
 
-#ifndef max
-#define max(a, b)	((a)>(b)?(a):(b))
+#ifndef MAX
+#define MAX(a, b)	((a)>(b)?(a):(b))
 #endif
 
-#define _ADDRSTRLEN	max(INET_ADDRSTRLEN, INET6_ADDRSTRLEN)
+#define _ADDRSTRLEN	MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN)
 
 typedef union {
+	struct sockaddr		sa;
 	struct sockaddr_in	in;
 	struct sockaddr_in6	in6;
 	struct sockaddr_nl	nl;
@@ -94,16 +95,18 @@ struct endpoint {
 	int family, type, protocol;
 	in_port_t port;
 	int sock;
-	char *errstr;
+	const char *errstr;
 	int _errno;
-	size_t mlen, llen;
+	size_t mlen, llen, mreqlen;
 	_saddr_t mcast, local;
 	union {
+#ifdef USE_ip_mreq
 		struct ip_mreq ip_mreq;
-		/* struct ip_mreqn ip_mreq; */
+#else
+		struct ip_mreqn ip_mreq;
+#endif
 		struct ipv6_mreq ipv6_mreq;
 	} mreq;
-	size_t mreqlen;
 };
 
 struct service {
@@ -122,21 +125,29 @@ struct service {
 	time_t interval;
 };
 
-extern int wsd_init(struct endpoint *);
-extern int wsd_recv(struct endpoint *);
-extern void wsd_exit(struct endpoint *);
-
-extern int wsd_http(struct endpoint *);
-
-extern int llmnr_init(struct endpoint *);
-extern int llmnr_recv(struct endpoint *);
-extern int llmnr_timer(struct endpoint *);
-extern void llmnr_exit(struct endpoint *);
-
-extern int connected_if(const _saddr_t *, _saddr_t *);
-extern char *ip2uri(const char *);
-
-extern int set_getresp(const char *, const char **);
-extern void printBootInfoKeys(FILE *, int);
+// wsd.c
+int wsd_init(struct endpoint *);
+int wsd_recv(struct endpoint *);
+void wsd_exit(struct endpoint *);
+
+void init_getresp(void);
+const char *get_getresp(const char *key);
+int set_getresp(const char *key, const char **endp);
+void printBootInfoKeys(FILE *fp, int indent);
+
+// llmnr.c
+int llmnr_init(struct endpoint *);
+int llmnr_recv(struct endpoint *);
+void llmnr_exit(struct endpoint *);
+
+// wsdd2.c
+int connected_if(const _saddr_t *, _saddr_t *);
+char *ip2uri(const char *);
+
+// nl_debug.c
+int nl_debug(void *buf, int len);
+void dump(const void *p, size_t len, unsigned long start, const char *prefix);
+void dump_str(const void *p, size_t len);
+void dump_hex(const void *p, size_t len);
 
 #endif
diff -urpN wsdd2.old/wsdd2.8 wsdd2/wsdd2.8
--- wsdd2.old/wsdd2.8	2020-01-31 19:31:29.516885489 +0700
+++ wsdd2/wsdd2.8	2021-11-29 14:22:49.857126999 +0700
@@ -1,7 +1,7 @@
 '\" t
 .\"     Title: wsdd2
 .\"
-.TH "WSDD2" "8" "03/15/2016" "WSDD" "System Administration tools"
+.TH "WSDD2" "8" "02/05/2021" "WSDD" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * set default formatting
 .\" -----------------------------------------------------------------
@@ -12,31 +12,30 @@
 .\" -----------------------------------------------------------------
 .\" * MAIN CONTENT STARTS HERE *
 .\" -----------------------------------------------------------------
+
 .SH "NAME"
-wsdds \- server to provide WSDD/LLMNR services to clients
+wsdd2 \- server to provide WSDD/LLMNR services to clients
 .SH "SYNOPSIS"
 .HP \w'\ 'u
-wsddd2 [\-4] [\-6] [\-L] [\-W] [\-d] [\-h] [\-l] [\-t] [\-u] [\-w]
+wsddd2 [\-h] [\-d] [\-4] [\-6] [\-u] [\-t] [\-l] [\-w] [\-L] [\-W]
+[\-i <intrerface>] [\-H <hostname>] [\-N <netbiosname>] [\-G <workgroup>]
+[\-b <kvlist>]
+
 .SH "DESCRIPTION"
 .PP
-\fBwsdd2\fR
-is the server daemon that provides WSDD (Web Services Dynamic Discovery)
-as well as LLMNR (Link-Local Multicast Name Resolution) services
+\fBwsdd2\fR is the server daemon that provides WSDD (Web Services Dynamic
+Discovery) as well as LLMNR (Link-Local Multicast Name Resolution) services
 primarily for Windows clients on both IPv4 and IPv6.
 .PP
-\fBwsdd2\fR's WSDD protocol handler
-multicasts Hello and Bye messages by itself over UDP,
-submits ProbeMatch and ResolveMatch messages
-in response to Probe and Resolve queries respectively over UDP,
-and submits HTTP reponse messages
-to HTTP property query POST messages over TCP.
-.PP
-\fBwsdd2\fR's LLMNR protocol handler
-responds to LLMNR multicast query messages over UDP
-and to LLMNR unicast query messages over TCP.
+\fBwsdd2\fR's WSDD protocol handler multicasts Hello and Bye messages by
+itself over UDP, responds with ProbeMatch and ResolveMatch messages in
+response to Probe and Resolve queries respectively over UDP, and sends
+HTTP reponse messages to HTTP property query POST messages over TCP.
 .PP
-\fBwsdd2\fR
-uses and listens on the following ports:
+\fBwsdd2\fR's LLMNR protocol handler responds to LLMNR multicast query
+messages over UDP and to LLMNR unicast query messages over TCP.
+.PP
+\fBwsdd2\fR uses and listens on the following ports:
 .PP
 3702 UDP
 .RS 4
@@ -57,159 +56,192 @@ LLMNR query multicast group addresses 22
 .RS 4
 LLMNR query unicast.
 .RE
+
 .SH "OPTIONS"
 .PP
+\-h
+.RS 4
+Display a simple help messasge to stdout including currently in effect
+parameters' values.
+.RE
+
+.PP
+\-d
+.RS 4
+Fork off a child process to become daemon.
+.RE
+
+.PP
 \-4 \-6
 .RS 4
 Respond only to IPv4 and IPv6 respectively.
-Default is equivalent to "\-4 \-6."
+Default is equivalent to "\-4 \-6".
+.RE
+
+.PP
+\-u \-t
+.RS 4
+Respond only to UDP and TCP respectively.
+Default is equivalent to "\-u \-t".
 .RE
+
+.PP
+\-l \-w
+.RS 4
+Respond only to LLMNR and WSDD respectively.
+Default is equivalent to "\-l \-w".
+.RE
+
 .PP
 \-L
 .RS 4
 Print out LLMNR debug messages to stdout.
 Multiple \-L's to increment debug level.
 .RE
+
 .PP
 \-W
 .RS 4
 Print out WSDD debug messages to stdout.
 Multiple \-W's to increment debug level.
 .RE
+
 .PP
-\-b "\fIkey1\fR:\fIval1\fR,\fIkey2\fR:\fIval2\fR,\fI...\fR"
+\-i <interface>
 .RS 4
-Set WSDD query over HTTP response values in a comma-delimited list.
-The valid/necessary keys are:
-.RS 4
-vendor
-model
-serial
-sku
-vendorurl
-modelutl
-presentationurl
-.RE
-This option overrides /proc/sys/dev/boot/info readouts.
+Use only specified interface to reply to incoming requests. Specifying "any"
+or leaving option out causes \fBwsdd2\fR to listen on every IPv4 or IPv6
+capable interface excluding those that have names matching LeafNets,
+docker*, veth*, tun*, ppp*, zt*.
 .RE
+
 .PP
-\-d
+\-H <hostname>
 .RS 4
-Fork off a child process to go daemon.
+Use specified string as host name instead of first label before '.' of
+system host name retrieved with \fBgethostname\fR(3) or \fBuname\fR(3)
+functions.
 .RE
+
 .PP
-\-h
+\-N <nebiosname>
 .RS 4
-Display a simple help messasge to stdout.
+Use specified string as NETBIOS machine name instead of value returned by
+.br
+\fBtestparm -s --parameter-name="netbios name"\fR command or system host
+name.
 .RE
+
 .PP
-\-l \-w
+\-G <workgroup>
 .RS 4
-Respond only to LLMNR and WSDD respectively.
-Default is equivalent to "\-l \-w."
+Use specified string as workgroup name instead of value returned by
+.br
+\fBtestparm -s --parameter-name="workgroup"\fR command or "WORKGROUP"
+default value.
 .RE
+
 .PP
-\-t \-u
+\-b "\fIkey1\fR:\fIval1\fR,\fIkey2\fR:\fIval2\fR,\fI...\fR"
 .RS 4
-Respond only to TCP and UDP respectively.
-Default is equivalent to "\-t \-u."
+Set WSDD query over HTTP response values in a comma-delimited list. The
+valid/necessary keys are: \fBvendor, model, serial, sku, vendorurl,
+modelurl, presentationurl\fR.
+.br
+This option overrides /proc/sys/dev/boot/info readouts.
 .RE
+
 .RE
 .SH "WSDD PROPERTY QUERY RESPONSE"
 .PP
-\fBwsdd2\fR
-responds to property queries using the following values over HTTP.
-If a value may be set with multiple methods,
-the latter in the method list has precedence.
+\fBwsdd2\fR responds to property queries using the following values over
+HTTP. If a value may be set with multiple methods, the latter in the method
+list has precedence.
+
 .PP
 Vendor
 .RS 4
 Value retrieved from /proc/sys/dev/boot/info or set with the -b option.
 .RE
 .PP
-VendorURL
+Model
 .RS 4
-Value set with the -b option.
+Value retrieved from /proc/sys/dev/boot/info or set with the -b option.
 .RE
 .PP
-Model
+Serial
 .RS 4
-Value retrieved from /proc/sys/dev/boot/info or set with the -b option.
+Value retrieved from /proc/sys/dev/boot/info or set with the -b option or
+\fB0\fR.
 .RE
 .PP
-ModelURL
+SKU
 .RS 4
-Value set with the -b option.
+Value retrieved from /proc/sys/dev/boot/info or set with the -b option.
 .RE
 .PP
-PresentationURL
+ModelURL
 .RS 4
 Value set with the -b option.
 .RE
 .PP
-Host
+VendorURL
 .RS 4
-Host name retrieved with \fBgethostname\fR(3),
-NETBIOS name retrieved with \fBtestparm\fR(1),
-or value set with the -b option.
+Value set with the -b option.
 .RE
 .PP
-Workgroup
+PresentationURL
 .RS 4
-Value retrieved with \fBtestparm\fR(1) or set with the -b option.
+Value set with the -b option.
 .RE
+
 .SH "FILES"
+.PP
 /etc/samba/smb.conf
 .RS 4
-This is the default location of the samba configuration file.
+This is the default location of the Samba configuration file.
 .RE
+
 .PP
 /etc/machine-id
 .RS 4
-A single line text file containing a host-unique UUID in the form of
-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
-To create a such new file, use \fBuuidgen\fR(1).
+A single line text file containing a host-unique UUID in the form of 32
+lowercase hex digits used by \fBsystemd-id128\fR(1). See \fBmachine-id\fR(5).
 .RE
+
 .PP
 /proc/sys/dev/boot/info
 .RS 4
-A list of \fIkey\fR:\fIvalue\fR entries for 
-WSDD query over HTTP response values.
+A list of \fIkey\fR:\fIvalue\fR entries for WSDD query over HTTP response
+values.
 .RE
+
 .SH "SIGNALS"
 .PP
-Sending the
-\fBwsdd2\fR
-a SIGHUP will cause it to restart.
-Restarting will re-parse
-\fBtestparm\fR(1)'s output and other parameters,
-but it will not re-evaluated command line options.
-Any change on, addition of, or deletion of a network interface
-will restart
-\fBwsdd2\fR
-as well.
-.PP
-SIGTERM and SIGINT will terminate
-\fBwsdd2\fR
-gracefully with WSDD Bye messages.
+Sending the \fBwsdd2\fR a SIGHUP will cause it to restart. Restarting will
+bind daemon to new interfaces but will not reparse \fBtestparm\fR(1)'s
+output and other parameters, nor re-evaluate command line options - stop and
+start the daemon again for this. Address change, addition, or deletion on a
+network interface will restart \fBwsdd2\fR as well.
+.PP
+SIGTERM and SIGINT will terminate \fBwsdd2\fR gracefully with WSDD "Bye"
+messages.
+
 .SH "SEE ALSO"
 .PP
-\fBtestparm\fR(1),
+\fBtestparm\fR(1), \fBsystemd-id128\fR(1).
+
 .SH "STANDARDS"
 .PP
-The WSDD protocol is described in detail in
-"Web Services Dynamic Discovery (WS-Discovery)
-Version 1.1" OASYS Standard 1 July 2009
+The WSDD protocol is described in detail in "Web Services Dynamic Discovery
+(WS-Discovery) Version 1.1" OASYS Standard, 1 July 2009
 .br
 http://docs.oasis-open.org/ws-dd/discovery/1.1/os/wsdd-discovery-1.1-spec-os.html
 .PP
 LLMNR complies with RFC4795.
+
 .SH "AUTHOR"
 .PP
-Hiro Sugawara at NETGEAR authored the code.
-\fBwsdd2\fR was inspired by and uses some code from
-the wsdd/llmnr extension for smbd
-created by
-Tobias Waldvogel,
-Jose M. Prieto,
-and possibly other contributors.
+Hiro Sugawara at NETGEAR authored the code. \fBwsdd2\fR was inspired by and
+uses some code from the wsdd/llmnr extension for smbd created by Tobias
+Waldvogel, Jose M. Prieto, and possibly other contributors.
diff -urpN wsdd2.old/wsdd2.c wsdd2/wsdd2.c
--- wsdd2.old/wsdd2.c	2021-02-18 14:59:20.992472515 +0700
+++ wsdd2/wsdd2.c	2021-11-29 14:22:49.857126999 +0700
@@ -3,8 +3,8 @@
 
    Main file for general network handling.
   
-  	Copyright (c) 2016 NETGEAR
-  	Copyright (c) 2016 Hiro Sugawara
+	Copyright (c) 2016 NETGEAR
+	Copyright (c) 2016 Hiro Sugawara
   
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,11 +20,48 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#define _GNU_SOURCE // asprintf()
+
 #include "wsdd.h"
 
+#include <stddef.h> // NULL
+#include <limits.h> // HOST_NAME_MAX
+#include <stdbool.h> // bool
+#include <stdio.h> // snprintf(), asprintf()
+#include <stdlib.h> // calloc(), free(), EXIT_FAILURE
+#include <stdarg.h> // va_list, va_start()
+#include <setjmp.h> // jmp_buf, setjmp(), longjmp()
+#include <signal.h> // sig_atomic_t, SIGHUP, SIGINT, SIGTERM
+#include <unistd.h> // gethostname(), getpid(), setsid(), close(), dup2()
+#include <syslog.h> // openlog()
+#include <string.h> // strncpy(), strchr(), strsignal()
+#include <fcntl.h> // open()
+#include <ctype.h> // isdigit(), isspace()
+#include <errno.h> // errno, ENOMEM
+#include <err.h> // err()
+#include <libgen.h> // basename()
+#include <sys/select.h> // FD_SET()
+#include <sys/socket.h> // SOCK_DGRAM
+#include <sys/stat.h> // stat()
+#include <netdb.h> // struct servent, getservbyname()
+#include <arpa/inet.h> // inet_ntop()
+#include <net/if.h> // if_indextoname()
+#include <netinet/in.h> // IPPROTO_IP
+#include <ifaddrs.h> // struct ifaddrs, getifaddrs()
+#include <linux/netlink.h> // NETLINK_ROUTE
+#include <linux/rtnetlink.h> // RTMGRP_LINK
+
+#ifndef PAGE_SIZE
+#define PAGE_SIZE 4096 // PAGE_SIZE
+#endif
+
+bool is_daemon = false;
 int debug_L, debug_W, debug_N;
-int ifindex = 0;
-char *ifname = NULL;
+const char *hostname = NULL, *hostaliases = NULL, *netbiosname = NULL, *netbiosaliases = NULL, *workgroup = NULL;
+
+static char *ifname = NULL;
+static unsigned ifindex = 0;
+static struct ifaddrs *ifaddrs_list = NULL;
 
 static int netlink_recv(struct endpoint *ep);
 
@@ -110,83 +147,75 @@ static struct service services[] = {
 		.exit	= llmnr_exit,
 	},
 	{
-		.name	= "ifaddr-netlink-v4v6",
+		.name	= "netlink-v4v6",
 		.family	= AF_NETLINK,
 		.type	= SOCK_RAW,
 		.protocol	= NETLINK_ROUTE,
-		.nl_groups	= RTMGRP_LINK |
-					RTMGRP_IPV4_IFADDR |
-					RTMGRP_IPV6_IFADDR,
+		.nl_groups	= RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV6_IFADDR,
 		.recv	= netlink_recv,
 	},
 };
 
+/*
+ * Find the interface address *ci which corresponds to received message sender address *sa
+ * in order to reply with the "right" IP address.
+ */
+
 int connected_if(const _saddr_t *sa, _saddr_t *ci)
 {
-	struct ifaddrs *ifaddr, *ifa;
 	int rv = -1;
 
-	if (getifaddrs(&ifaddr))
-		return -1;
-
-	ci->ss.ss_family = sa->ss.ss_family;
-
-	for (ifa = ifaddr; ifa; ifa = ifa->ifa_next) {
+	for (struct ifaddrs *ifa = ifaddrs_list; ifa; ifa = ifa->ifa_next) {
 		const uint8_t *_if, *_nm, *_sa;
 		uint8_t *_ca;
 		size_t alen;
 
-		if (!ifa->ifa_addr || sa->ss.ss_family != ifa->ifa_addr->sa_family)
+		if (ifa->ifa_flags & IFF_SLAVE || !ifa->ifa_netmask ||
+			!ifa->ifa_addr || ifa->ifa_addr->sa_family != sa->sa.sa_family)
 			continue;
 
-		if (debug_W >= 5) {
-			char name[_ADDRSTRLEN];
+		if (ifindex && if_nametoindex(ifa->ifa_name) != ifindex)
+			continue;
 
-			if (inet_ntop(ifa->ifa_addr->sa_family,
-					_SIN_ADDR((_saddr_t *)ifa->ifa_addr),
-					name, sizeof name))
-				printf("%s: %s: if=%s ",
-					__func__, ifa->ifa_name,name);
-			if (inet_ntop(sa->ss.ss_family,
-					_SIN_ADDR(sa), name, sizeof name))
-				printf("sc=%s ", name);
-			if (inet_ntop(ifa->ifa_netmask->sa_family,
-					_SIN_ADDR((_saddr_t *)ifa->ifa_netmask),
-					name, sizeof name))
-				printf("nm=%s\n", name);
+		if (debug_W >= 4) {
+			char ifa_addr[_ADDRSTRLEN], ifa_netmask[_ADDRSTRLEN], sa_addr[_ADDRSTRLEN];
+			if (!inet_ntop(ifa->ifa_addr->sa_family, _SIN_ADDR((_saddr_t *)ifa->ifa_addr), ifa_addr, sizeof(ifa_addr)))
+				ifa_addr[0] = '\0';
+			if (!inet_ntop(sa->sa.sa_family, _SIN_ADDR(sa), ifa_netmask, sizeof(ifa_netmask)))
+				ifa_netmask[0] = '\0';
+			if (!inet_ntop(ifa->ifa_netmask->sa_family, _SIN_ADDR((_saddr_t *)ifa->ifa_netmask), sa_addr, sizeof(sa_addr)))
+				sa_addr[0] = '\0';
+			DEBUG(4, W, "%s: %s: if=%s nm=%s sc=%s", __func__, ifa->ifa_name, ifa_addr, ifa_netmask, sa_addr);
 		}
 
 		switch (sa->ss.ss_family) {
 		case AF_INET:
-			_if = (uint8_t *)
-				&((_saddr_t *)ifa->ifa_addr)->in.sin_addr;
-			_nm = (uint8_t *)
-				&((_saddr_t *)ifa->ifa_netmask)->in.sin_addr;
-			_sa = (uint8_t *)&sa->in.sin_addr;
-			_ca = (uint8_t *)&ci->in.sin_addr;
-			alen = sizeof sa->in.sin_addr;
+			_if = (uint8_t *) &((_saddr_t *)ifa->ifa_addr)->in.sin_addr;
+			_nm = (uint8_t *) &((_saddr_t *)ifa->ifa_netmask)->in.sin_addr;
+			_sa = (uint8_t *) &sa->in.sin_addr;
+			_ca = (uint8_t *) &ci->in.sin_addr;
+			alen = sizeof(sa->in.sin_addr);
 			break;
 		case AF_INET6:
-			_if = (uint8_t *)
-				&((_saddr_t *)ifa->ifa_addr)->in6.sin6_addr;
-			_nm = (uint8_t *)
-				&((_saddr_t *)ifa->ifa_netmask)->in6.sin6_addr;
-			_sa = (uint8_t *)&sa->in6.sin6_addr;
-			_ca = (uint8_t *)&ci->in6.sin6_addr;
-			alen = sizeof sa->in6.sin6_addr;
+			_if = (uint8_t *) &((_saddr_t *)ifa->ifa_addr)->in6.sin6_addr;
+			_nm = (uint8_t *) &((_saddr_t *)ifa->ifa_netmask)->in6.sin6_addr;
+			_sa = (uint8_t *) &sa->in6.sin6_addr;
+			_ca = (uint8_t *) &ci->in6.sin6_addr;
+			alen = sizeof(sa->in6.sin6_addr);
 			break;
 		default:
 			continue;
 		}
 
 		rv = 0;
-		int i;
-		for (i = 0; i < alen; i++)
+		for (size_t i = 0; i < alen; i++) {
 			if ((_if[i] & _nm[i]) != (_sa[i] & _nm[i])) {
 				rv = -1;
 				break;
 			}
+		}
 		if (!rv) {
+			ci->ss.ss_family = sa->ss.ss_family;
 			memcpy(_ca, _if, alen);
 			break;
 		}
@@ -194,14 +223,11 @@ int connected_if(const _saddr_t *sa, _sa
 
 	if (debug_W >= 4) {
 		char name[_ADDRSTRLEN];
-
-		if (inet_ntop(ci->ss.ss_family, _SIN_ADDR(ci),
-				name, sizeof name))
-			printf("%s: ci=%s\n\n", __func__, name);
+		if (inet_ntop(ci->ss.ss_family, _SIN_ADDR(ci), name, sizeof(name)))
+			DEBUG(4, W, "%s: ci=%s rv=%d", __func__, name, rv);
 	}
 
-	freeifaddrs(ifaddr);
-	errno = EADDRNOTAVAIL;
+	if (rv) errno = ENONET;
 	return rv;
 }
 
@@ -216,8 +242,7 @@ char *ip2uri(const char *ip)
 	asprintf(&uri, "[%s]", ip);
 #else
 	char name[HOST_NAME_MAX + 1];
-
-	if (!gethostname(name, sizeof name - 1))
+	if (!gethostname(name, sizeof(name) - 1))
 		uri = strdup(name);
 #endif
 	return uri;
@@ -230,69 +255,73 @@ static const struct sock_params {
 	const char *name;
 	int ipproto_ip;
 	int ip_multicast_loop;
-	int ip_add_membership, ip_drop_membership;
+	int ip_add_membership;
+	int ip_drop_membership;
+	int ip_pktinfo;
 	size_t llen, mlen, mreqlen;
 } sock_params[] = {
 	[AF_INET] = {
-		.family	= AF_INET,
-		.name	= "IPv4",
-		.ipproto_ip	= IPPROTO_IP,
+		.family			= AF_INET,
+		.name			= "IPv4",
+		.ipproto_ip		= IPPROTO_IP,
 		.ip_multicast_loop	= IP_MULTICAST_LOOP,
 		.ip_add_membership	= IP_ADD_MEMBERSHIP,
 		.ip_drop_membership	= IP_DROP_MEMBERSHIP,
-		.llen		= sizeof(struct sockaddr_in),
-		.mlen		= sizeof(struct sockaddr_in),
-		.mreqlen	= sizeof endpoints[0].mreq.ip_mreq,
+		.ip_pktinfo		= IP_PKTINFO,
+		.llen			= sizeof(struct sockaddr_in),
+		.mlen			= sizeof(struct sockaddr_in),
+		.mreqlen		= sizeof(endpoints[0].mreq.ip_mreq),
 	},
 	[AF_INET6] = {
-		.family	= AF_INET6,
-		.name	= "IPv6",
-		.ipproto_ip	= IPPROTO_IPV6,
+		.family			= AF_INET6,
+		.name			= "IPv6",
+		.ipproto_ip		= IPPROTO_IPV6,
 		.ip_multicast_loop	= IPV6_MULTICAST_LOOP,
 		.ip_add_membership	= IPV6_ADD_MEMBERSHIP,
 		.ip_drop_membership	= IPV6_DROP_MEMBERSHIP,
-		.llen		= sizeof(struct sockaddr_in6),
-		.mlen		= sizeof(struct sockaddr_in6),
-		.mreqlen	= sizeof endpoints[0].mreq.ipv6_mreq,
+		.ip_pktinfo		= IPV6_RECVPKTINFO,
+		.llen			= sizeof(struct sockaddr_in6),
+		.mlen			= sizeof(struct sockaddr_in6),
+		.mreqlen		= sizeof(endpoints[0].mreq.ipv6_mreq),
 	},
 	[AF_NETLINK] = {
-		.family	= AF_NETLINK,
-		.name	= "NETLINK",
-		.llen		= sizeof(struct sockaddr_nl),
+		.family			= AF_NETLINK,
+		.name			= "NETLINK",
+		.llen			= sizeof(struct sockaddr_nl),
 	},
 };
 
-static int open_ep(struct endpoint **epp, struct service *sv,
-			const struct ifaddrs *ifa)
+static const char *const socktype_str[] = {
+	[SOCK_STREAM]    = "tcp",
+	[SOCK_DGRAM]     = "udp",
+	[SOCK_SEQPACKET] = "seq",
+};
+
+static int open_ep(struct endpoint **epp, struct service *sv, const struct ifaddrs *ifa)
 {
 #define __FUNCTION__	"open_ep"
-	struct endpoint *ep = calloc(sizeof *ep, 1);
+	const unsigned int disable = 0, enable = 1;
 
-	if (!(*epp = ep)) {
+	struct endpoint *ep = (struct endpoint *) calloc(sizeof(*ep), 1);
+	if ((*epp = ep) == NULL) {
 		errno = ENOMEM;
-		err(EXIT_FAILURE, __FUNCTION__ ": malloc");
+		err(EXIT_FAILURE, __FUNCTION__ ": calloc");
 	}
 
-	strncpy(ep->ifname, ifa->ifa_name, sizeof(ep->ifname)-1);
-	ep->service	= sv;
-	ep->family	= sv->family;
-	ep->type	= sv->type;
-	ep->protocol	= sv->protocol;
+	strncpy(ep->ifname, ifa->ifa_name, sizeof(ep->ifname));
+	ep->service = sv;
+	ep->family = sv->family;
+	ep->type = sv->type;
+	ep->protocol = sv->protocol;
 
-	if (sv->family >= ARRAY_SIZE(sock_params) ||
-		!sock_params[ep->family].name) {
+	if (sv->family >= (int) ARRAY_SIZE(sock_params) || !sock_params[ep->family].name) {
 		ep->errstr = __FUNCTION__ ": Unsupported address family";
 		ep->_errno = EINVAL;
 		return -1;
 	}
 
 	if (sv->family == AF_INET || sv->family == AF_INET6) {
-		const char *servicename[] = {
-			[SOCK_STREAM]	= "tcp",
-			[SOCK_DGRAM]	= "udp",
-		};
-		struct servent *se = getservbyname(sv->port_name,
-						servicename[sv->type]);
+		struct servent *se = getservbyname(sv->port_name, socktype_str[sv->type]);
 		ep->port = se ? ntohs(se->s_port) : 0;
 		if (!ep->port)
 			ep->port = sv->port_num;
@@ -305,97 +334,88 @@ static int open_ep(struct endpoint **epp
 
 	const struct sock_params *sp = &sock_params[ep->family];
 
-	ep->mcast.ss.ss_family	= ep->family;
-	ep->mlen	= sp->llen;
+	ep->mcast.ss.ss_family = ep->family;
+	ep->mlen = sp->mlen;
 
 	ep->local.ss.ss_family = ep->family;
-	ep->llen	= sp->llen;
+	ep->llen = sp->llen;
 
-	ep->mreqlen	= sp->mreqlen;
+	ep->mreqlen = sp->mreqlen;
 
 	switch (ep->family) {
 	case AF_INET:
 		if (sv->mcast_addr) {
-			ep->mcast.in.sin_port	= htons(ep->port);
-			if (inet_pton(ep->family, sv->mcast_addr,
-				&ep->mcast.in.sin_addr.s_addr) != 1) {
+			ep->mcast.in.sin_port = htons(ep->port);
+			if (inet_pton(ep->family, sv->mcast_addr, &ep->mcast.in.sin_addr.s_addr) != 1) {
 				ep->errstr = __FUNCTION__ ": Bad mcast IP addr";
 				ep->_errno = errno;
 				return -1;
 			}
 			ep->mreq.ip_mreq.imr_multiaddr = ep->mcast.in.sin_addr;
-#if 0
-			ep->mreq.ip_mreq.imr_address	=
-				((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
-			ep->mreq.ip_mreq.imr_ifindex =
-				if_nametoindex(ep->ifname);
+#ifdef USE_ip_mreq
+			ep->mreq.ip_mreq.imr_interface = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
 #else
-			ep->mreq.ip_mreq.imr_interface =
-				((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
+			ep->mreq.ip_mreq.imr_address = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
+			ep->mreq.ip_mreq.imr_ifindex = if_nametoindex(ep->ifname);
 #endif
 		}
-
 		//ep->local.saddr_in = *(struct sockaddr_in *)ifa->ifa_addr;
 		ep->local.in.sin_addr.s_addr = htonl(INADDR_ANY);
 		ep->local.in.sin_port = htons(ep->port);
 		break;
+
 	case AF_INET6:
 		if (sv->mcast_addr) {
 			ep->mcast.in6.sin6_port = htons(ep->port);
-			if (inet_pton(ep->family, sv->mcast_addr,
-				ep->mcast.in6.sin6_addr.s6_addr) != 1) {
-				ep->errstr =
-					__FUNCTION__ ": Bad mcast IPv6 addr";
+			if (inet_pton(ep->family, sv->mcast_addr, ep->mcast.in6.sin6_addr.s6_addr) != 1) {
+				ep->errstr = __FUNCTION__ ": Bad mcast IPv6 addr";
 				ep->_errno = errno;
 				return -1;
 			}
-			ep->mreq.ipv6_mreq.ipv6mr_multiaddr =
-						ep->mcast.in6.sin6_addr;
-			ep->mreq.ipv6_mreq.ipv6mr_interface =
-						if_nametoindex(ep->ifname);
+			ep->mreq.ipv6_mreq.ipv6mr_multiaddr = ep->mcast.in6.sin6_addr;
+			ep->mreq.ipv6_mreq.ipv6mr_interface = if_nametoindex(ep->ifname);
 		}
-
 		//ep->local.in6 = *(struct sockaddr_in6 *)ifa->ifa_addr;
 		ep->local.in6.sin6_addr = in6addr_any;
 		ep->local.in6.sin6_port = htons(ep->port);
 		break;
+
 	case AF_NETLINK:
+		ep->local.nl.nl_pid = getpid();
 		ep->local.nl.nl_groups = ep->service->nl_groups;
 		break;
 	}
 
-	ep->sock = socket(ep->family, ep->type, ep->protocol);
+	ep->sock = socket(ep->family, ep->type | SOCK_CLOEXEC, ep->protocol);
 	if (ep->sock < 0) {
 		ep->errstr = __FUNCTION__ ": Can't open socket";
 		ep->_errno = errno;
 		return -1;
 	}
 
-	const unsigned int enable = 1;
-	setsockopt(ep->sock, SOL_SOCKET, SO_REUSEADDR,
-				&enable, sizeof enable);
+	setsockopt(ep->sock, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof enable);
 #ifdef SO_REUSEPORT
-	setsockopt(ep->sock, SOL_SOCKET, SO_REUSEPORT,
-				&enable, sizeof enable);
+	setsockopt(ep->sock, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof enable);
+#endif
+#ifdef SO_RCVBUFFORCE
+	int rcvbuf = 128 * 1024;
+	if ((ep->family == AF_NETLINK) &&
+		setsockopt(ep->sock, SOL_SOCKET, SO_RCVBUFFORCE, &rcvbuf, sizeof rcvbuf)) {
+		LOG(LOG_WARNING, "%s: SO_RCVBUFFORCE: %s", __FUNCTION__, strerror(errno));
+	}
 #endif
 #ifdef IPV6_V6ONLY
 	if ((ep->family == AF_INET6) &&
-		setsockopt(ep->sock, sp->ipproto_ip, IPV6_V6ONLY,
-				&enable, sizeof enable)) {
+		setsockopt(ep->sock, sp->ipproto_ip, IPV6_V6ONLY, &enable, sizeof enable)) {
 		ep->errstr = __FUNCTION__ ": IPV6_V6ONLY";
 		ep->_errno = errno;
 		close(ep->sock);
 		return -1;
 	}
 #endif
-
 #ifdef SO_BINDTODEVICE
-	if (!sv->mcast_addr &&
-			(ep->family == AF_INET || ep->family == AF_INET6)) {
-		struct ifreq ifr;
-		strncpy(ifr.ifr_name, ep->ifname, IFNAMSIZ-1);
-		if (setsockopt(ep->sock, SOL_SOCKET, SO_BINDTODEVICE,
-				&ifr, sizeof(ifr))) {
+	if (!sv->mcast_addr && (ep->family == AF_INET || ep->family == AF_INET6)) {
+		if (setsockopt(ep->sock, SOL_SOCKET, SO_BINDTODEVICE, ep->ifname, strlen(ep->ifname))) {
 			ep->errstr = __FUNCTION__ ": SO_BINDTODEVICE";
 			ep->_errno = errno;
 			close(ep->sock);
@@ -409,34 +429,48 @@ static int open_ep(struct endpoint **epp
 		ep->_errno = errno;
 		close(ep->sock);
 		ep->sock = -1;
-		DEBUG(0, W, "%s: %s: %s",
-			ep->service->name, ep->errstr, strerror(ep->_errno));
+		DEBUG(0, W, "%s: %s: %s", ep->service->name, ep->errstr, strerror(ep->_errno));
 		return (ep->_errno == EADDRINUSE) ? 0 : -1;
 	}
 
-	if (sv->mcast_addr) {
-		const unsigned int disable = 0, enable = 1;
+	if (ep->type == SOCK_DGRAM &&
+		setsockopt(ep->sock, sp->ipproto_ip, sp->ip_pktinfo, &enable, sizeof(enable))) {
+		ep->errstr = __FUNCTION__ ": PKTINFO";
+		ep->_errno = errno;
+		close(ep->sock);
+		return -1;
+	}
 
-		if ((ep->family == AF_INET) &&
-			setsockopt(ep->sock, sp->ipproto_ip, IP_PKTINFO,
-					&enable, sizeof enable)) {
-			ep->errstr = __FUNCTION__ ": IP_PKTINFO";
+	if (sv->mcast_addr) {
+#ifdef IP_MULTICAST_IF
+		/* Set multicast sending interface to avoid error: wsdd-mcast-v4: wsd_send_soap_msg: send: No route to host */
+		if (ep->family == AF_INET && ep->type == SOCK_DGRAM &&
+			setsockopt(ep->sock, sp->ipproto_ip, IP_MULTICAST_IF, &ep->mreq, ep->mreqlen)) {
+			ep->errstr = __FUNCTION__ ": IP_MULTICAST_IF";
 			ep->_errno = errno;
 			close(ep->sock);
 			return -1;
 		}
+#endif
+#ifdef IPV6_MULTICAST_IF
+		/* Set multicast sending interface for IPv6 */
+		if (ep->family == AF_INET6 && ep->type == SOCK_DGRAM &&
+			setsockopt(ep->sock, sp->ipproto_ip, IPV6_MULTICAST_IF, &ep->mreq.ipv6_mreq.ipv6mr_interface, sizeof(ep->mreq.ipv6_mreq.ipv6mr_interface))) {
+			ep->errstr = __FUNCTION__ ": IPV6_MULTICAST_IF";
+			ep->_errno = errno;
+			close(ep->sock);
+			return -1;
+		}
+#endif
 		/* Disable loopback. */
-		if (setsockopt(ep->sock, sp->ipproto_ip, sp->ip_multicast_loop,
-				&disable, sizeof disable)) {
+		if (setsockopt(ep->sock, sp->ipproto_ip, sp->ip_multicast_loop, &disable, sizeof(disable))) {
 			ep->errstr = __FUNCTION__ ": IP_MULTICAST_LOOP";
 			ep->_errno = errno;
 			close(ep->sock);
 			return -1;
 		}
-
 		/* Set inbound multicast. */
-		if (setsockopt(ep->sock, sp->ipproto_ip, sp->ip_add_membership,
-				&ep->mreq, ep->mreqlen)) {
+		if (setsockopt(ep->sock, sp->ipproto_ip, sp->ip_add_membership, &ep->mreq, ep->mreqlen)) {
 			ep->errstr = __FUNCTION__ ": IP_ADD_MEMBERSHIP";
 			ep->_errno = errno;
 			close(ep->sock);
@@ -451,10 +485,6 @@ static int open_ep(struct endpoint **epp
 		return -1;
 	}
 
-	if (ep->service->init && ep->service->init(ep)) {
-		close(ep->sock);
-		return -1;
-	}
 	return 0;
 #undef __FUNCTION__
 }
@@ -463,19 +493,12 @@ static void close_ep(struct endpoint *ep
 {
 	if (ep->service->exit)
 		ep->service->exit(ep);
-	if (ep->service->mcast_addr) {
-		setsockopt(ep->sock,
-				sock_params[ep->family].ipproto_ip,
-				sock_params[ep->family].ip_drop_membership,
-				&ep->mreq, ep->mreqlen);
-	}
+	if (ep->service->mcast_addr)
+		setsockopt(ep->sock, sock_params[ep->family].ipproto_ip,
+			sock_params[ep->family].ip_drop_membership, &ep->mreq, ep->mreqlen);
 	close(ep->sock);
 }
 
-#include <setjmp.h>
-#include <signal.h>
-#include <stdarg.h>
-
 static jmp_buf sigenv;
 volatile sig_atomic_t restart;
 
@@ -488,7 +511,7 @@ void restart_service(void)
 
 static bool is_new_addr(struct nlmsghdr *nh)
 {
-	struct ifaddrmsg *ifam = (struct ifaddrmsg *)NLMSG_DATA(nh);
+	struct ifaddrmsg *ifam = (struct ifaddrmsg *) NLMSG_DATA(nh);
 	struct rtattr *rta = IFA_RTA(ifam);
 	size_t rtasize = IFA_PAYLOAD(nh);
 
@@ -503,9 +526,8 @@ static bool is_new_addr(struct nlmsghdr
 	}
 
 	while (RTA_OK(rta, rtasize)) {
-		struct ifa_cacheinfo *cache_info;
 		if (rta->rta_type == IFA_CACHEINFO) {
-			cache_info = (struct ifa_cacheinfo *)(RTA_DATA(rta));
+			struct ifa_cacheinfo *cache_info = (struct ifa_cacheinfo *) RTA_DATA(rta);
 			if (cache_info->cstamp != cache_info->tstamp)
 				return false;
 		}
@@ -518,10 +540,9 @@ static bool is_new_addr(struct nlmsghdr
 static int netlink_recv(struct endpoint *ep)
 {
 #define __FUNCTION__	"netlink_recv"
-	char buf[4096];
-	struct iovec iov = { buf, sizeof buf };
+	char buf[PAGE_SIZE];
 	struct sockaddr_nl sa;
-	struct nlmsghdr *nh;
+	struct iovec iov = { buf, sizeof buf };
 	struct msghdr msg = { &sa, sizeof sa, &iov, 1, NULL, 0, 0 };
 	ssize_t msglen = recvmsg(ep->sock, &msg, 0);
 
@@ -531,14 +552,14 @@ static int netlink_recv(struct endpoint
 		ep->errstr = __FUNCTION__ ": netlink_recv: recv";
 		return -1;
 	}
-
-
-	for (nh = (struct nlmsghdr *)buf;
+#ifdef NL_DEBUG
+	nl_debug(buf, msglen);
+#endif
+	for (struct nlmsghdr *nh = (struct nlmsghdr *) buf;
 			NLMSG_OK(nh, msglen) && nh->nlmsg_type != NLMSG_DONE;
 			nh = NLMSG_NEXT(nh, msglen)) {
 		if (is_new_addr(nh) || nh->nlmsg_type == RTM_DELADDR) {
-			DEBUG(1, W,
-		"I/F address addition/change/deletion detected.");
+			DEBUG(1, W, __FUNCTION__ ": address addition/change/deletion detected.");
 			restart_service();
 			break;
 		}
@@ -550,7 +571,7 @@ static int netlink_recv(struct endpoint
 
 static void sighandler(int sig)
 {
-	DEBUG(0, W, "%s received.", strsignal(sig));
+	DEBUG(0, W, "'%s' signal received.", strsignal(sig));
 	switch (sig) {
 	case SIGHUP:
 		restart = 1;
@@ -560,36 +581,103 @@ static void sighandler(int sig)
 	}
 }
 
+static char *get_smbparm(const char *name, const char *_default)
+{
+#define __FUNCTION__	"get_smbparm"
+	char *cmd = NULL, *result = NULL;
+
+	if (asprintf(&cmd, "testparm -s --parameter-name=\"%s\" 2>/dev/null", name) <= 0) {
+		DEBUG(0, W, __FUNCTION__ ": can't allocate cmd string");
+		return NULL;
+	}
+
+	FILE *pp = popen(cmd, "r");
+	free(cmd);
+
+	if (!pp) {
+		DEBUG(0, W, __FUNCTION__ ": can't run testparam");
+		return strdup(_default);
+	}
+
+	char buf[PAGE_SIZE];
+	if (!fgets(buf, sizeof(buf), pp) || !buf[0]  || buf[0] == '\n') {
+		DEBUG(0, W, "cannot read %s from testparm", name);
+		result = strdup(_default);
+	} else { // trim whitespace
+		char *p;
+		for (p = buf + strlen(buf) - 1; buf < p && isspace(*p); p--)
+			*p = '\0';
+		for (p = buf; *p && isspace(*p); p++)
+			;
+		result = strdup(p);
+	}
+
+	pclose(pp);
+	return result;
+#undef __FUNCTION__
+}
+
 static void help(const char *prog, int ec, const char *fmt, ...)
 {
 	if (fmt) {
 		va_list ap;
-
 		va_start(ap, fmt);
 		vprintf(fmt, ap);
 		va_end(ap);
+		puts("\n");
 	}
 	printf( "WSDD and LLMNR daemon\n"
-		"Usage: %s [opts]\n"
-		"       -4  IPv4 only\n"
-		"       -6  IPv6 only\n"
-		"       -L  LLMNR debug mode (incremental level)\n"
-		"       -W  WSDD debug mode (incremental level)\n"
-		"       -d  go daemon\n"
-		"       -h  This message\n"
-		"       -l  LLMNR only\n"
-		"       -t  TCP only\n"
-		"       -u  UDP only\n"
-		"       -w  WSDD only\n"
-		"       -i \"interface\"  Listening interface (optional)\n"
-		"       -N  set NetbiosName manually\n"
-		"       -G  set Workgroup manually\n"
-		"       -b \"key1:val1,key2:val2,...\"  Boot parameters\n",
-			prog);
+		"Usage: %s [options]\n"
+		"       -h this message\n"
+		"       -d become daemon\n"
+		"       -4 IPv4 only\n"
+		"       -6 IPv6 only\n"
+		"       -u UDP only\n"
+		"       -t TCP only\n"
+		"       -l LLMNR only\n"
+		"       -w WSDD only\n"
+		"       -L increment LLMNR debug level (%d)\n"
+		"       -W increment WSDD debug level (%d)\n"
+		"       -i <interface> reply only on this interface (%s)\n"
+		"       -H <name> set host name (%s)\n"
+		"       -A \"name list\" set host aliases (%s)\n"
+		"       -N <name> set netbios name (%s)\n"
+		"       -B \"name list\" set netbios aliases (%s)\n"
+		"       -G <name> set workgroup (%s)\n"
+		"       -b \"key1:val1,key2:val2,...\" boot parameters:\n",
+		prog, debug_L, debug_W, ifname ? ifname : "any",
+		hostname, hostaliases, netbiosname, netbiosaliases, workgroup
+	);
 	printBootInfoKeys(stdout, 11);
 	exit(ec);
 }
 
+static void init_sysinfo()
+{
+	char hostn[HOST_NAME_MAX + 1];
+
+	if (!hostname && gethostname(hostn, sizeof(hostn) - 1) != 0)
+		err(EXIT_FAILURE, "gethostname");
+
+	char *p = strchr(hostn, '.');
+	if (p) *p = '\0';
+	hostname = strdup(hostn);
+
+	if (!hostaliases && !(hostaliases = get_smbparm("additional dns hostnames", "")))
+		err(EXIT_FAILURE, "get_smbparm");
+
+	if (!netbiosname && !(netbiosname = get_smbparm("netbios name", hostname)))
+		err(EXIT_FAILURE, "get_smbparm");
+
+	if (!netbiosaliases && !(netbiosaliases = get_smbparm("netbios aliases", "")))
+		err(EXIT_FAILURE, "get_smbparm");
+
+	if (!workgroup && !(workgroup = get_smbparm("workgroup", "WORKGROUP")))
+		err(EXIT_FAILURE, "get_smbparm");
+
+	init_getresp();
+}
+
 #define	_4	1
 #define	_6	2
 #define _TCP	1
@@ -599,36 +687,31 @@ static void help(const char *prog, int e
 
 int main(int argc, char **argv)
 {
-	bool daemon = false;
 	int opt;
-	const char *prog = basename(*argv);
+	const char *prog = basename(argv[0]);
 	unsigned int ipv46 = 0, tcpudp = 0, llmnrwsdd = 0;
 
-	while ((opt = getopt(argc, argv, "?46LWb:dhltuwi:N:G:")) != -1) {
+	init_sysinfo();
+
+	while ((opt = getopt(argc, argv, "hd46utlwLWi:H:N:G:b:")) != -1) {
 		switch (opt) {
-		case 'L':
-			debug_L++;
-			break;
-		case 'W':
-			debug_W++;
-			break;
-		case 'b':
-			while (optarg)
-				if (set_getresp(optarg, (const char **)&optarg))
-					help(prog, EXIT_FAILURE,
-						"bad key:val '%s'\n", optarg);
-			break;
-		case 'd':
-			daemon = true;
-			break;
 		case 'h':
 			help(prog, EXIT_SUCCESS, NULL);
 			break;
+		case 'd':
+			is_daemon = true;
+			break;
 		case '4':
-			ipv46	|= _4;
+			ipv46 |= _4;
 			break;
 		case '6':
-			ipv46	|= _6;
+			ipv46 |= _6;
+			break;
+		case 'u':
+			tcpudp |= _UDP;
+			break;
+		case 't':
+			tcpudp |= _TCP;
 			break;
 		case 'l':
 			llmnrwsdd |= _LLMNR;
@@ -636,60 +719,89 @@ int main(int argc, char **argv)
 		case 'w':
 			llmnrwsdd |= _WSDD;
 			break;
-		case 't':
-			tcpudp	|= _TCP;
+		case 'L':
+			debug_L++;
 			break;
-		case 'u':
-			tcpudp	|= _UDP;
+		case 'W':
+			debug_W++;
 			break;
 		case 'i':
-			if (optarg != NULL && strlen(optarg) > 1) {
-				ifindex = if_nametoindex(optarg);
-				if (ifindex == 0)
-					help(prog, EXIT_FAILURE, "bad interface '%s'\n", optarg);
+			if (optarg && strlen(optarg) && strcmp(optarg, "any") != 0) {
 				ifname = strdup(optarg);
+				ifindex = ifname ? if_nametoindex(ifname) : 0;
+				if (!ifindex) help(prog, EXIT_FAILURE, "Bad interface '%s'", ifname);
+			} else {
+				free(ifname);
+				ifname = NULL;
+				ifindex = 0;
 			}
 			break;
+		case 'H':
+			if (optarg != NULL && strlen(optarg) > 0)
+				hostname = strdup(optarg);
+			break;
 		case 'N':
-			if (optarg != NULL && strlen(optarg) > 1) {
+			if (optarg != NULL && strlen(optarg) > 0)
 				netbiosname = strdup(optarg);
-			}
 			break;
 		case 'G':
-			if (optarg != NULL && strlen(optarg) > 1) {
+			if (optarg != NULL && strlen(optarg) > 0)
 				workgroup = strdup(optarg);
-			}
+			break;
+		case 'b':
+			while (optarg)
+				if (set_getresp(optarg, (const char **)&optarg) != 0)
+					help(prog, EXIT_FAILURE, "Bad key:val '%s'", optarg);
 			break;
 		case '?':
-			if (optopt == 'b' || optopt == 'i' || optopt == 'N' || optopt == 'G')
-				fprintf (stderr, "Option -%c requires an argument.\n", optopt);
+			if (strchr("iHNGb", optopt))
+				printf("Option -%c requires an argument.\n", optopt);
+			/* ... fall through ... */
 		default:
-			help(prog, EXIT_FAILURE, "bad option '%c'\n", opt);
+			help(prog, EXIT_FAILURE, "Bad option '%c'", opt);
 		}
 	}
 
+	if (argc > optind)
+		help(prog, EXIT_FAILURE, "Unknown argument '%s'", argv[optind]);
+
 	if (!ipv46)
-		ipv46	= _4 | _6;
+		ipv46 = _4 | _6;
 	if (!llmnrwsdd)
 		llmnrwsdd = _LLMNR | _WSDD;
 	if (!tcpudp)
-		tcpudp	= _TCP | _UDP;
+		tcpudp = _TCP | _UDP;
 
-	if (daemon) {
+	if (is_daemon) {
 		pid_t pid = fork();
 
 		if (pid < 0)
 			err(EXIT_FAILURE, "fork");
 		if (pid)
 			exit(EXIT_SUCCESS);
+
+                chdir("/");
+
+                int fd;
+                if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
+                        dup2(fd, STDIN_FILENO);
+                        dup2(fd, STDOUT_FILENO);
+                        dup2(fd, STDERR_FILENO);
+                        if (fd > STDERR_FILENO) close(fd);
+                }
+
+		if (setsid() < 0)
+			exit(EXIT_FAILURE);
 	}
 
 	openlog(prog, LOG_PID, LOG_USER);
-	syslog(LOG_USER | LOG_INFO, "starting.");
+	LOG(LOG_INFO, "starting.");
 
 again:
-	{}	/* Necessary to satisfy C syntax for statement labeling. */
+	{} /* Necessary to satisfy C syntax for statement labeling. */
 	struct sigaction sigact, oldact;
+	DEBUG(1, W, "ifname %s, ifindex %d", ifname, ifindex);
+	DEBUG(1, W, "hostname %s, netbios name %s, workgroup %s", hostname, netbiosname, workgroup);
 
 	sigemptyset(&sigact.sa_mask);
 	sigact.sa_flags = 0;
@@ -701,17 +813,19 @@ again:
 		err(EXIT_FAILURE, "cannot install signal handler.");
 	}
 
-	struct ifaddrs *ifaddrs;
+	// Refresh ifaddrs list
+	if (ifaddrs_list != NULL)
+		freeifaddrs(ifaddrs_list);
+	if (getifaddrs(&ifaddrs_list) != 0)
+		err(EXIT_FAILURE, "getifaddrs()");
+
 	fd_set fds;
-	int svn, rv = 0, nfds = -1;
+	int rv = 0, nfds = -1;
 	struct endpoint *ep, *badep = NULL;
 
 	FD_ZERO(&fds);
 
-	if (getifaddrs(&ifaddrs))
-		err(EXIT_FAILURE, "ifaddrs");
-
-	for (svn = 0; svn < ARRAY_SIZE(services); svn++) {
+	for (size_t svn = 0; svn < ARRAY_SIZE(services); svn++) {
 		struct service *sv = &services[svn];
 
 		if (!(ipv46 & _4) && sv->family == AF_INET)
@@ -727,53 +841,77 @@ again:
 		if (!(llmnrwsdd & _WSDD) && strstr(sv->name, "wsdd"))
 			continue;
 
-		struct ifaddrs *ifa;
-
 		if (sv->family == AF_INET || sv->family == AF_INET6) {
-			for (ifa = ifaddrs; ifa; ifa = ifa->ifa_next) {
-				if (!ifa->ifa_addr ||
-					(ifa->ifa_addr->sa_family != sv->family) ||
-					(ifa->ifa_flags & IFF_LOOPBACK) ||
-					(ifa->ifa_flags & IFF_SLAVE) ||
-					(ifname && strcmp(ifa->ifa_name, ifname)) ||
-					(!strcmp(ifa->ifa_name, "LeafNets")) ||
-					(!strncmp(ifa->ifa_name, "docker", 6)) ||
-					(!strncmp(ifa->ifa_name, "veth", 4)) ||
-					(!strncmp(ifa->ifa_name, "tun", 3)) ||
-					(!strncmp(ifa->ifa_name, "zt", 2)) ||
-					(sv->mcast_addr &&
-					!(ifa->ifa_flags & IFF_MULTICAST)))
+			for (struct ifaddrs *ifa = ifaddrs_list; ifa; ifa = ifa->ifa_next) {
+				if (ifa->ifa_flags & IFF_SLAVE || !ifa->ifa_netmask ||
+					!ifa->ifa_addr || ifa->ifa_addr->sa_family != sv->family)
 					continue;
 
+				char ifaddr[_ADDRSTRLEN];
+				void *addr = _SIN_ADDR((_saddr_t *)ifa->ifa_addr);
+				inet_ntop(ifa->ifa_addr->sa_family, addr, ifaddr, sizeof(ifaddr));
+
+				if (ifname && strcmp(ifa->ifa_name, ifname) != 0) {
+					//DEBUG(2, W, "skipped %s: not selected", ifa->ifa_name);
+					ifa->ifa_flags |= IFF_SLAVE; // mark as not used
+					continue;
+				}
+
+				// skip if already bound to this interface
+				ep = NULL;
+				for (struct endpoint *e = endpoints; e; e = e->next)
+					if (e->service == sv && strcmp(e->ifname, ifa->ifa_name) == 0)
+						ep = e;
+
+				// show interface
+				DEBUG(1, W, "%s %s port %d %s %s @ %s%s", sv->name,
+					socktype_str[sv->type], sv->port_num,
+					sv->mcast_addr ? sv->mcast_addr : "-",
+					ifaddr, ifa->ifa_name, ep ? ": already bound" : "");
+				if (ep)
+					continue;
+
+				if (!ifname && sv->mcast_addr && !(ifa->ifa_flags & IFF_MULTICAST)) {
+					DEBUG(2, W, "skipped %s: not multicast", ifa->ifa_name);
+					ifa->ifa_flags |= IFF_SLAVE; // mark as not used
+					continue;
+				}
+				if (!ifname && (ifa->ifa_flags & IFF_LOOPBACK)) {
+					DEBUG(2, W, "skipped %s: loopback", ifa->ifa_name);
+					ifa->ifa_flags |= IFF_SLAVE; // mark as not used
+					continue;
+				}
+				if (!ifname && ((!strcmp(ifa->ifa_name, "LeafNets")) ||
+						(!strncmp(ifa->ifa_name, "docker", 6)) ||
+						(!strncmp(ifa->ifa_name, "veth", 4)) ||
+						(!strncmp(ifa->ifa_name, "tun", 3)) ||
+						(!strncmp(ifa->ifa_name, "ppp", 3)) ||
+						(!strncmp(ifa->ifa_name, "zt", 2)))) {
+					DEBUG(2, W, "skipped %s: excluded by name", ifa->ifa_name);
+					ifa->ifa_flags |= IFF_SLAVE; // mark as not used
+					continue;
+				}
+				// skip bridge ports unless it is specified on the command line
 				if (!ifname) {
-					char path[sizeof("/sys/class/net//brport")+IFNAMSIZ];
 					struct stat st;
+					char path[sizeof("/sys/class/net//brport") + IFNAMSIZ];
 					snprintf(path, sizeof(path), "/sys/class/net/%s/brport", ifa->ifa_name);
-					if (stat(path, &st) == 0)
+					if (stat(path, &st) == 0) {
+						DEBUG(2, W, "skipped %s: bridge port", ifa->ifa_name);
+						ifa->ifa_flags |= IFF_SLAVE; // mark as not used
 						continue;
+					}
 				}
-
-				char ifaddr[_ADDRSTRLEN];
-				void *addr =
-					_SIN_ADDR((_saddr_t *)ifa->ifa_addr);
-
-				inet_ntop(ifa->ifa_addr->sa_family, addr,
-						ifaddr, sizeof ifaddr);
-
-				DEBUG(2, W, "%s %s %s@%s",
-					sv->name,
-					sv->mcast_addr ? sv->mcast_addr : "",
-					ifa->ifa_name,
-					ifaddr);
-
-				if (open_ep(&ep, sv, ifa)) {
-					syslog(LOG_USER | LOG_ERR, "error: %s: %s: %s",
-						ep->service->name, ep->errstr, strerror(ep->_errno));
+				// open socket for this interface/family
+				if (open_ep(&ep, sv, ifa) != 0) {
+					LOG(LOG_ERR, "error: %s: %s: %s", ep->service->name,
+						ep->errstr, strerror(ep->_errno));
+					ifa->ifa_flags |= IFF_SLAVE; // mark as not used
 					free(ep);
 					continue;
-				} else if (ep->sock < 0)
+				} else if (ep->sock < 0) {
 					free(ep);
-				else {
+				} else {
 					ep->next = endpoints;
 					endpoints = ep;
 					FD_SET(ep->sock, &fds);
@@ -781,18 +919,18 @@ again:
 						nfds = ep->sock;
 				}
 			}
-			if (badep)
-				break;
+
 		} else if (sv->family == AF_NETLINK) {
-			const struct ifaddrs ifa = { .ifa_name = "netlink", };
+			struct ifaddrs ifa = {};
+			ifa.ifa_name = "netlink";
 
-			DEBUG(2, W, "%s @0x%x", sv->name, sv->nl_groups);
-			if (open_ep(&ep, sv, &ifa)) {
+			DEBUG(2, W, "%s 0x%x @ %s", sv->name, sv->nl_groups, ifa.ifa_name);
+			if (open_ep(&ep, sv, &ifa) != 0) {
 				badep = ep;
 				break;
-			} else if (ep->sock < 0)
+			} else if (ep->sock < 0) {
 				free(ep);
-			else {
+			} else {
 				ep->next = endpoints;
 				endpoints = ep;
 				FD_SET(ep->sock, &fds);
@@ -802,7 +940,15 @@ again:
 		}
 	}
 
-	freeifaddrs(ifaddrs);
+	if (!badep) {
+		for (struct endpoint *ep = endpoints; ep; ep = ep->next) {
+			if (ep->service->init && ep->service->init(ep)) {
+				DEBUG(1, W, "%s init failed: %s: %s", ep->service->name,
+						ep->errstr, strerror(ep->_errno));
+				//badep = ep;
+			}
+		}
+	}
 
 	if (!badep) {
 		int n = 0;
@@ -812,20 +958,17 @@ again:
 
 		do {
 			fd_set rfds = fds;
-
 			n = select(nfds + 1, &rfds, NULL, NULL, NULL);
-			DEBUG(3, W, "select: n=%d", n);
+			DEBUG(4, W, "select: n=%d", n);
 			for (ep = endpoints; n > 0 && ep; ep = ep->next) {
 				if (!FD_ISSET(ep->sock, &rfds))
 					continue;
-				DEBUG(3, W, "dispatch %s_recv",
-					ep->service->name);
+				DEBUG(3, W, "dispatch %s recv", ep->service->name);
 				n--;
 				if (ep->service->recv) {
 					int ret = ep->service->recv(ep);
 					if (ret < 0) {
-						DEBUG(1, W,
-					"Detected %s socket error, restarting",
+						DEBUG(1, W, "Detected %s socket error, restarting",
 							ep->service->name);
 						restart_service();
 					}
@@ -834,13 +977,13 @@ again:
 		} while (n >= 0 && !restart);
 
 		if (n < 0 && errno != EINTR) {
-			syslog(LOG_USER | LOG_WARNING, "%s: select: %s",
-				__func__, strerror(errno));
+			LOG(LOG_WARNING, "%s: select: %s", __func__, strerror(errno));
 			rv = EXIT_FAILURE;
 		}
 	}
+
 end:
-	{}
+	{} /* Necessary to satisfy C syntax for statement labeling. */
 	const char *badservice = NULL, *badbad = NULL;
 	int baderrno = 0;
 
@@ -852,15 +995,13 @@ end:
 
 	while (endpoints) {
 		struct endpoint *tempep = endpoints->next;
-
 		close_ep(endpoints);
 		free(endpoints);
 		endpoints = tempep;
 	}
 
 	if (badep) {
-		syslog(LOG_USER | LOG_ERR, "%s: %s: terminating.",
-			badservice, badbad);
+		LOG(LOG_ERR, "%s: %s: terminating.", badservice, badbad);
 		closelog();
 		errno = baderrno;
 		err(EXIT_FAILURE, "%s: %s", badservice, badbad);
@@ -871,7 +1012,12 @@ end:
 		goto again;
 	}
 
-	syslog(LOG_USER | LOG_INFO, "terminating.");
+	if (ifaddrs_list != NULL) {
+		freeifaddrs(ifaddrs_list);
+		ifaddrs_list = NULL;
+	}
+
+	LOG(LOG_INFO, "terminating.");
 	closelog();
 	return rv;
 }
diff -urpN wsdd2.old/wsdd2.service wsdd2/wsdd2.service
--- wsdd2.old/wsdd2.service	2021-02-18 14:59:20.992472515 +0700
+++ wsdd2/wsdd2.service	2021-11-29 14:22:49.857126999 +0700
@@ -7,7 +7,7 @@ ExecStart=/usr/sbin/wsdd2
 ExecReload=/bin/kill -HUP $MAINPID
 Restart=on-failure
 DynamicUser=true
-AmbientCapabilities=CAP_NET_RAW
+AmbientCapabilities=CAP_NET_RAW CAP_NET_ADMIN
 PrivateTmp=true
 PrivateDevices=true
 ProtectSystem=full
