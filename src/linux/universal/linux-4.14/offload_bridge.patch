Index: include/linux/if_bridge.h
===================================================================
--- include/linux/if_bridge.h	(revision 49056)
+++ include/linux/if_bridge.h	(working copy)
@@ -54,6 +54,7 @@ struct br_ip_list {
 #define BR_MRP_LOST_CONT	BIT(17)
 #define BR_MRP_LOST_IN_CONT	BIT(18)
 #define BR_BLOCK_BPDU		BIT(19)
+#define BR_OFFLOAD		BIT(20)
 
 #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
 
Index: net/bridge/Makefile
===================================================================
--- net/bridge/Makefile	(revision 49056)
+++ net/bridge/Makefile	(working copy)
@@ -5,7 +5,7 @@
 
 obj-$(CONFIG_BRIDGE) += bridge.o
 
-bridge-y	:= br.o br_device.o br_fdb.o br_forward.o br_if.o br_input.o \
+bridge-y	:= br.o br_device.o br_fdb.o br_forward.o br_if.o br_input.o br_offload.o \
 			br_ioctl.o br_stp.o br_stp_bpdu.o \
 			br_stp_if.o br_stp_timer.o br_netlink.o \
 			br_netlink_tunnel.o
Index: net/bridge/br.c
===================================================================
--- net/bridge/br.c	(revision 49056)
+++ net/bridge/br.c	(working copy)
@@ -22,6 +22,7 @@
 #include <net/switchdev.h>
 
 #include "br_private.h"
+#include "br_private_offload.h"
 
 /*
  * Handle changes in state of network devices enslaved to a bridge.
@@ -210,6 +211,10 @@ static int __init br_init(void)
 	if (err)
 		goto err_out;
 
+	err = br_offload_init();
+	if (err)
+		goto err_out0;
+
 	err = register_pernet_subsys(&br_net_ops);
 	if (err)
 		goto err_out1;
@@ -253,6 +258,8 @@ err_out3:
 err_out2:
 	unregister_pernet_subsys(&br_net_ops);
 err_out1:
+	br_offload_fini();
+err_out0:
 	br_fdb_fini();
 err_out:
 	stp_proto_unregister(&br_stp_proto);
@@ -274,6 +281,7 @@ static void __exit br_deinit(void)
 #if IS_ENABLED(CONFIG_ATM_LANE)
 	br_fdb_test_addr_hook = NULL;
 #endif
+	br_offload_fini();
 	br_fdb_fini();
 }
 
Index: net/bridge/br_device.c
===================================================================
--- net/bridge/br_device.c	(revision 49056)
+++ net/bridge/br_device.c	(working copy)
@@ -454,6 +454,8 @@ void br_dev_setup(struct net_device *dev)
 	br->bridge_hello_time = br->hello_time = 2 * HZ;
 	br->bridge_forward_delay = br->forward_delay = 15 * HZ;
 	br->bridge_ageing_time = br->ageing_time = BR_DEFAULT_AGEING_TIME;
+	br->offload_cache_size = 128;
+	br->offload_cache_reserved = 8;
 	dev->max_mtu = ETH_MAX_MTU;
 
 	br_netfilter_rtable_init(br);
Index: net/bridge/br_fdb.c
===================================================================
--- net/bridge/br_fdb.c	(revision 49056)
+++ net/bridge/br_fdb.c	(working copy)
@@ -27,6 +27,7 @@
 #include <net/switchdev.h>
 #include <trace/events/bridge.h>
 #include "br_private.h"
+#include "br_private_offload.h"
 
 static struct kmem_cache *br_fdb_cache __read_mostly;
 static int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
@@ -499,6 +500,8 @@ static struct net_bridge_fdb_entry *fdb_create(str
 		fdb->offloaded = 0;
 		fdb->updated = fdb->used = jiffies;
 		hlist_add_head_rcu(&fdb->hlist, head);
+		INIT_HLIST_HEAD(&fdb->offload_in);
+		INIT_HLIST_HEAD(&fdb->offload_out);
 	}
 	return fdb;
 }
@@ -684,6 +687,8 @@ static void fdb_notify(struct net_bridge *br,
 	struct sk_buff *skb;
 	int err = -ENOBUFS;
 
+	br_offload_fdb_update(fdb);
+
 	br_switchdev_fdb_notify(fdb, type);
 
 	skb = nlmsg_new(fdb_nlmsg_size(), GFP_ATOMIC);
Index: net/bridge/br_forward.c
===================================================================
--- net/bridge/br_forward.c	(revision 49056)
+++ net/bridge/br_forward.c	(working copy)
@@ -20,6 +20,7 @@
 #include <linux/if_vlan.h>
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
+#include "br_private_offload.h"
 #include <linux/inetdevice.h>
 #include <linux/if_arp.h>
 #include <net/arp.h>
@@ -38,6 +39,8 @@ static inline int should_deliver(const struct net_
 
 int br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)
 {
+	br_offload_output(skb);
+
 	skb_push(skb, ETH_HLEN);
 	if (!is_skb_forwardable(skb->dev, skb))
 		goto drop;
Index: net/bridge/br_if.c
===================================================================
--- net/bridge/br_if.c	(revision 49056)
+++ net/bridge/br_if.c	(working copy)
@@ -28,6 +28,7 @@
 #include <net/switchdev.h>
 
 #include "br_private.h"
+#include "br_private_offload.h"
 
 /*
  * Determine initial path cost based on speed.
@@ -364,7 +365,7 @@ static struct net_bridge_port *new_nbp(struct net_
 	p->path_cost = port_cost(dev);
 	p->priority = 0x8000 >> BR_PORT_BITS;
 	p->port_no = index;
-	p->flags = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;
+	p->flags = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD | BR_OFFLOAD;
 	br_init_port(p);
 	br_set_state(p, BR_STATE_DISABLED);
 	br_stp_port_timer_init(p);
@@ -672,6 +673,9 @@ void br_port_flags_change(struct net_bridge_port *
 
 	if (mask & BR_AUTO_MASK)
 		nbp_update_port_count(br);
+
+	if (mask & BR_OFFLOAD)
+		br_offload_port_state(p);
 }
 
 /* Update bridge statistics for bridge packets processed by offload engines */
Index: net/bridge/br_input.c
===================================================================
--- net/bridge/br_input.c	(revision 49056)
+++ net/bridge/br_input.c	(working copy)
@@ -22,6 +22,7 @@
 #include <linux/rculist.h>
 #include "br_private.h"
 #include "br_private_tunnel.h"
+#include "br_private_offload.h"
 
 /* Hook for brouter */
 br_should_route_hook_t __rcu *br_should_route_hook __read_mostly;
@@ -219,6 +220,7 @@ int br_handle_frame_finish(struct net *net, struct
 			dst->used = now;
 		br_forward(dst->dst, skb, local_rcv, false);
 	} else {
+		br_offload_skb_disable(skb);
 		if (!mcast_hit)
 			br_flood(br, skb, pkt_type, local_rcv, false);
 		else
@@ -295,6 +297,9 @@ rx_handler_result_t br_handle_frame(struct sk_buff
 		return RX_HANDLER_CONSUMED;
 
 	p = br_port_get_rcu(skb->dev);
+	if (br_offload_input(p, skb))
+		return RX_HANDLER_CONSUMED;
+
 	if (p->flags & BR_VLAN_TUNNEL) {
 		if (br_handle_ingress_vlan_tunnel(skb, p,
 						  nbp_vlan_group_rcu(p)))
Index: net/bridge/br_private.h
===================================================================
--- net/bridge/br_private.h	(revision 49056)
+++ net/bridge/br_private.h	(working copy)
@@ -184,7 +184,13 @@ struct net_bridge_fdb_entry {
 	unsigned long			updated ____cacheline_aligned_in_smp;
 	unsigned long			used;
 
-	struct rcu_head			rcu;
+	union {
+		struct {
+			struct hlist_head		offload_in;
+			struct hlist_head		offload_out;
+		};
+		struct rcu_head			rcu;
+	};
 };
 
 #define MDB_PG_FLAGS_PERMANENT		BIT(0)
@@ -224,6 +230,12 @@ struct net_bridge_mdb_htable
 	u32				ver;
 };
 
+struct net_bridge_port_offload {
+	struct rhashtable		rht;
+	struct work_struct		gc_work;
+	bool				enabled;
+};
+
 struct net_bridge_port {
 	struct net_bridge		*br;
 	struct net_device		*dev;
@@ -276,6 +288,7 @@ struct net_bridge_port {
 #ifdef CONFIG_NET_SWITCHDEV
 	int				offload_fwd_mark;
 #endif
+	struct net_bridge_port_offload	offload;
 };
 
 #define br_auto_port(p) ((p)->flags & BR_AUTO_MASK)
@@ -402,6 +415,9 @@ struct net_bridge {
 	struct kobject			*ifobj;
 	u32				auto_cnt;
 
+	u32				offload_cache_size;
+	u32				offload_cache_reserved;
+
 #ifdef CONFIG_NET_SWITCHDEV
 	int offload_fwd_mark;
 #endif
@@ -426,6 +442,10 @@ struct br_input_skb_cb {
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	bool vlan_filtered;
 #endif
+	u8 offload:1;
+	u8 input_vlan_present:1;
+	u16 input_vlan_tag;
+	int input_ifindex;
 
 #ifdef CONFIG_NET_SWITCHDEV
 	int offload_fwd_mark;
Index: net/bridge/br_stp.c
===================================================================
--- net/bridge/br_stp.c	(revision 49056)
+++ net/bridge/br_stp.c	(working copy)
@@ -16,6 +16,7 @@
 
 #include "br_private.h"
 #include "br_private_stp.h"
+#include "br_private_offload.h"
 
 /* since time values in bpdu are in jiffies and then scaled (1/256)
  * before sending, make sure that is at least one STP tick.
@@ -55,6 +56,8 @@ void br_set_state(struct net_bridge_port *p, unsig
 		br_info(p->br, "port %u(%s) entered %s state\n",
 				(unsigned int) p->port_no, p->dev->name,
 				br_port_state_names[p->state]);
+
+	br_offload_port_state(p);
 }
 
 /* called under bridge lock */
Index: net/bridge/br_sysfs_br.c
===================================================================
--- net/bridge/br_sysfs_br.c	(revision 49056)
+++ net/bridge/br_sysfs_br.c	(working copy)
@@ -22,6 +22,7 @@
 #include <linux/sched/signal.h>
 
 #include "br_private.h"
+#include "br_private_offload.h"
 
 #define to_bridge(cd)	((struct net_bridge *)netdev_priv(to_net_dev(cd)))
 
@@ -808,6 +809,38 @@ static ssize_t vlan_stats_enabled_store(struct dev
 static DEVICE_ATTR_RW(vlan_stats_enabled);
 #endif
 
+static ssize_t offload_cache_size_show(struct device *d,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct net_bridge *br = to_bridge(d);
+	return sprintf(buf, "%u\n", br->offload_cache_size);
+}
+
+static ssize_t offload_cache_size_store(struct device *d,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	return store_bridge_parm(d, buf, len, br_offload_set_cache_size);
+}
+static DEVICE_ATTR_RW(offload_cache_size);
+
+static ssize_t offload_cache_reserved_show(struct device *d,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct net_bridge *br = to_bridge(d);
+	return sprintf(buf, "%u\n", br->offload_cache_reserved);
+}
+
+static ssize_t offload_cache_reserved_store(struct device *d,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	return store_bridge_parm(d, buf, len, br_offload_set_cache_reserved);
+}
+static DEVICE_ATTR_RW(offload_cache_reserved);
+
 static struct attribute *bridge_attrs[] = {
 	&dev_attr_forward_delay.attr,
 	&dev_attr_hello_time.attr,
@@ -860,6 +893,8 @@ static struct attribute *bridge_attrs[] = {
 	&dev_attr_default_pvid.attr,
 	&dev_attr_vlan_stats_enabled.attr,
 #endif
+	&dev_attr_offload_cache_size.attr,
+	&dev_attr_offload_cache_reserved.attr,
 	NULL
 };
 
Index: net/bridge/br_sysfs_if.c
===================================================================
--- net/bridge/br_sysfs_if.c	(revision 49056)
+++ net/bridge/br_sysfs_if.c	(working copy)
@@ -179,6 +179,7 @@ BRPORT_ATTR_FLAG(multicast_flood, BR_MCAST_FLOOD);
 BRPORT_ATTR_FLAG(broadcast_flood, BR_BCAST_FLOOD);
 BRPORT_ATTR_FLAG(isolate_mode, BR_ISOLATE_MODE);
 BRPORT_ATTR_FLAG(block_bpdu, BR_BLOCK_BPDU);
+BRPORT_ATTR_FLAG(offload, BR_OFFLOAD);
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
@@ -230,6 +231,7 @@ static const struct brport_attribute *brport_attrs
 	&brport_attr_broadcast_flood,
 	&brport_attr_isolate_mode,
 	&brport_attr_block_bpdu,
+	&brport_attr_offload,
 	NULL
 };
 
Index: net/bridge/br_vlan_tunnel.c
===================================================================
--- net/bridge/br_vlan_tunnel.c	(revision 49056)
+++ net/bridge/br_vlan_tunnel.c	(working copy)
@@ -19,6 +19,7 @@
 
 #include "br_private.h"
 #include "br_private_tunnel.h"
+#include "br_private_offload.h"
 
 static inline int br_vlan_tunid_cmp(struct rhashtable_compare_arg *arg,
 				    const void *ptr)
@@ -184,6 +185,7 @@ int br_handle_ingress_vlan_tunnel(struct sk_buff *
 	skb_dst_drop(skb);
 
 	__vlan_hwaccel_put_tag(skb, p->br->vlan_proto, vlan->vid);
+	br_offload_skb_disable(skb);
 
 	return 0;
 }
@@ -207,6 +209,7 @@ int br_handle_egress_vlan_tunnel(struct sk_buff *s
 	if (err)
 		return err;
 
+	br_offload_skb_disable(skb);
 	tunnel_dst = rcu_dereference(vlan->tinfo.tunnel_dst);
 	if (tunnel_dst && dst_hold_safe(&tunnel_dst->dst))
 		skb_dst_set(skb, &tunnel_dst->dst);
